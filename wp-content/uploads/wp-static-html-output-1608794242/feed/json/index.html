{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/",
    "feed_url": "https://eloquentarduino.github.io/feed/json/",
    "language": "en-US",
    "title": "Eloquent Arduino Blog",
    "description": "Machine learning on Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/?p=1416",
            "url": "https://eloquentarduino.github.io/2020/12/tinyml-benchmark-table/",
            "title": "The Grand Benchmark Table of Embedded Machine Learning",
            "content_html": "<p>How tiny is TinyML? How <em>fast</em> is TinyML?</p>\n<p>Do you want to get some <em>REAL</em> numbers on embedded machine learning on Arduino, STM32, ESP32, Seeedstudio boards (and more coming)? </p>\n<p>This page will answer all your questions!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/Inference-time-vs-Accuracy-scatter-plot.png\" alt=\"Inference time vs Accuracy scatter plot\" /></p>\n<p><span id=\"more-1416\"></span></p>\n<h3>Background</h3>\n<p>If you're new to this blog, you need to know that (almost one year ago) I settled on a mission to <strong>bring machine learning to embedded microcontrollers of all sizes</strong> (<a href=\"/2019/12/machine-learning-on-attiny85/\">even the Attiny85</a>!).</p>\n<p>To me, it is just insane to deploy heavyweight Neural Networks to such small devices, if you don't need their expressiveness (mainly image and audio analysis). The vast majority of embedded ML tasks is, in fact, related to sensors' readings, which can easily be solved with &quot;traditional&quot; ML algorithms.</p>\n<p>Today's industry seems to be more leaned toward Neural Networks, though, so I thought it would be beneficial for you readers to get an actual grasp on the potential of traditional Machine learning algorithms in the embedded context.</p>\n<p>On this blog you can find posts about:</p>\n<ul>\n<li><a href=\"/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/\">Decision Tree, Random Forest and XGBoost</a></li>\n<li><a href=\"/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">Gaussian Naive Bayes</a></li>\n<li><a href=\"/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/\">SEFR - a binary classifier</a></li>\n<li><a href=\"/2020/06/arduino-dimensionality-reduction-pca-for-machine-learning-projects/\">PCA for dimensionality reduction</a></li>\n<li><a href=\"/2020/02/even-smaller-machine-learning-models-for-your-mcu/\">Relevant Vector Machines</a></li>\n<li><a href=\"/2019/12/how-to-do-gesture-identification-on-arduino/\">SVM for gesture detection</a></li>\n<li><a href=\"/2020/05/anomaly-detection-on-your-arduino-microcontroller-via-one-class-svm/\">One Class SVM for anomaly detection</a></li>\n</ul>\n<p>All these algorithms go a long way in both accuracy and resource comsumption, so (in my opinion) they should be your first choice when developing a new project.</p>\n<p>To support my claimings I made a huge effort to collect real world data, and now I want to share this data with you.</p>\n<p>Before you ask:</p>\n<p>&quot;Are Neural Networks models benchmarked here?&quot;. No.</p>\n<p>&quot;Will Neural Networks model be benchmarked in the future?&quot;. Yes, as soon as I'm comfortable with them: I want to create a fair comparison between NN and traditional algorithms.</p>\n<p>So now let's move to the contents.</p>\n<h3>The boards</h3>\n<p>I run the benchmarks on the boards I have at hand: they were all purchased by me, except for the Arduino Nano BLE Sense (given to me by the Arduino team).</p>\n<ul>\n<li><a href=\"https://ae01.alicdn.com/kf/H81a3be13b25244f09d8c538e2bea36e23/4-MB-Flash-Per-WeMos-D1-ESP32-ESP-32-ESP-32S-ESP32S-Wifi-Senza-Fili-di.jpg_Q90.jpg_.webp\">Espressif ESP32</a></li>\n<li><a href=\"https://www.mechatronicslab.net/my_uploads/2020/06/NodeMCU-ESP8266-Pinout-1.jpg\">Espressif ESP8266 NodeMCU v1.0</a></li>\n<li><a href=\"https://www.st.com/en/evaluation-tools/nucleo-l432kc.html\">STM32 Nucleo L432KC</a> (Cortex M4)</li>\n<li><a href=\"https://www.seeedstudio.com/Seeeduino-XIAO-Arduino-Microcontroller-SAMD21-Cortex-M0+-p-4426.html\">Seeedstudio XIAO</a> (SAMD21 Cortex M0)</li>\n<li><a href=\"https://store.arduino.cc/arduino-nano-33-ble-sense\">Arduino Nano 33 BLE Sense</a> (Cortex M4F)</li>\n</ul>\n<h3>The datasets</h3>\n<p>I picked a small selection of toy and real world datasets to benchmark the classifiers against (the real world ones were picked from a <a href=\"https://scholar.harvard.edu/files/vijay-janapa-reddi/files/tinymlsummit2020-4-4-janapareddi.pdf\">TinyML Talks presentation</a> when easily available, plus some more from the <a href=\"https://archive.ics.uci.edu/ml//datasets.php\">UCI database</a> almost at random).</p>\n<p>Here's the list of the benchmarked datasets, with the <em>shape</em> of the dataset (in the format <code>number of samples</code> x <code>number of features</code> x <code>number of classes</code>).</p>\n<ul>\n<li>Iris <code>(150 x 4 x 3)</code>: from the sklearn package</li>\n<li>Wine <code>(178 x 13 x 3)</code>: from the sklearn package</li>\n<li>Digits <code>(1797 x 64 x 10)</code>: from the sklearn package</li>\n<li><a href=\"https://archive.ics.uci.edu/ml/datasets/human+activity+recognition+using+smartphones\">Human Activity</a> <code>(10299 x 561 x 6)</code></li>\n<li><a href=\"https://archive.ics.uci.edu/ml/datasets/Daily+and+Sports+Activities\">Sport Activity</a> <code>(4800 x 180 x 10)</code></li>\n<li><a href=\"https://archive.ics.uci.edu/ml/datasets/Gas+Sensor+Array+Drift+Dataset\">Gas Sensor Array Drift</a> <code>(1000 x 128 x 6)</code></li>\n<li><a href=\"https://archive.ics.uci.edu/ml/datasets/EMG+data+for+gestures\">EMG</a> <code>(1648 x 63 x 5 )</code></li>\n<li><a href=\"https://archive.ics.uci.edu/ml/datasets/gesture+phase+segmentation\">Gesture Phase Segmentaion</a> <code>(1000 x 19 x 5)</code></li>\n<li><a href=\"https://archive.ics.uci.edu/ml/datasets/Statlog+%28Vehicle+Silhouettes%29\">Statlog (Vehicle Silhouettes)</a> <code>(846 x 18 x 4)</code></li>\n<li><a href=\"http://archive.ics.uci.edu/ml/datasets/mammographic+mass\">Mammographic Mass</a> <code>(830 x 4 x 2)</code></li>\n<li><a href=\"https://archive.ics.uci.edu/ml/datasets/dataset+for+sensorless+drive+diagnosis\">Sensorless Drive Diagnosis</a> <code>(1000 x 48 x 11)</code></li>\n</ul>\n<p>The datasets are chosen to be representative of different domains and the list will grow in the next weeks.</p>\n<p>Some datasets are used <em>as-is</em>, others were pre-processed with very light feature extraction. In detail:</p>\n<ul>\n<li><code>Human Activity</code> features were extracted with a rolling window, and for each window min/max/avg/std/skew/kurtosis were calculated</li>\n<li><code>Sport Activity</code> got the same pre-processing, and the number of actvities was reduced from 19 to 10</li>\n<li><code>EMG</code> features were extracted with a rolling window, and for each window the Root Mean Square value was calculated</li>\n</ul>\n<p>The reported benchmarks <strong>only consider the inference process</strong>: any feature extraction is not included! Nevertheless, only features with linear time complexity were used, so any MCU will have no problem in computing them.</p>\n<h3>The classifiers</h3>\n<p>The following classifiers are benchmarked:</p>\n<ul>\n<li>Decision Tree</li>\n<li>Random Forest</li>\n<li>XGBoost</li>\n<li>Logistic Regression</li>\n<li>Gaussian Naive Bayes</li>\n</ul>\n<p>Why these classifiers?</p>\n<p>Because they're all supported by the <a href=\"https://github.com/eloquentarduino/micromlgen\">micromlgen</a> package, so they can easily be ported to plain C.</p>\n<p>* <em>XGBoost porting failed on some datasets, so you will see holes in the data. I will correct this in the next weeks</em></p>\n<p><code>micromlgen</code> actually supports Support Vector Machines, too: it is not included because on real world datasets the number of support vector is so high (hundreds or even thousands) that no single board could handle that.</p>\n<p>If you want to stay up to date with the new numbers, subscribe to the newsletter: I promise you won't receive more than 1 mail per month.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the (more than) monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2>The Results</h2>\n<p>This section reports (a selection of) the charts generated from the benchmark results to give you a quick glance of the capabilities of the aforementioned boards and algorithms in terms of performance and accuracy.</p>\n<p>If you like an interactive view of the data, there's a <a href=\"https://colab.research.google.com/drive/1sl755xwwNyrFUVK1WtcqiOISpO2h8cMF?usp=sharing\">Colab Notebook</a> that reproduces the charts reported here, where you can interact with the data as you like.</p>\n<p>At the very end of the article, you can also find a link to the raw CSV file I generated (as you can see, it required A LOT of work to create).</p>\n<h3>Accuracy</h3>\n<p>The overall accuracy of each classifier on each dataset (this plot is not bounded to any particular board, it is computed &quot;offline&quot;).</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/Accuracy.png\" alt=\"TinyML Accuracy\" /></p>\n<p><strong>Comment</strong>:  many classifiers (Random Forest, XGBoost, Logistic Regression) can easily achieve up to 95+ % accuracy on some datasets with minimal pre-processing, while still scoring 85+ % on more difficult datasets.</p>\n<h3>Flash percent</h3>\n<p>These charts plot, for each dataset, how much flash (in percent on the total available) it takes for the classifier to compile (visit the <a href=\"https://colab.research.google.com/drive/1sl755xwwNyrFUVK1WtcqiOISpO2h8cMF?usp=sharing\">Colab Notebook</a> to see all the charts).</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/Human-Activity-Flash-percent.png\" alt=\"Human Activity Flash percent plot\" /></p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/Gesture-Phase-Flash-Percent.png\" alt=\"Gesture Phase Flash Percent plot\" /></p>\n<p><strong>Comment</strong>: DecisionTree, GaussianNB and Logistic Regression require the least amount of flash. XGBoost is very &quot;flash-intensive&quot;; RandomForest sits in the middle.</p>\n<h5>How tiny can TinyML be?</h5>\n<p>As low as 6% of flash size for a fully functional DecisionTree with 85+% accuracy.</p>\n<h3>Inference time</h3>\n<p>These charts plot, for each dataset, how long it takes for the classifier to run (only the classification, no feature extraction!).</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/EMG-Inference-time-plot.png\" alt=\"EMG Inference time plot\" /></p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/Sport-Activity-Inference-time-plot.png\" alt=\"Sport Activity Inference time plot\" /></p>\n<p><strong>Comment</strong>: DecisionTree is the clear winner here, with minimal inference time  (from 0.4 to 30 microseconds), followed by Random Forest. Logistic Regression, XGBoost and GaussianNB are the slowest.</p>\n<h5>How fast can TinyML be?</h5>\n<p>As fast as sub-millisecond inference time for a fully functional DecisionTree with 85+% accuracy.</p>\n<h3>Inference time vs Accuracy</h3>\n<p>This plot correlates the inference time vs the classification accuracy. The more upper-left a point is, the better (fast inference time, high accuracy).</p>\n<p><a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/Inference-time-vs-Accuracy-scatter-plot.png\">Click here to open the image at full size</a></p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/Inference-time-vs-Accuracy-scatter-plot.png\" alt=\"Inference time vs Accuracy scatter plot\" /></p>\n<p><strong>Comment</strong>: as already stated, you will see a lot of blue markers (Decision Tree) in the top left, since it is very fast and quite accurate. Moving to the right you can see purple (Logistic Regression) and orange (Random Forest).  GaussianNB (red) exhibits quite low accuracy instead.</p>\n<h3>Inference time vs Flash percent</h3>\n<p>This plot correlates the inference time vs the the (relative) flash requirement. The more lower-left a point is, the better (fast inference time, low flash requirements).</p>\n<p><a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/Inference-time-vs-Flash-percent-scatter-plot.png\">Click here to open the image at full size</a></p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/Inference-time-vs-Flash-percent-scatter-plot.png\" alt=\"Inference time vs Flash percent scatter plot\" /></p>\n<p><strong>Comment</strong>: Again, we see blue (Decision Tree) is both fast and small, followed by Logistic Regression and Random Forest. Now it is clear that XGBoost (green), while not being the slowest, is the more demanding in terms of flash.</p>\n<h2>Conclusions</h2>\n<p>I hope this post helped you broaden your view on TinyML, on how tiny it can be, how fast it can be (sub-millisecond inference!), how wide it is.</p>\n<p>Please don't hesitate to comment with your opinion on the subject, suggestions of new boards or datasets I should benchmark, or any other idea you have in mind that can contribute to the purpose of this page.</p>\n<p>And don't forget to stay tuned for the updates: I already have <strong>2 more boards</strong> I will benchmark in the next days!</p>\n<hr />\n<p>As promised, here's <a href=\"https://github.com/eloquentarduino/eloquentarduino.github.io/blob/master/UCI%20datasets.csv\">the link to the raw benchmarks in CSV format</a>.</p>\n<p>You can run your own analysis and visualization on it: if you use it in your own work, please add a link to this post.</p>\n<p>In future posts I will share how I collected all those numbers, so subscribe to the newsletter to stay up to date!</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the (more than) monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/12/tinyml-benchmark-table/\">The Grand Benchmark Table of Embedded Machine Learning</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "How tiny is TinyML? How fast is TinyML?\nDo you want to get some REAL numbers on embedded machine learning on Arduino, STM32, ESP32, Seeedstudio boards (and more coming)? \nThis page will answer all your questions!\n\n\nBackground\nIf you're new to this blog, you need to know that (almost one year ago) I settled on a mission to bring machine learning to embedded microcontrollers of all sizes (even the Attiny85!).\nTo me, it is just insane to deploy heavyweight Neural Networks to such small devices, if you don't need their expressiveness (mainly image and audio analysis). The vast majority of embedded ML tasks is, in fact, related to sensors' readings, which can easily be solved with &quot;traditional&quot; ML algorithms.\nToday's industry seems to be more leaned toward Neural Networks, though, so I thought it would be beneficial for you readers to get an actual grasp on the potential of traditional Machine learning algorithms in the embedded context.\nOn this blog you can find posts about:\n\nDecision Tree, Random Forest and XGBoost\nGaussian Naive Bayes\nSEFR - a binary classifier\nPCA for dimensionality reduction\nRelevant Vector Machines\nSVM for gesture detection\nOne Class SVM for anomaly detection\n\nAll these algorithms go a long way in both accuracy and resource comsumption, so (in my opinion) they should be your first choice when developing a new project.\nTo support my claimings I made a huge effort to collect real world data, and now I want to share this data with you.\nBefore you ask:\n&quot;Are Neural Networks models benchmarked here?&quot;. No.\n&quot;Will Neural Networks model be benchmarked in the future?&quot;. Yes, as soon as I'm comfortable with them: I want to create a fair comparison between NN and traditional algorithms.\nSo now let's move to the contents.\nThe boards\nI run the benchmarks on the boards I have at hand: they were all purchased by me, except for the Arduino Nano BLE Sense (given to me by the Arduino team).\n\nEspressif ESP32\nEspressif ESP8266 NodeMCU v1.0\nSTM32 Nucleo L432KC (Cortex M4)\nSeeedstudio XIAO (SAMD21 Cortex M0)\nArduino Nano 33 BLE Sense (Cortex M4F)\n\nThe datasets\nI picked a small selection of toy and real world datasets to benchmark the classifiers against (the real world ones were picked from a TinyML Talks presentation when easily available, plus some more from the UCI database almost at random).\nHere's the list of the benchmarked datasets, with the shape of the dataset (in the format number of samples x number of features x number of classes).\n\nIris (150 x 4 x 3): from the sklearn package\nWine (178 x 13 x 3): from the sklearn package\nDigits (1797 x 64 x 10): from the sklearn package\nHuman Activity (10299 x 561 x 6)\nSport Activity (4800 x 180 x 10)\nGas Sensor Array Drift (1000 x 128 x 6)\nEMG (1648 x 63 x 5 )\nGesture Phase Segmentaion (1000 x 19 x 5)\nStatlog (Vehicle Silhouettes) (846 x 18 x 4)\nMammographic Mass (830 x 4 x 2)\nSensorless Drive Diagnosis (1000 x 48 x 11)\n\nThe datasets are chosen to be representative of different domains and the list will grow in the next weeks.\nSome datasets are used as-is, others were pre-processed with very light feature extraction. In detail:\n\nHuman Activity features were extracted with a rolling window, and for each window min/max/avg/std/skew/kurtosis were calculated\nSport Activity got the same pre-processing, and the number of actvities was reduced from 19 to 10\nEMG features were extracted with a rolling window, and for each window the Root Mean Square value was calculated\n\nThe reported benchmarks only consider the inference process: any feature extraction is not included! Nevertheless, only features with linear time complexity were used, so any MCU will have no problem in computing them.\nThe classifiers\nThe following classifiers are benchmarked:\n\nDecision Tree\nRandom Forest\nXGBoost\nLogistic Regression\nGaussian Naive Bayes\n\nWhy these classifiers?\nBecause they're all supported by the micromlgen package, so they can easily be ported to plain C.\n* XGBoost porting failed on some datasets, so you will see holes in the data. I will correct this in the next weeks\nmicromlgen actually supports Support Vector Machines, too: it is not included because on real world datasets the number of support vector is so high (hundreds or even thousands) that no single board could handle that.\nIf you want to stay up to date with the new numbers, subscribe to the newsletter: I promise you won't receive more than 1 mail per month.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nThe Results\nThis section reports (a selection of) the charts generated from the benchmark results to give you a quick glance of the capabilities of the aforementioned boards and algorithms in terms of performance and accuracy.\nIf you like an interactive view of the data, there's a Colab Notebook that reproduces the charts reported here, where you can interact with the data as you like.\nAt the very end of the article, you can also find a link to the raw CSV file I generated (as you can see, it required A LOT of work to create).\nAccuracy\nThe overall accuracy of each classifier on each dataset (this plot is not bounded to any particular board, it is computed &quot;offline&quot;).\n\nComment:  many classifiers (Random Forest, XGBoost, Logistic Regression) can easily achieve up to 95+ % accuracy on some datasets with minimal pre-processing, while still scoring 85+ % on more difficult datasets.\nFlash percent\nThese charts plot, for each dataset, how much flash (in percent on the total available) it takes for the classifier to compile (visit the Colab Notebook to see all the charts).\n\n\nComment: DecisionTree, GaussianNB and Logistic Regression require the least amount of flash. XGBoost is very &quot;flash-intensive&quot;; RandomForest sits in the middle.\nHow tiny can TinyML be?\nAs low as 6% of flash size for a fully functional DecisionTree with 85+% accuracy.\nInference time\nThese charts plot, for each dataset, how long it takes for the classifier to run (only the classification, no feature extraction!).\n\n\nComment: DecisionTree is the clear winner here, with minimal inference time  (from 0.4 to 30 microseconds), followed by Random Forest. Logistic Regression, XGBoost and GaussianNB are the slowest.\nHow fast can TinyML be?\nAs fast as sub-millisecond inference time for a fully functional DecisionTree with 85+% accuracy.\nInference time vs Accuracy\nThis plot correlates the inference time vs the classification accuracy. The more upper-left a point is, the better (fast inference time, high accuracy).\nClick here to open the image at full size\n\nComment: as already stated, you will see a lot of blue markers (Decision Tree) in the top left, since it is very fast and quite accurate. Moving to the right you can see purple (Logistic Regression) and orange (Random Forest).  GaussianNB (red) exhibits quite low accuracy instead.\nInference time vs Flash percent\nThis plot correlates the inference time vs the the (relative) flash requirement. The more lower-left a point is, the better (fast inference time, low flash requirements).\nClick here to open the image at full size\n\nComment: Again, we see blue (Decision Tree) is both fast and small, followed by Logistic Regression and Random Forest. Now it is clear that XGBoost (green), while not being the slowest, is the more demanding in terms of flash.\nConclusions\nI hope this post helped you broaden your view on TinyML, on how tiny it can be, how fast it can be (sub-millisecond inference!), how wide it is.\nPlease don't hesitate to comment with your opinion on the subject, suggestions of new boards or datasets I should benchmark, or any other idea you have in mind that can contribute to the purpose of this page.\nAnd don't forget to stay tuned for the updates: I already have 2 more boards I will benchmark in the next days!\n\nAs promised, here's the link to the raw benchmarks in CSV format.\nYou can run your own analysis and visualization on it: if you use it in your own work, please add a link to this post.\nIn future posts I will share how I collected all those numbers, so subscribe to the newsletter to stay up to date!\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nL'articolo The Grand Benchmark Table of Embedded Machine Learning proviene da Eloquent Arduino Blog.",
            "date_published": "2020-12-16T21:31:10+01:00",
            "date_modified": "2020-12-20T17:13:28+01:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1390",
            "url": "https://eloquentarduino.github.io/2020/12/esp32-cam-motion-detection-with-photo-capture-grayscale-version/",
            "title": "Esp32-cam motion detection WITH PHOTO CAPTURE! (grayscale version)",
            "content_html": "<p>Do you want to transform your cheap esp32-cam in a DIY surveillance camera with <strong>moton detection AND photo capture</strong>?</p>\n<p>Look no further: this post explains STEP-BY-STEP all you need to know to build one yourself!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/12/esp32-cam-motion-detection.png\" alt=\"Esp32-cam motion detection\" /></p>\n<p><span id=\"more-1390\"></span></p>\n<p>As I told you in the <a href=\"/2020/05/easier-faster-pure-video-esp32-cam-motion-detection\">Easier, faster pure video Esp32-cam motion detection post</a>, motion detection on the esp32-cam seems to be the hottest topic on my blog, so I thought it deserved some more tutorials.</p>\n<p>Without question, to #1 request you made me in the comments was</p>\n<blockquote>\n<p>How can I save the image that triggered the motion detection to the disk?</p>\n</blockquote>\n<p>Well, in this post I will show you <strong>how to save the image to the SPIFFS</strong> filesystem your esp32-cam comes equipped with!</p>\n<h2>Motion detection, refactored</h2>\n<p><strong>Please read the post on <a href=\"/2020/05/easier-faster-pure-video-esp32-cam-motion-detection\">easier, faster esp32-cam motion detection</a> first if you want to understand the following code.</strong></p>\n<p>It took me quite some time to write this post because I was struggling to design a clear, easy to use API for the motion detection feature and the image storage.</p>\n<p>And I have to admit that, even after so long, I'm still not satisfied with the results.</p>\n<p>Nonetheless, it works, and it works well in my opinion, so I will publish this and maybe get feedback from you to help me improve (so please leave a comment if you have any suggestion).</p>\n<p>I won't bother you with the design considerations I took since this is an hands-on tutorial, so let's take a look at the code to implement motion detection on the esp32-cam or any other esp32 with a camera attached (I'm using the M5Stick camera).</p>\n<p>First of all, you need the <code>EloquentVision</code> library: you can install it either from <a href=\"https://github.com/eloquentarduino/EloquentVision\">Github</a> or using the Arduino IDE's Library Manager.</p>\n<p>Next, the code.</p>\n<pre><code class=\"language-cpp\">// Change according to your model\n// The models available are\n//   - CAMERA_MODEL_WROVER_KIT\n//   - CAMERA_MODEL_ESP_EYE\n//   - CAMERA_MODEL_M5STACK_PSRAM\n//   - CAMERA_MODEL_M5STACK_WIDE\n//   - CAMERA_MODEL_AI_THINKER\n#define CAMERA_MODEL_M5STACK_WIDE\n\n#include &lt;FS.h&gt;\n#include &lt;SPIFFS.h&gt;\n#include &quot;EloquentVision.h&quot;\n\n// set the resolution of the source image and the resolution of the downscaled image for the motion detection\n#define FRAME_SIZE FRAMESIZE_QVGA\n#define SOURCE_WIDTH 320\n#define SOURCE_HEIGHT 240\n#define CHANNELS 1\n#define DEST_WIDTH 32\n#define DEST_HEIGHT 24\n#define BLOCK_VARIATION_THRESHOLD 0.3\n#define MOTION_THRESHOLD 0.2\n\n// we&#039;re using the Eloquent::Vision namespace a lot!\nusing namespace Eloquent::Vision;\nusing namespace Eloquent::Vision::IO;\nusing namespace Eloquent::Vision::ImageProcessing;\nusing namespace Eloquent::Vision::ImageProcessing::Downscale;\nusing namespace Eloquent::Vision::ImageProcessing::DownscaleStrategies;\n\n// an easy interface to capture images from the camera\nESP32Camera camera;\n// the buffer to store the downscaled version of the image\nuint8_t resized[DEST_HEIGHT][DEST_WIDTH];\n// the downscaler algorithm\n// for more details see https://eloquentarduino.github.io/2020/05/easier-faster-pure-video-esp32-cam-motion-detection\nCross&lt;SOURCE_WIDTH, SOURCE_HEIGHT, DEST_WIDTH, DEST_HEIGHT&gt; crossStrategy;\n// the downscaler container\nDownscaler&lt;SOURCE_WIDTH, SOURCE_HEIGHT, CHANNELS, DEST_WIDTH, DEST_HEIGHT&gt; downscaler(&amp;crossStrategy);\n// the motion detection algorithm\nMotionDetection&lt;DEST_WIDTH, DEST_HEIGHT&gt; motion;\n\nvoid setup() {\n    Serial.begin(115200);\n    SPIFFS.begin(true);\n    camera.begin(FRAME_SIZE, PIXFORMAT_GRAYSCALE);\n    motion.setBlockVariationThreshold(BLOCK_VARIATION_THRESHOLD);\n}\n\nvoid loop() {\n    camera_fb_t *frame = camera.capture();\n\n    // resize image and detect motion\n    downscaler.downscale(frame-&gt;buf, resized);\n    motion.update(resized);\n    motion.detect();\n\n    if (motion.ratio() &gt; MOTION_THRESHOLD) {\n        Serial.println(&quot;Motion detected&quot;);\n\n        // here we want to save the image to disk\n    }\n}</code></pre>\n<h2>Save image to disk</h2>\n<p>Fine, we can detect motion!</p>\n<p>Now we want to save the triggering image to disk in a format that we can decode without any custom software. It would be cool if we could see the image using the native <a href=\"https://github.com/espressif/arduino-esp32/blob/master/libraries/WebServer/examples/FSBrowser/FSBrowser.ino\">Esp32 Filesystem Browser sketch</a>.</p>\n<p>Thankfully to the guys at espressif, the esp32 is able to encode a raw image to JPEG format: it is convenient to use (any PC on earth can read a jpeg) and it is also <em>fast</em>.</p>\n<p><em>and thanks to the reader ankaiser for pointing it out</em></p>\n<p>It's really easy to do thanks to the <a href=\"https://github.com/eloquentarduino/EloquentVision\">EloquentVision</a> library.</p>\n<pre><code class=\"language-cpp\">if (motion.ratio() &gt; MOTION_THRESHOLD) {\n        Serial.println(&quot;Motion detected&quot;);\n\n        // quality ranges from 10 to 64 -&gt; the higher, the more detailed\n        uint8_t quality = 30;\n        JpegWriter&lt;SOURCE_WIDTH, SOURCE_HEIGHT&gt; jpegWriter;\n        File imageFile = SPIFFS.open(&quot;/capture.jpg&quot;, &quot;wb&quot;);\n\n        // it takes &lt; 1 second for a 320x240 image and 4 Kb of space\n        jpegWriter.writeGrayscale(imageFile, frame-&gt;buf, quality);\n        imageFile.close();\n}</code></pre>\n<p>Well done! Now your image is on the disk and can be downloaded with the FSBrowser sketch.</p>\n<p>Now you have all the tools you need to create your own DIY surveillance camera with motion detection feature!</p>\n<p>You can use it to catch thieves (I discourage you to rely on such a rudimentary setup however!), to capture images of <em>wild</em> animals in your garden (birds, sqirrels or the like), or any other application you see fit.</p>\n<h3>Further improvements</h3>\n<p>Of course you may well understand that a proper motion detection setup should be more complex than the one presented here. Nevertheless, a couple of quick fixes can greatly improve the usability of this project with little effort. Here I suggest you a couple.</p>\n<p><strong>#1: Debouncing successive frames</strong>: the code presented in this post is a stripped down version of a <a href=\"https://github.com/eloquentarduino/EloquentVision/blob/master/examples/EasyMotionDetectionGrayscale/EasyMotionDetectionGrayscale.ino\">more complete esp32-cam motion detection example sketch</a>.</p>\n<p>That sketch implements a debouncing function to prevent writing &quot;ghost images&quot; (see the <a href=\"/2020/01/motion-detection-with-esp32-cam-only-arduino-version/\">original post on motion detection</a> for a clear evidence of this effect).</p>\n<p><strong>#2: Proper file naming</strong>: the example sketch uses a fixed filename for the image. This means any new image will overwrite the older, which may be undesiderable based on your requirements. A proper way to handle this would be to attach an RTC and name the image after the time it occurred (something like &quot;motion_2020-12-03_08:09:10.bmp&quot;)</p>\n<p><strong>#3: RGB images</strong>: this is something I'm working on. I mean, the Bitmap writer is there (so you could actually use it to store images on your esp32), but the multi-channel motion detection is driving me crazy, I need some more time to design it the way I want, so stay tuned!</p>\n<hr />\n<p>I hope you enjoyed this tutorial on esp32-cam motion detection with photo capture: it was born as a response to your asking, so don't be afraid and ask me anything: I will do my best to help you!</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/12/esp32-cam-motion-detection-with-photo-capture-grayscale-version/\">Esp32-cam motion detection WITH PHOTO CAPTURE! (grayscale version)</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Do you want to transform your cheap esp32-cam in a DIY surveillance camera with moton detection AND photo capture?\nLook no further: this post explains STEP-BY-STEP all you need to know to build one yourself!\n\n\nAs I told you in the Easier, faster pure video Esp32-cam motion detection post, motion detection on the esp32-cam seems to be the hottest topic on my blog, so I thought it deserved some more tutorials.\nWithout question, to #1 request you made me in the comments was\n\nHow can I save the image that triggered the motion detection to the disk?\n\nWell, in this post I will show you how to save the image to the SPIFFS filesystem your esp32-cam comes equipped with!\nMotion detection, refactored\nPlease read the post on easier, faster esp32-cam motion detection first if you want to understand the following code.\nIt took me quite some time to write this post because I was struggling to design a clear, easy to use API for the motion detection feature and the image storage.\nAnd I have to admit that, even after so long, I'm still not satisfied with the results.\nNonetheless, it works, and it works well in my opinion, so I will publish this and maybe get feedback from you to help me improve (so please leave a comment if you have any suggestion).\nI won't bother you with the design considerations I took since this is an hands-on tutorial, so let's take a look at the code to implement motion detection on the esp32-cam or any other esp32 with a camera attached (I'm using the M5Stick camera).\nFirst of all, you need the EloquentVision library: you can install it either from Github or using the Arduino IDE's Library Manager.\nNext, the code.\n// Change according to your model\n// The models available are\n//   - CAMERA_MODEL_WROVER_KIT\n//   - CAMERA_MODEL_ESP_EYE\n//   - CAMERA_MODEL_M5STACK_PSRAM\n//   - CAMERA_MODEL_M5STACK_WIDE\n//   - CAMERA_MODEL_AI_THINKER\n#define CAMERA_MODEL_M5STACK_WIDE\n\n#include &lt;FS.h&gt;\n#include &lt;SPIFFS.h&gt;\n#include &quot;EloquentVision.h&quot;\n\n// set the resolution of the source image and the resolution of the downscaled image for the motion detection\n#define FRAME_SIZE FRAMESIZE_QVGA\n#define SOURCE_WIDTH 320\n#define SOURCE_HEIGHT 240\n#define CHANNELS 1\n#define DEST_WIDTH 32\n#define DEST_HEIGHT 24\n#define BLOCK_VARIATION_THRESHOLD 0.3\n#define MOTION_THRESHOLD 0.2\n\n// we&#039;re using the Eloquent::Vision namespace a lot!\nusing namespace Eloquent::Vision;\nusing namespace Eloquent::Vision::IO;\nusing namespace Eloquent::Vision::ImageProcessing;\nusing namespace Eloquent::Vision::ImageProcessing::Downscale;\nusing namespace Eloquent::Vision::ImageProcessing::DownscaleStrategies;\n\n// an easy interface to capture images from the camera\nESP32Camera camera;\n// the buffer to store the downscaled version of the image\nuint8_t resized[DEST_HEIGHT][DEST_WIDTH];\n// the downscaler algorithm\n// for more details see https://eloquentarduino.github.io/2020/05/easier-faster-pure-video-esp32-cam-motion-detection\nCross&lt;SOURCE_WIDTH, SOURCE_HEIGHT, DEST_WIDTH, DEST_HEIGHT&gt; crossStrategy;\n// the downscaler container\nDownscaler&lt;SOURCE_WIDTH, SOURCE_HEIGHT, CHANNELS, DEST_WIDTH, DEST_HEIGHT&gt; downscaler(&amp;crossStrategy);\n// the motion detection algorithm\nMotionDetection&lt;DEST_WIDTH, DEST_HEIGHT&gt; motion;\n\nvoid setup() {\n    Serial.begin(115200);\n    SPIFFS.begin(true);\n    camera.begin(FRAME_SIZE, PIXFORMAT_GRAYSCALE);\n    motion.setBlockVariationThreshold(BLOCK_VARIATION_THRESHOLD);\n}\n\nvoid loop() {\n    camera_fb_t *frame = camera.capture();\n\n    // resize image and detect motion\n    downscaler.downscale(frame-&gt;buf, resized);\n    motion.update(resized);\n    motion.detect();\n\n    if (motion.ratio() &gt; MOTION_THRESHOLD) {\n        Serial.println(&quot;Motion detected&quot;);\n\n        // here we want to save the image to disk\n    }\n}\nSave image to disk\nFine, we can detect motion!\nNow we want to save the triggering image to disk in a format that we can decode without any custom software. It would be cool if we could see the image using the native Esp32 Filesystem Browser sketch.\nThankfully to the guys at espressif, the esp32 is able to encode a raw image to JPEG format: it is convenient to use (any PC on earth can read a jpeg) and it is also fast.\nand thanks to the reader ankaiser for pointing it out\nIt's really easy to do thanks to the EloquentVision library.\nif (motion.ratio() &gt; MOTION_THRESHOLD) {\n        Serial.println(&quot;Motion detected&quot;);\n\n        // quality ranges from 10 to 64 -&gt; the higher, the more detailed\n        uint8_t quality = 30;\n        JpegWriter&lt;SOURCE_WIDTH, SOURCE_HEIGHT&gt; jpegWriter;\n        File imageFile = SPIFFS.open(&quot;/capture.jpg&quot;, &quot;wb&quot;);\n\n        // it takes &lt; 1 second for a 320x240 image and 4 Kb of space\n        jpegWriter.writeGrayscale(imageFile, frame-&gt;buf, quality);\n        imageFile.close();\n}\nWell done! Now your image is on the disk and can be downloaded with the FSBrowser sketch.\nNow you have all the tools you need to create your own DIY surveillance camera with motion detection feature!\nYou can use it to catch thieves (I discourage you to rely on such a rudimentary setup however!), to capture images of wild animals in your garden (birds, sqirrels or the like), or any other application you see fit.\nFurther improvements\nOf course you may well understand that a proper motion detection setup should be more complex than the one presented here. Nevertheless, a couple of quick fixes can greatly improve the usability of this project with little effort. Here I suggest you a couple.\n#1: Debouncing successive frames: the code presented in this post is a stripped down version of a more complete esp32-cam motion detection example sketch.\nThat sketch implements a debouncing function to prevent writing &quot;ghost images&quot; (see the original post on motion detection for a clear evidence of this effect).\n#2: Proper file naming: the example sketch uses a fixed filename for the image. This means any new image will overwrite the older, which may be undesiderable based on your requirements. A proper way to handle this would be to attach an RTC and name the image after the time it occurred (something like &quot;motion_2020-12-03_08:09:10.bmp&quot;)\n#3: RGB images: this is something I'm working on. I mean, the Bitmap writer is there (so you could actually use it to store images on your esp32), but the multi-channel motion detection is driving me crazy, I need some more time to design it the way I want, so stay tuned!\n\nI hope you enjoyed this tutorial on esp32-cam motion detection with photo capture: it was born as a response to your asking, so don't be afraid and ask me anything: I will do my best to help you!\nL'articolo Esp32-cam motion detection WITH PHOTO CAPTURE! (grayscale version) proviene da Eloquent Arduino Blog.",
            "date_published": "2020-12-03T18:50:59+01:00",
            "date_modified": "2020-12-06T09:31:20+01:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "Computer vision",
                "Eloquent library"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1365",
            "url": "https://eloquentarduino.github.io/2020/11/tinyml-on-arduino-and-stm32-cnn-convolutional-neural-network-example/",
            "title": "TinyML on Arduino and STM32: CNN (Convolutional Neural Network) example",
            "content_html": "<p>Painless TinyML Convolutional Neural Network on your Arduino and STM32 boards: the MNIST dataset example!</p>\n<p>Are you fascinated by TinyML and Tensorflow for microcontrollers? </p>\n<p>Do you want to run a CNN (Convolutional Neural Network) on your Arduino and STM32 boards? </p>\n<p>Do you want to do it without pain? </p>\n<p>EloquentTinyML is the library for you!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/11/CNN-topology.png\" alt=\"CNN topology\" /></p>\n<p><span id=\"more-1365\"></span></p>\n<p><a href=\"https://github.com/eloquentarduino/EloquentTinyML\">EloquentTinyML</a>, my library to easily run Tensorflow Lite neural networks on Arduino microcontrollers, is gaining some popularity so I think it's time for a good tutorial on the topic.</p>\n<p>If you're a seasoned follower of my blog, you may know that I don't really like Tensorflow on microcontrollers, because it is often <em>&quot;over-sized&quot;</em> for the project at hand and there are <a href=\"/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">leaner</a>, <a href=\"/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/\">faster</a> <a href=\"/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/\">alternatives</a>.</p>\n<p>Nonetheless, Tensorflow is gaining much popularity in the embedded world so I'll try to give my contribute too.</p>\n<p>In this tutorial, I'm going to show you <strong>step by step</strong> how to train a CNN in Tensorflow and deploy it to you board: I tested the code both on the <strong>Arduino Nano 33 BLE Sense</strong> and the <strong>STM32 Nucleus L432KC</strong>.</p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tochow-to-train-a-cnn-in-tensorflow\">How to train a CNN in Tensorflow</a><ol><li><a href=\"#tocstep-1-import-the-libraries\">Step 1. Import the libraries</a><li><a href=\"#tocstep-2-generate-train-validation-and-test-data\">Step 2. Generate train, validation and test data</a><li><a href=\"#tocstep-3-create-and-train-the-model\">Step 3. Create and train the model</a><li><a href=\"#tocstep-4-testing-the-model-accuracy\">Step 4. Testing the model accuracy</a><li><a href=\"#tocstep-5-exporting-the-model\">Step 5. Exporting the model</a></li></ol><li><a href=\"#tochow-to-run-a-cnn-on-arduino-and-stm32-boards-with-eloquenttinyml\">How to run a CNN on Arduino and STM32 boards with EloquentTinyML</a><ol><li><a href=\"#toccnn-on-arduino-and-stm32-figures\">CNN on Arduino and STM32 figures</a></li></ol><li><a href=\"#tocand-you\">And you?</a></ol></div></p>\n<h2 id=\"tochow-to-train-a-cnn-in-tensorflow\">How to train a CNN in Tensorflow</h2>\n<p>I'm not an expert either in Tensorflow nor Convolutional Neural Networks, so I kept the project as simple as possible. I used an <em>image-like</em> dataset to create a setup where CNN should perform well: the dataset is the <a href=\"http://yann.lecun.com/exdb/mnist/\">MNIST handwritten digits</a> one.</p>\n<p><img src=\"https://miro.medium.com/max/800/1*LyRlX__08q40UJohhJG9Ow.png\" alt=\"MNIST dataset example\" /></p>\n<p>It is composed by <strong>8x8</strong> images of handwritten digits, from 0 to 9 and can be easily imported via the <code>scikit-learn</code> Python package.</p>\n<p>Regarding the CNN topology, I wanted to stay as lean as possible: the goal of this tutorial is to teach you how to deploy your own network, not about achieving 100% accuracy.</p>\n<p>Let's see step by step how to produce a usable model.</p>\n<h3 id=\"tocstep-1-import-the-libraries\">Step 1. Import the libraries</h3>\n<p>We will need <code>numpy</code> and <code>Tensorflow</code>, of course, plus <code>scikit-learn</code> to load the dataset and <a href=\"https://github.com/eloquentarduino/tinymlgen\">tinymlgen</a> to port the CNN to plain C.</p>\n<pre><code class=\"language-python\">import numpy as np\nfrom sklearn.datasets import load_digits\nimport tensorflow as tf\nfrom tensorflow.keras import layers\nfrom tinymlgen import port</code></pre>\n<h3 id=\"tocstep-2-generate-train-validation-and-test-data\">Step 2. Generate train, validation and test data</h3>\n<p>To train the network, we need:</p>\n<ul>\n<li><code>training data</code>: this is the data the network uses to learn its weights</li>\n<li><code>validation data</code>: this is the data the network uses to understand if it's doing well during learning</li>\n<li><code>test data</code>: this is the data we use to test the network accuracy once it's done learning</li>\n</ul>\n<pre><code class=\"language-python\">def get_data():\n    np.random.seed(1337)\n    x_values, y_values = load_digits(return_X_y=True)\n    x_values /= x_values.max()\n    # reshape to (8 x 8 x 1)\n    x_values = x_values.reshape((len(x_values), 8, 8, 1))\n\n    # split into train, validation, test\n    TRAIN_SPLIT = int(0.6 * len(x_values))\n    TEST_SPLIT = int(0.2 * len(x_values) + TRAIN_SPLIT)\n    x_train, x_test, x_validate = np.split(x_values, [TRAIN_SPLIT, TEST_SPLIT])\n    y_train, y_test, y_validate = np.split(y_values, [TRAIN_SPLIT, TEST_SPLIT])\n\n    return x_train, x_test, x_validate, y_train, y_test, y_validate</code></pre>\n<h3 id=\"tocstep-3-create-and-train-the-model\">Step 3. Create and train the model</h3>\n<p>Now we have to create our network topology.</p>\n<p>As I stated earlier, I wanted to keep this as simple as possible (also considering that we're using a toy dataset): I added a single convolution layer (without even max pooling) followed by the output layer.</p>\n<pre><code class=\"language-python\">def get_model():\n    x_train, x_test, x_validate, y_train, y_test, y_validate = get_data()\n\n    # create a CNN\n    model = tf.keras.Sequential()\n    model.add(layers.Conv2D(8, (3, 3), activation=&#039;relu&#039;, input_shape=(8, 8, 1)))\n    # model.add(layers.MaxPooling2D((2, 2)))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(len(np.unique(y_train))))\n\n    model.compile(optimizer=&#039;adam&#039;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[&#039;accuracy&#039;])\n    model.fit(x_train, y_train, epochs=50, batch_size=16,\n                        validation_data=(x_validate, y_validate))\n    return model, x_test, y_test</code></pre>\n<h3 id=\"tocstep-4-testing-the-model-accuracy\">Step 4. Testing the model accuracy</h3>\n<p>Do you think this topology is too simple to learn something useful in so few epochs?</p>\n<p>Think again: it achieved <strong>97%</strong> accuracy!</p>\n<p>Not bad.</p>\n<pre><code class=\"language-python\">def test_model(model, x_test, y_test):\n    x_test = (x_test / x_test.max()).reshape((len(x_test), 8, 8, 1))\n    y_pred = model.predict(x_test).argmax(axis=1)\n\n    print(&#039;ACCURACY&#039;, (y_pred == y_test).sum() / len(y_test))</code></pre>\n<h3 id=\"tocstep-5-exporting-the-model\">Step 5. Exporting the model</h3>\n<p>Once we have a trained model that performs well, we want to deploy it to our microcontroller. Thanks to the <code>tinymlgen</code> packages, is as easy as a one-liner.</p>\n<pre><code class=\"language-python\">if __name__ == &#039;__main__&#039;:\n    model, x_test, y_test = get_model()\n    test_model(model, x_test, y_test)\n    c_code = port(model, variable_name=&#039;digits_model&#039;, pretty_print=True)\n    print(c_code)</code></pre>\n<h2 id=\"tochow-to-run-a-cnn-on-arduino-and-stm32-boards-with-eloquenttinyml\">How to run a CNN on Arduino and STM32 boards with EloquentTinyML</h2>\n<p>Ok, now we have the content we need to create an Arduino sketch to run the CNN on our microcontroller.</p>\n<p>We will use the <code>EloquentTinyML</code> library to do this without pain.</p>\n<p>This is a library to run TinyML models on your microcontroller without messing around with complex compilation procedures and esoteric errors.</p>\n<p>You must first install the library at its latest version (0.0.5 or 0.0.4 if not available), either via the Library Manager or directly from Github.</p>\n<pre><code class=\"language-cpp\">#include &lt;EloquentTinyML.h&gt;\n\n// copy the printed code from tinymlgen into this file\n#include &quot;digits_model.h&quot;\n\n#define NUMBER_OF_INPUTS 64\n#define NUMBER_OF_OUTPUTS 10\n#define TENSOR_ARENA_SIZE 8*1024\n\nEloquent::TinyML::TfLite&lt;NUMBER_OF_INPUTS, NUMBER_OF_OUTPUTS, TENSOR_ARENA_SIZE&gt; ml;\n\nvoid setup() {\n    Serial.begin(115200);\n    ml.begin(digits_model);\n}\n\nvoid loop() {\n    // a random sample from the MNIST dataset (precisely the last one)\n    float x_test[64] = { 0., 0. , 0.625 , 0.875 , 0.5   , 0.0625, 0. , 0. ,\n                    0. , 0.125 , 1. , 0.875 , 0.375 , 0.0625, 0. , 0. ,\n                    0. , 0. , 0.9375, 0.9375, 0.5   , 0.9375, 0. , 0. ,\n                    0. , 0. , 0.3125, 1. , 1. , 0.625 , 0. , 0. ,\n                    0. , 0. , 0.75  , 0.9375, 0.9375, 0.75  , 0. , 0. ,\n                    0. , 0.25  , 1. , 0.375 , 0.25  , 1. , 0.375 , 0. ,\n                    0. , 0.5   , 1. , 0.625 , 0.5   , 1. , 0.5   , 0. ,\n                    0. , 0.0625, 0.5   , 0.75  , 0.875 , 0.75  , 0.0625, 0. };\n    // the output vector for the model predictions\n    float y_pred[10] = {0};\n    // the actual class of the sample\n    int y_test = 8;\n\n    // let&#039;s see how long it takes to classify the sample\n    uint32_t start = micros();\n\n    ml.predict(x_test, y_pred);\n\n    uint32_t timeit = micros() - start;\n\n    Serial.print(&quot;It took &quot;);\n    Serial.print(timeit);\n    Serial.println(&quot; micros to run inference&quot;);\n\n    // let&#039;s print the raw predictions for all the classes\n    // these values are not directly interpretable as probabilities!\n    Serial.print(&quot;Test output is: &quot;);\n    Serial.println(y_test);\n    Serial.print(&quot;Predicted proba are: &quot;);\n\n    for (int i = 0; i &lt; 10; i++) {\n        Serial.print(y_pred[i]);\n        Serial.print(i == 9 ? &#039;\\n&#039; : &#039;,&#039;);\n    }\n\n    // let&#039;s print the &quot;most probable&quot; class\n    // you can either use probaToClass() if you also want to use all the probabilities\n    Serial.print(&quot;Predicted class is: &quot;);\n    Serial.println(ml.probaToClass(y_pred));\n    // or you can skip the predict() method and call directly predictClass()\n    Serial.print(&quot;Sanity check: &quot;);\n    Serial.println(ml.predictClass(x_test));\n\n    delay(1000);\n}</code></pre>\n<p>That's it: if everything went fine, you should see that the predicted class is <code>8</code>.</p>\n<h3 id=\"toccnn-on-arduino-and-stm32-figures\">CNN on Arduino and STM32 figures</h3>\n<p>I'll report the figures I get for compiling and running this project on the two boards I used.</p>\n<table>\n<thead>\n<tr>\n<th>Board</th>\n<th style=\"text-align: right;\">Flash</th>\n<th style=\"text-align: right;\">RAM</th>\n<th style=\"text-align: right;\">Inference time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Nucleus  L432KC</td>\n<td style=\"text-align: right;\">154560</td>\n<td style=\"text-align: right;\">not available*</td>\n<td style=\"text-align: right;\">7187</td>\n</tr>\n<tr>\n<td>Arduino Nano 33 BLE Sense</td>\n<td style=\"text-align: right;\">197656</td>\n<td style=\"text-align: right;\">56160</td>\n<td style=\"text-align: right;\">9400</td>\n</tr>\n</tbody>\n</table>\n<p><em>I used the Grumpyoldpizza compiler for the Nucleus, which doesn't report back the RAM usage</em></p>\n<h2 id=\"tocand-you\">And you?</h2>\n<p>Were you able to deploy a CNN to your microcontroller thanks to this tutorial? Or are you having troubles?</p>\n<p>Let me know in the comment and I will help you or share your experience with us.</p>\n<hr />\n<p>You can find the whole code on <a href=\"https://github.com/eloquentarduino/EloquentTinyML/tree/master/examples/DigitsExample\">Github</a>.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/11/tinyml-on-arduino-and-stm32-cnn-convolutional-neural-network-example/\">TinyML on Arduino and STM32: CNN (Convolutional Neural Network) example</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Painless TinyML Convolutional Neural Network on your Arduino and STM32 boards: the MNIST dataset example!\nAre you fascinated by TinyML and Tensorflow for microcontrollers? \nDo you want to run a CNN (Convolutional Neural Network) on your Arduino and STM32 boards? \nDo you want to do it without pain? \nEloquentTinyML is the library for you!\n\n\nEloquentTinyML, my library to easily run Tensorflow Lite neural networks on Arduino microcontrollers, is gaining some popularity so I think it's time for a good tutorial on the topic.\nIf you're a seasoned follower of my blog, you may know that I don't really like Tensorflow on microcontrollers, because it is often &quot;over-sized&quot; for the project at hand and there are leaner, faster alternatives.\nNonetheless, Tensorflow is gaining much popularity in the embedded world so I'll try to give my contribute too.\nIn this tutorial, I'm going to show you step by step how to train a CNN in Tensorflow and deploy it to you board: I tested the code both on the Arduino Nano 33 BLE Sense and the STM32 Nucleus L432KC.\nTable of contentsHow to train a CNN in TensorflowStep 1. Import the librariesStep 2. Generate train, validation and test dataStep 3. Create and train the modelStep 4. Testing the model accuracyStep 5. Exporting the modelHow to run a CNN on Arduino and STM32 boards with EloquentTinyMLCNN on Arduino and STM32 figuresAnd you?\nHow to train a CNN in Tensorflow\nI'm not an expert either in Tensorflow nor Convolutional Neural Networks, so I kept the project as simple as possible. I used an image-like dataset to create a setup where CNN should perform well: the dataset is the MNIST handwritten digits one.\n\nIt is composed by 8x8 images of handwritten digits, from 0 to 9 and can be easily imported via the scikit-learn Python package.\nRegarding the CNN topology, I wanted to stay as lean as possible: the goal of this tutorial is to teach you how to deploy your own network, not about achieving 100% accuracy.\nLet's see step by step how to produce a usable model.\nStep 1. Import the libraries\nWe will need numpy and Tensorflow, of course, plus scikit-learn to load the dataset and tinymlgen to port the CNN to plain C.\nimport numpy as np\nfrom sklearn.datasets import load_digits\nimport tensorflow as tf\nfrom tensorflow.keras import layers\nfrom tinymlgen import port\nStep 2. Generate train, validation and test data\nTo train the network, we need:\n\ntraining data: this is the data the network uses to learn its weights\nvalidation data: this is the data the network uses to understand if it's doing well during learning\ntest data: this is the data we use to test the network accuracy once it's done learning\n\ndef get_data():\n    np.random.seed(1337)\n    x_values, y_values = load_digits(return_X_y=True)\n    x_values /= x_values.max()\n    # reshape to (8 x 8 x 1)\n    x_values = x_values.reshape((len(x_values), 8, 8, 1))\n\n    # split into train, validation, test\n    TRAIN_SPLIT = int(0.6 * len(x_values))\n    TEST_SPLIT = int(0.2 * len(x_values) + TRAIN_SPLIT)\n    x_train, x_test, x_validate = np.split(x_values, [TRAIN_SPLIT, TEST_SPLIT])\n    y_train, y_test, y_validate = np.split(y_values, [TRAIN_SPLIT, TEST_SPLIT])\n\n    return x_train, x_test, x_validate, y_train, y_test, y_validate\nStep 3. Create and train the model\nNow we have to create our network topology.\nAs I stated earlier, I wanted to keep this as simple as possible (also considering that we're using a toy dataset): I added a single convolution layer (without even max pooling) followed by the output layer.\ndef get_model():\n    x_train, x_test, x_validate, y_train, y_test, y_validate = get_data()\n\n    # create a CNN\n    model = tf.keras.Sequential()\n    model.add(layers.Conv2D(8, (3, 3), activation=&#039;relu&#039;, input_shape=(8, 8, 1)))\n    # model.add(layers.MaxPooling2D((2, 2)))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(len(np.unique(y_train))))\n\n    model.compile(optimizer=&#039;adam&#039;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[&#039;accuracy&#039;])\n    model.fit(x_train, y_train, epochs=50, batch_size=16,\n                        validation_data=(x_validate, y_validate))\n    return model, x_test, y_test\nStep 4. Testing the model accuracy\nDo you think this topology is too simple to learn something useful in so few epochs?\nThink again: it achieved 97% accuracy!\nNot bad.\ndef test_model(model, x_test, y_test):\n    x_test = (x_test / x_test.max()).reshape((len(x_test), 8, 8, 1))\n    y_pred = model.predict(x_test).argmax(axis=1)\n\n    print(&#039;ACCURACY&#039;, (y_pred == y_test).sum() / len(y_test))\nStep 5. Exporting the model\nOnce we have a trained model that performs well, we want to deploy it to our microcontroller. Thanks to the tinymlgen packages, is as easy as a one-liner.\nif __name__ == &#039;__main__&#039;:\n    model, x_test, y_test = get_model()\n    test_model(model, x_test, y_test)\n    c_code = port(model, variable_name=&#039;digits_model&#039;, pretty_print=True)\n    print(c_code)\nHow to run a CNN on Arduino and STM32 boards with EloquentTinyML\nOk, now we have the content we need to create an Arduino sketch to run the CNN on our microcontroller.\nWe will use the EloquentTinyML library to do this without pain.\nThis is a library to run TinyML models on your microcontroller without messing around with complex compilation procedures and esoteric errors.\nYou must first install the library at its latest version (0.0.5 or 0.0.4 if not available), either via the Library Manager or directly from Github.\n#include &lt;EloquentTinyML.h&gt;\n\n// copy the printed code from tinymlgen into this file\n#include &quot;digits_model.h&quot;\n\n#define NUMBER_OF_INPUTS 64\n#define NUMBER_OF_OUTPUTS 10\n#define TENSOR_ARENA_SIZE 8*1024\n\nEloquent::TinyML::TfLite&lt;NUMBER_OF_INPUTS, NUMBER_OF_OUTPUTS, TENSOR_ARENA_SIZE&gt; ml;\n\nvoid setup() {\n    Serial.begin(115200);\n    ml.begin(digits_model);\n}\n\nvoid loop() {\n    // a random sample from the MNIST dataset (precisely the last one)\n    float x_test[64] = { 0., 0. , 0.625 , 0.875 , 0.5   , 0.0625, 0. , 0. ,\n                    0. , 0.125 , 1. , 0.875 , 0.375 , 0.0625, 0. , 0. ,\n                    0. , 0. , 0.9375, 0.9375, 0.5   , 0.9375, 0. , 0. ,\n                    0. , 0. , 0.3125, 1. , 1. , 0.625 , 0. , 0. ,\n                    0. , 0. , 0.75  , 0.9375, 0.9375, 0.75  , 0. , 0. ,\n                    0. , 0.25  , 1. , 0.375 , 0.25  , 1. , 0.375 , 0. ,\n                    0. , 0.5   , 1. , 0.625 , 0.5   , 1. , 0.5   , 0. ,\n                    0. , 0.0625, 0.5   , 0.75  , 0.875 , 0.75  , 0.0625, 0. };\n    // the output vector for the model predictions\n    float y_pred[10] = {0};\n    // the actual class of the sample\n    int y_test = 8;\n\n    // let&#039;s see how long it takes to classify the sample\n    uint32_t start = micros();\n\n    ml.predict(x_test, y_pred);\n\n    uint32_t timeit = micros() - start;\n\n    Serial.print(&quot;It took &quot;);\n    Serial.print(timeit);\n    Serial.println(&quot; micros to run inference&quot;);\n\n    // let&#039;s print the raw predictions for all the classes\n    // these values are not directly interpretable as probabilities!\n    Serial.print(&quot;Test output is: &quot;);\n    Serial.println(y_test);\n    Serial.print(&quot;Predicted proba are: &quot;);\n\n    for (int i = 0; i &lt; 10; i++) {\n        Serial.print(y_pred[i]);\n        Serial.print(i == 9 ? &#039;\\n&#039; : &#039;,&#039;);\n    }\n\n    // let&#039;s print the &quot;most probable&quot; class\n    // you can either use probaToClass() if you also want to use all the probabilities\n    Serial.print(&quot;Predicted class is: &quot;);\n    Serial.println(ml.probaToClass(y_pred));\n    // or you can skip the predict() method and call directly predictClass()\n    Serial.print(&quot;Sanity check: &quot;);\n    Serial.println(ml.predictClass(x_test));\n\n    delay(1000);\n}\nThat's it: if everything went fine, you should see that the predicted class is 8.\nCNN on Arduino and STM32 figures\nI'll report the figures I get for compiling and running this project on the two boards I used.\n\n\n\nBoard\nFlash\nRAM\nInference time\n\n\n\n\nNucleus  L432KC\n154560\nnot available*\n7187\n\n\nArduino Nano 33 BLE Sense\n197656\n56160\n9400\n\n\n\nI used the Grumpyoldpizza compiler for the Nucleus, which doesn't report back the RAM usage\nAnd you?\nWere you able to deploy a CNN to your microcontroller thanks to this tutorial? Or are you having troubles?\nLet me know in the comment and I will help you or share your experience with us.\n\nYou can find the whole code on Github.\nL'articolo TinyML on Arduino and STM32: CNN (Convolutional Neural Network) example proviene da Eloquent Arduino Blog.",
            "date_published": "2020-11-10T17:37:13+01:00",
            "date_modified": "2020-11-10T19:10:06+01:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "Senza categoria"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1264",
            "url": "https://eloquentarduino.github.io/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/",
            "title": "Decision Tree, Random Forest and XGBoost on Arduino",
            "content_html": "<p>You will be surprised by how much accuracy you can achieve in just a few kylobytes of resources: <strong>Decision Tree, Random Forest and XGBoost (Extreme Gradient Boosting)</strong> are now available on your microcontrollers: highly RAM-optmized implementations for super-fast classification on embedded devices.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/DecisionTree.png\" alt=\"DecisionTree\" /></p>\n<p><span id=\"more-1264\"></span></p>\n<h2>Decision Tree</h2>\n<p><strong>Decision Tree</strong> is without doubt one of the most well-known classification algorithms out there. It is so simple to understand that it was probably the first classifier you encountered in any Machine Learning course.</p>\n<p>I won't go into the details of how a Decision Tree classifier trains and selects the splits for the input features: here I will explain how a RAM-efficient porting of such a classifier is implemented.</p>\n<p>To an introduction visit <a href=\"https://en.wikipedia.org/wiki/Decision_tree_learning\">Wikipedia</a>; for a more in-depth guide visit <a href=\"https://www.kdnuggets.com/2020/01/decision-tree-algorithm-explained.html\">KDNuggets</a>.</p>\n<p>Since we're willing to sacrifice program space (a.k.a flash) in favor of memory (a.k.a RAM), because RAM is the most scarce resource in the vast majority of microcontrollers, the smart way to port a Decision Tree classifier from Python to C is &quot;hard-coding&quot; the splits in code, without keeping any reference to them into variables.</p>\n<p>Here's what it looks like for a Decision tree that classifies the Iris dataset.</p>\n<p>As you can see, we're using <strong>0 bytes of RAM</strong> to get the classification result, since no variable is being allocated. On the other side, the program space will grow almost linearly with the number of splits.</p>\n<p>Since program space is often much greater than RAM on microcontrollers, this implementation exploits its abundance to be able to deploy larger models. How much large? It will depend on the flash size available: many new generations board (Arduino Nano 33 BLE Sense, ESP32, ST Nucleus...) have 1 Mb of flash, which will hold tens of thousands of splits. </p>\n<h2>Random Forest</h2>\n<p><strong><a href=\"https://en.wikipedia.org/wiki/Random_forest\">Random Forest</a></strong> is just many Decision Trees joined together in a voting scheme. The core idea is that of <em>&quot;the wisdom of the corwd&quot;</em>, such that if many trees vote for a given class (having being trained on different subsets of the training set), that class is probably the true class.</p>\n<p><a href=\"https://towardsdatascience.com/understanding-random-forest-58381e0602d2\">Towards Data Science</a> has a more detailed guide on Random Forest and how it balances the trees with the<em>bagging</em> tecnique.</p>\n<p>As easy as Decision Trees, Random Forest gets the exact same implementation with <strong>0 bytes of RAM</strong> required (it actually needs as many bytes as the number of classes to store the votes, but that's really negligible): it just hard-codes all its composing trees.</p>\n<h2>XGBoost (Extreme Gradient Boosting)</h2>\n<p>Extreme Gradient Boosting is <em>&quot;Gradient Boosting on steroids&quot;</em> and has gained much attention from the Machine learning community due to its top results in many data competitions.</p>\n<ol>\n<li>&quot;gradient boosting&quot; refers to the process of chaining a number of trees so that each tree tries to learn from the errors of the previous</li>\n<li>&quot;extreme&quot; refers to many software and hardware optimizations that greatly reduce the time it takes to train the model</li>\n</ol>\n<p>You can read <a href=\"https://www.kdd.org/kdd2016/papers/files/rfp0697-chenAemb.pdf\">the original paper about XGBoost here</a>. For a discursive description head to <a href=\"https://www.kdnuggets.com/2019/05/xgboost-algorithm.html\">KDNuggets</a>, if you want some more math refer to <a href=\"https://medium.com/@gabrieltseng/gradient-boosting-and-xgboost-c306c1bcfaf5\">this blog post on Medium</a>.</p>\n<h2>Porting to plain C</h2>\n<p>If you followed my earlier posts on <a href=\"/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">Gaussian Naive Bayes</a>, <a href=\"https://eloquentarduino.github.io/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/\">SEFR</a>, <a href=\"/2020/02/even-smaller-machine-learning-models-for-your-mcu/\">Relevant Vector Machine</a> and <a href=\"/2019/11/you-can-run-machine-learning-on-arduino/\">Support Vector Machines</a>, you already know how to port these new classifiers.</p>\n<p>If you're new, you will need a couple things:</p>\n<ol>\n<li>install the <a href=\"https://pypi.org/project/micromlgen/\">micromlgen</a> package with </li>\n</ol>\n<pre><code class=\"language-bash\">pip install micromlgen</code></pre>\n<ol start=\"2\">\n<li>(optionally, if you want to use Extreme Gradient Boosting) install the <a href=\"https://pypi.org/project/xgboost/\">xgboost</a> package with </li>\n</ol>\n<pre><code class=\"language-bash\">pip install xgboost</code></pre>\n<ol start=\"3\">\n<li>use the <code>micromlgen.port</code> function to generate your plain C code</li>\n</ol>\n<pre><code class=\"language-python\">from micromlgen import port\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n\nclf = DecisionTreeClassifier()\nX, y = load_iris(return_X_y=True)\nclf.fit(X, y)\nprint(port(clf))</code></pre>\n<p>You can then copy-past the C code and import it in your sketch.</p>\n<h2>Using in the Arduino sketch</h2>\n<p>Once you have the classifier code, create a new project named <code>TreeClassifierExample</code> and copy the classifier code into a file named <code>DecisionTree.h</code> (or <code>RandomForest.h</code> or <code>XGBoost.h</code> depending on the model you chose).</p>\n<p>The copy the following to the main ino file.</p>\n<pre><code class=\"language-cpp\">#include &quot;DecisionTree.h&quot;\n\nEloquent::ML::Port::DecisionTree clf;\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;Begin&quot;);\n}\n\nvoid loop() {\n    float irisSample[4] = {6.2, 2.8, 4.8, 1.8};\n\n    Serial.print(&quot;Predicted label (you should see &#039;2&#039;: &quot;);\n    Serial.println(clf.predict(irisSample));\n    delay(1000);\n}</code></pre>\n<h2>Bechmarks</h2>\n<p>How do the 3 classifiers compare against each other?</p>\n<p>We will evaluate a few keypoints:</p>\n<ul>\n<li>training time</li>\n<li>accuracy</li>\n<li>needed RAM</li>\n<li>needed Flash</li>\n</ul>\n<p>for each classifier on a variety of datasets. I will report the results for RAM and Flash on the Arduino Nano old generation, so you should consider more the relative figures than the absolute ones.</p>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th style=\"text-align: center;\">Classifier</th>\n<th style=\"text-align: center;\">Training <br />time (s)</th>\n<th style=\"text-align: center;\">Accuracy</th>\n<th style=\"text-align: center;\">RAM <br />(bytes)</th>\n<th style=\"text-align: center;\">Flash <br />(bytes)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Gas Sensor Array Drift Dataset </strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">1,6</td>\n<td style=\"text-align: center;\">0.781 \u00b1 0.12</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">5722</td>\n</tr>\n<tr>\n<td>13910 samples x 128 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">3</td>\n<td style=\"text-align: center;\">0.865 \u00b1 0.083</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">6438</td>\n</tr>\n<tr>\n<td>6 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">18,8</td>\n<td style=\"text-align: center;\"><strong>0.878 \u00b1 0.074</strong></td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">6506</td>\n</tr>\n<tr>\n<td><strong>Gesture Phase Segmentation Dataset</strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">0,1</td>\n<td style=\"text-align: center;\">0.943 \u00b1 0.005</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">5638</td>\n</tr>\n<tr>\n<td>10000 samples x 19 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">0,7</td>\n<td style=\"text-align: center;\"><strong>0.970 \u00b1 0.004</strong></td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6466</td>\n</tr>\n<tr>\n<td>5 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">18,9</td>\n<td style=\"text-align: center;\">0.969 \u00b1 0.003</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6536</td>\n</tr>\n<tr>\n<td><strong>Drive Diagnosis Dataset</strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">0,6</td>\n<td style=\"text-align: center;\">0.946 \u00b1 0.005</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">5850</td>\n</tr>\n<tr>\n<td>10000 samples x 48 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">2,6</td>\n<td style=\"text-align: center;\"><strong>0.983 \u00b1 0.003</strong></td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6526</td>\n</tr>\n<tr>\n<td>11 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">68,9</td>\n<td style=\"text-align: center;\">0.977 \u00b1 0.005</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6698</td>\n</tr>\n</tbody>\n</table>\n<p>* <em>all datasets are taken from the <a href=\"https://archive.ics.uci.edu/ml//datasets.php\">UCI Machine Learning datasets archive</a></em></p>\n<p>I'm collecting more data for a complete benchmark, but in the meantime you can see that both Random Forest and XGBoost are on par: if not that XGBoost takes 5 to 25 times longer to train.</p>\n<p>I've never used XGBoost, so I may be missing some tuning parameters, but for now Random Forest remains my favourite classifier.</p>\n<h2>Code listings</h2>\n<pre><code class=\"language-cpp\">// example IRIS dataset classification with Decision Tree\nint predict(float *x) {\n  if (x[3] &lt;= 0.800000011920929) {\n      return 0;\n  }\n  else {\n      if (x[3] &lt;= 1.75) {\n          if (x[2] &lt;= 4.950000047683716) {\n              if (x[0] &lt;= 5.049999952316284) {\n                  return 1;\n              }\n              else {\n                  return 1;\n              }\n          }\n          else {\n              return 2;\n          }\n      }\n      else {\n          if (x[2] &lt;= 4.950000047683716) {\n              return 2;\n          }\n          else {\n              return 2;\n          }\n      }\n  }\n}</code></pre>\n<pre><code class=\"language-cpp\">// example IRIS dataset classification with Random Forest of 3 trees\n\nint predict(float *x) {\n  uint16_t votes[3] = { 0 };\n\n  // tree #1\n  if (x[0] &lt;= 5.450000047683716) {\n      if (x[1] &lt;= 2.950000047683716) {\n          votes[1] += 1;\n      }\n      else {\n          votes[0] += 1;\n      }\n  }\n  else {\n      if (x[0] &lt;= 6.049999952316284) {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[2] &lt;= 3.549999952316284) {\n                  votes[0] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n      else {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[3] &lt;= 1.449999988079071) {\n                  if (x[0] &lt;= 6.1499998569488525) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #2\n  if (x[0] &lt;= 5.549999952316284) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 3.950000047683716) {\n              votes[1] += 1;\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[3] &lt;= 1.699999988079071) {\n          if (x[1] &lt;= 2.649999976158142) {\n              if (x[3] &lt;= 1.25) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              if (x[2] &lt;= 4.1499998569488525) {\n                  votes[1] += 1;\n              }\n              else {\n                  if (x[0] &lt;= 6.75) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n          }\n      }\n      else {\n          if (x[0] &lt;= 6.0) {\n              votes[2] += 1;\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #3\n  if (x[3] &lt;= 1.75) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 4.8500001430511475) {\n              if (x[0] &lt;= 5.299999952316284) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[0] &lt;= 5.950000047683716) {\n          votes[2] += 1;\n      }\n      else {\n          votes[2] += 1;\n      }\n  }\n\n  // return argmax of votes\n  uint8_t classIdx = 0;\n  float maxVotes = votes[0];\n\n  for (uint8_t i = 1; i &lt; 3; i++) {\n      if (votes[i] &gt; maxVotes) {\n          classIdx = i;\n          maxVotes = votes[i];\n      }\n  }\n\n  return classIdx;\n}</code></pre>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/\">Decision Tree, Random Forest and XGBoost on Arduino</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "You will be surprised by how much accuracy you can achieve in just a few kylobytes of resources: Decision Tree, Random Forest and XGBoost (Extreme Gradient Boosting) are now available on your microcontrollers: highly RAM-optmized implementations for super-fast classification on embedded devices.\n\n\nDecision Tree\nDecision Tree is without doubt one of the most well-known classification algorithms out there. It is so simple to understand that it was probably the first classifier you encountered in any Machine Learning course.\nI won't go into the details of how a Decision Tree classifier trains and selects the splits for the input features: here I will explain how a RAM-efficient porting of such a classifier is implemented.\nTo an introduction visit Wikipedia; for a more in-depth guide visit KDNuggets.\nSince we're willing to sacrifice program space (a.k.a flash) in favor of memory (a.k.a RAM), because RAM is the most scarce resource in the vast majority of microcontrollers, the smart way to port a Decision Tree classifier from Python to C is &quot;hard-coding&quot; the splits in code, without keeping any reference to them into variables.\nHere's what it looks like for a Decision tree that classifies the Iris dataset.\nAs you can see, we're using 0 bytes of RAM to get the classification result, since no variable is being allocated. On the other side, the program space will grow almost linearly with the number of splits.\nSince program space is often much greater than RAM on microcontrollers, this implementation exploits its abundance to be able to deploy larger models. How much large? It will depend on the flash size available: many new generations board (Arduino Nano 33 BLE Sense, ESP32, ST Nucleus...) have 1 Mb of flash, which will hold tens of thousands of splits. \nRandom Forest\nRandom Forest is just many Decision Trees joined together in a voting scheme. The core idea is that of &quot;the wisdom of the corwd&quot;, such that if many trees vote for a given class (having being trained on different subsets of the training set), that class is probably the true class.\nTowards Data Science has a more detailed guide on Random Forest and how it balances the trees with thebagging tecnique.\nAs easy as Decision Trees, Random Forest gets the exact same implementation with 0 bytes of RAM required (it actually needs as many bytes as the number of classes to store the votes, but that's really negligible): it just hard-codes all its composing trees.\nXGBoost (Extreme Gradient Boosting)\nExtreme Gradient Boosting is &quot;Gradient Boosting on steroids&quot; and has gained much attention from the Machine learning community due to its top results in many data competitions.\n\n&quot;gradient boosting&quot; refers to the process of chaining a number of trees so that each tree tries to learn from the errors of the previous\n&quot;extreme&quot; refers to many software and hardware optimizations that greatly reduce the time it takes to train the model\n\nYou can read the original paper about XGBoost here. For a discursive description head to KDNuggets, if you want some more math refer to this blog post on Medium.\nPorting to plain C\nIf you followed my earlier posts on Gaussian Naive Bayes, SEFR, Relevant Vector Machine and Support Vector Machines, you already know how to port these new classifiers.\nIf you're new, you will need a couple things:\n\ninstall the micromlgen package with \n\npip install micromlgen\n\n(optionally, if you want to use Extreme Gradient Boosting) install the xgboost package with \n\npip install xgboost\n\nuse the micromlgen.port function to generate your plain C code\n\nfrom micromlgen import port\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n\nclf = DecisionTreeClassifier()\nX, y = load_iris(return_X_y=True)\nclf.fit(X, y)\nprint(port(clf))\nYou can then copy-past the C code and import it in your sketch.\nUsing in the Arduino sketch\nOnce you have the classifier code, create a new project named TreeClassifierExample and copy the classifier code into a file named DecisionTree.h (or RandomForest.h or XGBoost.h depending on the model you chose).\nThe copy the following to the main ino file.\n#include &quot;DecisionTree.h&quot;\n\nEloquent::ML::Port::DecisionTree clf;\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;Begin&quot;);\n}\n\nvoid loop() {\n    float irisSample[4] = {6.2, 2.8, 4.8, 1.8};\n\n    Serial.print(&quot;Predicted label (you should see &#039;2&#039;: &quot;);\n    Serial.println(clf.predict(irisSample));\n    delay(1000);\n}\nBechmarks\nHow do the 3 classifiers compare against each other?\nWe will evaluate a few keypoints:\n\ntraining time\naccuracy\nneeded RAM\nneeded Flash\n\nfor each classifier on a variety of datasets. I will report the results for RAM and Flash on the Arduino Nano old generation, so you should consider more the relative figures than the absolute ones.\n\n\n\nDataset\nClassifier\nTraining time (s)\nAccuracy\nRAM (bytes)\nFlash (bytes)\n\n\n\n\nGas Sensor Array Drift Dataset \nDecision Tree\n1,6\n0.781 \u00b1 0.12\n290\n5722\n\n\n13910 samples x 128 features\nRandom Forest\n3\n0.865 \u00b1 0.083\n290\n6438\n\n\n6 classes\nXGBoost\n18,8\n0.878 \u00b1 0.074\n290\n6506\n\n\nGesture Phase Segmentation Dataset\nDecision Tree\n0,1\n0.943 \u00b1 0.005\n290\n5638\n\n\n10000 samples x 19 features\nRandom Forest\n0,7\n0.970 \u00b1 0.004\n306\n6466\n\n\n5 classes\nXGBoost\n18,9\n0.969 \u00b1 0.003\n306\n6536\n\n\nDrive Diagnosis Dataset\nDecision Tree\n0,6\n0.946 \u00b1 0.005\n306\n5850\n\n\n10000 samples x 48 features\nRandom Forest\n2,6\n0.983 \u00b1 0.003\n306\n6526\n\n\n11 classes\nXGBoost\n68,9\n0.977 \u00b1 0.005\n306\n6698\n\n\n\n* all datasets are taken from the UCI Machine Learning datasets archive\nI'm collecting more data for a complete benchmark, but in the meantime you can see that both Random Forest and XGBoost are on par: if not that XGBoost takes 5 to 25 times longer to train.\nI've never used XGBoost, so I may be missing some tuning parameters, but for now Random Forest remains my favourite classifier.\nCode listings\n// example IRIS dataset classification with Decision Tree\nint predict(float *x) {\n  if (x[3] &lt;= 0.800000011920929) {\n      return 0;\n  }\n  else {\n      if (x[3] &lt;= 1.75) {\n          if (x[2] &lt;= 4.950000047683716) {\n              if (x[0] &lt;= 5.049999952316284) {\n                  return 1;\n              }\n              else {\n                  return 1;\n              }\n          }\n          else {\n              return 2;\n          }\n      }\n      else {\n          if (x[2] &lt;= 4.950000047683716) {\n              return 2;\n          }\n          else {\n              return 2;\n          }\n      }\n  }\n}\n// example IRIS dataset classification with Random Forest of 3 trees\n\nint predict(float *x) {\n  uint16_t votes[3] = { 0 };\n\n  // tree #1\n  if (x[0] &lt;= 5.450000047683716) {\n      if (x[1] &lt;= 2.950000047683716) {\n          votes[1] += 1;\n      }\n      else {\n          votes[0] += 1;\n      }\n  }\n  else {\n      if (x[0] &lt;= 6.049999952316284) {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[2] &lt;= 3.549999952316284) {\n                  votes[0] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n      else {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[3] &lt;= 1.449999988079071) {\n                  if (x[0] &lt;= 6.1499998569488525) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #2\n  if (x[0] &lt;= 5.549999952316284) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 3.950000047683716) {\n              votes[1] += 1;\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[3] &lt;= 1.699999988079071) {\n          if (x[1] &lt;= 2.649999976158142) {\n              if (x[3] &lt;= 1.25) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              if (x[2] &lt;= 4.1499998569488525) {\n                  votes[1] += 1;\n              }\n              else {\n                  if (x[0] &lt;= 6.75) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n          }\n      }\n      else {\n          if (x[0] &lt;= 6.0) {\n              votes[2] += 1;\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #3\n  if (x[3] &lt;= 1.75) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 4.8500001430511475) {\n              if (x[0] &lt;= 5.299999952316284) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[0] &lt;= 5.950000047683716) {\n          votes[2] += 1;\n      }\n      else {\n          votes[2] += 1;\n      }\n  }\n\n  // return argmax of votes\n  uint8_t classIdx = 0;\n  float maxVotes = votes[0];\n\n  for (uint8_t i = 1; i &lt; 3; i++) {\n      if (votes[i] &gt; maxVotes) {\n          classIdx = i;\n          maxVotes = votes[i];\n      }\n  }\n\n  return classIdx;\n}\nL'articolo Decision Tree, Random Forest and XGBoost on Arduino proviene da Eloquent Arduino Blog.",
            "date_published": "2020-10-19T19:31:02+02:00",
            "date_modified": "2020-12-10T12:26:23+01:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning",
                "Arduino Machine Learning tutorial"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1297",
            "url": "https://eloquentarduino.github.io/2020/09/principal-fft-components-as-efficient-features-extrator/",
            "title": "\u201cPrincipal\u201d FFT components as efficient features extrator",
            "content_html": "<p><a href=\"https://en.wikipedia.org/wiki/Fourier_transform\">Fourier Transform</a> is probably the most well known algorithm for feature extraction from time-dependent data (in particular speech data), where frequency holds a great deal of information. Sadly, computing the transform over the whole spectrum of the signal still requires O(NlogN) with the best implementation (<a href=\"https://en.wikipedia.org/wiki/Fast_Fourier_transform\">FFT - Fast Fourier Transform</a>); we would like to achieve faster computation on our microcontrollers.</p>\n<p>In this post I propose a partial, naive <strong>linear-time</strong> implementation of the Fourier Transform you can use to extract features from your data for Machine Learning models.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/09/FFT-spectrum.png\" alt=\"FFT spectrum example\" /></p>\n<p><span id=\"more-1297\"></span></p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#toctraining-aware-fft\">Training-aware FFT</a><li><a href=\"#tocaccuracy-comparison\">Accuracy comparison</a><li><a href=\"#tochow-to-use-principal-fft-in-python\">How to use Principal FFT in Python</a><li><a href=\"#tochow-to-use-principal-fft-in-c\">How to use Principal FFT in C</a><ol><li><a href=\"#tocbenchmarking\">Benchmarking</a></ol></div></p>\n<p><strong>DISCLAIMER</strong></p>\n<p><em>The contents of this post represent my own knowledge and are not supported by any academic work (as far as I know). It may really be the case that the findings of my work don't apply to your own projects; yet, I think this idea can turn useful in solving certain kind of problems.</em></p>\n<h2 id=\"toctraining-aware-fft\">Training-aware FFT</h2>\n<p>Fourier transform is used to describe a signal over its entire frequency range. This is useful in a number of applications, but here we're focused on the FT for the sole purpose of extracting features to be used with Machine learning models.</p>\n<p>For this reason, we don't actually need a full description of the input signal: we're only interested in extracting some kind of signature that a ML model can use to distinguish among the different classes. Noticing that in a signal spectrum most frequencies have a low magnitude (as you can see in the picture above), the idea to only keep the <em>most important</em> frequencies came to my mind as a mean to speed up the computation on resource constrained microcontrollers.</p>\n<p>I was thinking to a kind of PCA (Principal Component Analysis), but using FFT spectrum as features.</p>\n<p>Since we will have a training set with the raw signals, we would like to select the most prominent frequencies among all the samples and apply the computation only on those: even using the naive implementation of FFT, this will yield a linear-time implementation.</p>\n<h2 id=\"tocaccuracy-comparison\">Accuracy comparison</h2>\n<p>How does this <em>Principal FFT</em> compare to, let's say, PCA as a dimensionality reduction algorithm w.r.t model accuracy? Let's see the numbers!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/09/FFT-vs-PCA.png\" alt=\"FFT vs PCA accuracy comparison on various datasets\" /></p>\n<p><a href=\"/wp-content/uploads/2020/09/Principal-FFT-benchmark.ods\" title=\"Principal FFT benchmark spreadsheet\">Download the Principal FFT benchmark spreadsheet</a></p>\n<p>I couldn't find many examples of the kind of datasets I wished to test, but in the image you can see different types of data:</p>\n<ul>\n<li>human activity classification from smartphone data</li>\n<li>gesture classification by IMU data</li>\n<li>MNIST handwritten digits image data</li>\n<li>free speech audio data</li>\n</ul>\n<p>We can note a couple findings:</p>\n<ol>\n<li>Principal FFT is almost on par with PCA after a certain number of components</li>\n<li>PrincipalFFT definitely leaves PCA behind on audio data</li>\n</ol>\n<p>From even this simple analysis you should be convinced that Principal FFT can be (under certain cases) a fast, performant features extractor for your projects that involve time-dependant data.</p>\n<h2 id=\"tochow-to-use-principal-fft-in-python\">How to use Principal FFT in Python</h2>\n<p>I created a Python package to use Principal FFT, called <code>principal-fft</code>.</p>\n<pre><code class=\"language-bash\">pip install principal-fft</code></pre>\n<p>The class follows the <code>Transformer</code> API from <code>scikit-learn</code>, so it has <code>fit</code> and <code>transform</code> methods.</p>\n<pre><code class=\"language-python\">from principalfft import PrincipalFFT\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import load_digits\nfrom sklearn.ensemble import RandomForestClassifier\n\nmnist = load_digits()\nX, y = mnist.data, mnist.target\nXfft = PrincipalFFT(n_components=10).fit_transform(X)\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nXfft_train, Xfft_test, y_train, y_test = train_test_split(Xfft, y, test_size=0.3)\n\nclf = RandomForestClassifier(50, min_samples_leaf=5).fit(X_train, y_train)\nprint(&quot;Raw score&quot;, clf.score(X_test, y_test))\n\nclf = RandomForestClassifier(50, min_samples_leaf=5).fit(Xfft_train, y_train)\nprint(&quot;FFT score&quot;, clf.score(Xfft_test, y_test))</code></pre>\n<p>My results are <code>0.09</code> for raw data and <code>0.78</code> for FFT transformed: quite a big difference!</p>\n<p>As with any dimensionality reduction, <code>n_components</code> is an hyperparameter you have to tune for your specific project: from my experiments, you shouldn't go lower than <code>8</code> to achieve a reasonable accuracy.</p>\n<h2 id=\"tochow-to-use-principal-fft-in-c\">How to use Principal FFT in C</h2>\n<p>So, now that we tested our Principal FFT transformer in Python and achieved good results, how do we use it on our microcontroller? Of course with the <code>micromlgen</code> porter: it is now (<code>version 1.1.9</code>) able to port PrincipalFFT objects to plain C.</p>\n<pre><code class=\"language-bash\">pip install micromlgen==1.1.9</code></pre>\n<p>What does the C code look like?</p>\n<pre><code class=\"language-cpp\">void principalFFT(float *features, float *fft) {\n    // apply principal FFT (naive implementation for the top 10 frequencies only)\n    const int topFrequencies[] = { 0, 8, 17, 16, 1, 9, 2, 7, 15, 6 };\n\n    for (int i = 0; i &lt; 10; i++) {\n        const int k = topFrequencies[i];\n        const float harmonic = 0.09817477042468103 * k;\n        float re = 0;\n        float im = 0;\n\n        // optimized case\n        if (k == 0) {\n            for (int n = 0; n &lt; 64; n++) {\n                re += features[n];\n            }\n        }\n\n        else {\n            for (int n = 0; n &lt; 64; n++) {\n                const float harmonic_n = harmonic * n;\n                const float cos_n = cos(harmonic_n);\n                const float sin_n = sin(harmonic_n);\n                re += features[n] * cos_n;\n                im -= features[n] * sin_n;\n            }\n        }\n\n        fft[i] = sqrt(re * re + im * im);\n    }\n}</code></pre>\n<p>This is the most direct porting available.</p>\n<p>In the <em>Benchmarks</em> section, we'll see how this implementation can be speed-up with alternative implementations.</p>\n<h3 id=\"tocbenchmarking\">Benchmarking</h3>\n<p>The following table reports the benchmark on the MNIST dataset (64 features) with 10 principal FFT components vs various tecniques to decrease the computation time at the expense of memory usage.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th style=\"text-align: center;\">Flash (Kb)</th>\n<th style=\"text-align: center;\">Execution time (micros)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>None</td>\n<td style=\"text-align: center;\">137420</td>\n<td style=\"text-align: center;\">-</td>\n</tr>\n<tr>\n<td>arduinoFFT library</td>\n<td style=\"text-align: center;\">147812</td>\n<td style=\"text-align: center;\">3200</td>\n</tr>\n<tr>\n<td>principalFFT</td>\n<td style=\"text-align: center;\">151404</td>\n<td style=\"text-align: center;\">4400</td>\n</tr>\n<tr>\n<td>principalFFT w/ cos+sin LUT</td>\n<td style=\"text-align: center;\">152124</td>\n<td style=\"text-align: center;\">900</td>\n</tr>\n<tr>\n<td>principalFFT w/ cos LUT + sin sign LUT</td>\n<td style=\"text-align: center;\">150220</td>\n<td style=\"text-align: center;\">1250</td>\n</tr>\n</tbody>\n</table>\n<p>*<em>all the benchmarks were run on the Arduino 33 Nano BLE Sense</em></p>\n<p>Some thoughts:</p>\n<ol start=\"2\">\n<li><code>principalFFT w/ cos+sin LUT</code> means I pre-compute the values of <code>sin</code> and <code>cos</code> at compile time, so there's no computation on the board; of course these lookup tables will eat some memory</li>\n<li><code>principalFFT w/ cos LUT + sin sign LUT</code> means I pre-compute the <code>cos</code> values only and compute <code>sin</code> using <code>sqrt(1 - cos(x)^2)</code>; it adds some microseconds to the computation, but requires less memory</li>\n<li><code>arduinoFFT library</code> is faster than <code>principalFFT</code> in the execution time and requires less memory, even if <code>principalFFT</code> is only computing 10 frequencies: I need to investigate how it can achieve such performances</li>\n</ol>\n<p>You can activate the LUT functionality with:</p>\n<pre><code class=\"language-python\">from micromlgen import port\nfrom principalfft import PrincipalFFT\n\nfft = PrincipalFFT(n_components=10).fit(X)\n\n# cos lookup, sin computed\nport(fft, lookup_cos=True)\n\n# cos + sin lookup\nport(fft, lookup_cos=True, lookup_sin=True)</code></pre>\n<p>Here's how the C code looks like with LUT.</p>\n<pre><code class=\"language-cpp\">void principalFFT(float *features, float *fft) {\n    // apply principal FFT (naive implementation for the top N frequencies only)\n    const int topFrequencies[] = { 0, 8, 17, 16, 1, 9, 2, 7, 15, 6 };\n    const float cosLUT[10][64] = {\n        {  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0},\n        {  1.0,  0.7071,  6.1232e-17,  -0.7071,  -1.0,  -0.7071,  -1.8369e-16,  0.7071,  1.0,  0.7071,  3.0616e-16,  -0.7071,  -1.0,  -0.7071,  -4.2862e-16,  0.7071,  1.0,  0.7071,  5.5109e-16,  -0.7071,  -1.0,  -0.7071,  -2.4499e-15,  0.7071,  1.0,  0.7071,  -9.8033e-16,  -0.7071,  -1.0,  -0.7071,  -2.6948e-15,  0.7071,  1.0,  0.7071,  -7.3540e-16,  -0.7071,  -1.0,  -0.7071,  -2.9397e-15,  0.7071,  1.0,  0.7071,  -4.9047e-16,  -0.7071,  -1.0,  -0.7071,  -3.1847e-15,  0.7071,  1.0,  0.7071,  -2.4554e-16,  -0.7071,  -1.0,  -0.7071,  -3.4296e-15,  0.7071,  1.0,  0.7071,  -6.1898e-19,  -0.7071,  -1.0,  -0.7071,  -3.6745e-15,  0.7071},   ... };\n    const bool sinLUT[10][64] = {\n        {  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false},\n        {  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  false,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false},  ...};\n\n    for (int i = 0; i &lt; 10; i++) {\n        const int k = topFrequencies[i];\n        const float harmonic = 0.09817477042468103 * k;\n        float re = 0;\n        float im = 0;\n        // optimized case\n        if (k == 0) {\n            for (int n = 0; n &lt; 64; n++) {\n                re += features[n];\n            }\n        }\n\n        else {\n            for (int n = 0; n &lt; 64; n++) {\n                const float cos_n = cosLUT[i][n];\n                const float sin_n = sinLUT[i][n] ? sqrt(1 - cos_n * cos_n) : -sqrt(1 - cos_n * cos_n);\n                re += features[n] * cos_n;\n                im -= features[n] * sin_n;\n            }\n        }\n\n        fft[i] = sqrt(re * re + im * im);\n    }\n}</code></pre>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the (more than) monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<hr />\n<p>This post required much work to be produced, so I hope I didn't forgot anything  and you found these information useful.<br />\nAs always, there's a <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PrincipalFFTExample/PrincipalFFTExample.ino\">Github repo</a> with all the code of this post.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/09/principal-fft-components-as-efficient-features-extrator/\">&#8220;Principal&#8221; FFT components as efficient features extrator</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Fourier Transform is probably the most well known algorithm for feature extraction from time-dependent data (in particular speech data), where frequency holds a great deal of information. Sadly, computing the transform over the whole spectrum of the signal still requires O(NlogN) with the best implementation (FFT - Fast Fourier Transform); we would like to achieve faster computation on our microcontrollers.\nIn this post I propose a partial, naive linear-time implementation of the Fourier Transform you can use to extract features from your data for Machine Learning models.\n\n\nTable of contentsTraining-aware FFTAccuracy comparisonHow to use Principal FFT in PythonHow to use Principal FFT in CBenchmarking\nDISCLAIMER\nThe contents of this post represent my own knowledge and are not supported by any academic work (as far as I know). It may really be the case that the findings of my work don't apply to your own projects; yet, I think this idea can turn useful in solving certain kind of problems.\nTraining-aware FFT\nFourier transform is used to describe a signal over its entire frequency range. This is useful in a number of applications, but here we're focused on the FT for the sole purpose of extracting features to be used with Machine learning models.\nFor this reason, we don't actually need a full description of the input signal: we're only interested in extracting some kind of signature that a ML model can use to distinguish among the different classes. Noticing that in a signal spectrum most frequencies have a low magnitude (as you can see in the picture above), the idea to only keep the most important frequencies came to my mind as a mean to speed up the computation on resource constrained microcontrollers.\nI was thinking to a kind of PCA (Principal Component Analysis), but using FFT spectrum as features.\nSince we will have a training set with the raw signals, we would like to select the most prominent frequencies among all the samples and apply the computation only on those: even using the naive implementation of FFT, this will yield a linear-time implementation.\nAccuracy comparison\nHow does this Principal FFT compare to, let's say, PCA as a dimensionality reduction algorithm w.r.t model accuracy? Let's see the numbers!\n\nDownload the Principal FFT benchmark spreadsheet\nI couldn't find many examples of the kind of datasets I wished to test, but in the image you can see different types of data:\n\nhuman activity classification from smartphone data\ngesture classification by IMU data\nMNIST handwritten digits image data\nfree speech audio data\n\nWe can note a couple findings:\n\nPrincipal FFT is almost on par with PCA after a certain number of components\nPrincipalFFT definitely leaves PCA behind on audio data\n\nFrom even this simple analysis you should be convinced that Principal FFT can be (under certain cases) a fast, performant features extractor for your projects that involve time-dependant data.\nHow to use Principal FFT in Python\nI created a Python package to use Principal FFT, called principal-fft.\npip install principal-fft\nThe class follows the Transformer API from scikit-learn, so it has fit and transform methods.\nfrom principalfft import PrincipalFFT\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import load_digits\nfrom sklearn.ensemble import RandomForestClassifier\n\nmnist = load_digits()\nX, y = mnist.data, mnist.target\nXfft = PrincipalFFT(n_components=10).fit_transform(X)\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nXfft_train, Xfft_test, y_train, y_test = train_test_split(Xfft, y, test_size=0.3)\n\nclf = RandomForestClassifier(50, min_samples_leaf=5).fit(X_train, y_train)\nprint(&quot;Raw score&quot;, clf.score(X_test, y_test))\n\nclf = RandomForestClassifier(50, min_samples_leaf=5).fit(Xfft_train, y_train)\nprint(&quot;FFT score&quot;, clf.score(Xfft_test, y_test))\nMy results are 0.09 for raw data and 0.78 for FFT transformed: quite a big difference!\nAs with any dimensionality reduction, n_components is an hyperparameter you have to tune for your specific project: from my experiments, you shouldn't go lower than 8 to achieve a reasonable accuracy.\nHow to use Principal FFT in C\nSo, now that we tested our Principal FFT transformer in Python and achieved good results, how do we use it on our microcontroller? Of course with the micromlgen porter: it is now (version 1.1.9) able to port PrincipalFFT objects to plain C.\npip install micromlgen==1.1.9\nWhat does the C code look like?\nvoid principalFFT(float *features, float *fft) {\n    // apply principal FFT (naive implementation for the top 10 frequencies only)\n    const int topFrequencies[] = { 0, 8, 17, 16, 1, 9, 2, 7, 15, 6 };\n\n    for (int i = 0; i &lt; 10; i++) {\n        const int k = topFrequencies[i];\n        const float harmonic = 0.09817477042468103 * k;\n        float re = 0;\n        float im = 0;\n\n        // optimized case\n        if (k == 0) {\n            for (int n = 0; n &lt; 64; n++) {\n                re += features[n];\n            }\n        }\n\n        else {\n            for (int n = 0; n &lt; 64; n++) {\n                const float harmonic_n = harmonic * n;\n                const float cos_n = cos(harmonic_n);\n                const float sin_n = sin(harmonic_n);\n                re += features[n] * cos_n;\n                im -= features[n] * sin_n;\n            }\n        }\n\n        fft[i] = sqrt(re * re + im * im);\n    }\n}\nThis is the most direct porting available.\nIn the Benchmarks section, we'll see how this implementation can be speed-up with alternative implementations.\nBenchmarking\nThe following table reports the benchmark on the MNIST dataset (64 features) with 10 principal FFT components vs various tecniques to decrease the computation time at the expense of memory usage.\n\n\n\nAlgorithm\nFlash (Kb)\nExecution time (micros)\n\n\n\n\nNone\n137420\n-\n\n\narduinoFFT library\n147812\n3200\n\n\nprincipalFFT\n151404\n4400\n\n\nprincipalFFT w/ cos+sin LUT\n152124\n900\n\n\nprincipalFFT w/ cos LUT + sin sign LUT\n150220\n1250\n\n\n\n*all the benchmarks were run on the Arduino 33 Nano BLE Sense\nSome thoughts:\n\nprincipalFFT w/ cos+sin LUT means I pre-compute the values of sin and cos at compile time, so there's no computation on the board; of course these lookup tables will eat some memory\nprincipalFFT w/ cos LUT + sin sign LUT means I pre-compute the cos values only and compute sin using sqrt(1 - cos(x)^2); it adds some microseconds to the computation, but requires less memory\narduinoFFT library is faster than principalFFT in the execution time and requires less memory, even if principalFFT is only computing 10 frequencies: I need to investigate how it can achieve such performances\n\nYou can activate the LUT functionality with:\nfrom micromlgen import port\nfrom principalfft import PrincipalFFT\n\nfft = PrincipalFFT(n_components=10).fit(X)\n\n# cos lookup, sin computed\nport(fft, lookup_cos=True)\n\n# cos + sin lookup\nport(fft, lookup_cos=True, lookup_sin=True)\nHere's how the C code looks like with LUT.\nvoid principalFFT(float *features, float *fft) {\n    // apply principal FFT (naive implementation for the top N frequencies only)\n    const int topFrequencies[] = { 0, 8, 17, 16, 1, 9, 2, 7, 15, 6 };\n    const float cosLUT[10][64] = {\n        {  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0},\n        {  1.0,  0.7071,  6.1232e-17,  -0.7071,  -1.0,  -0.7071,  -1.8369e-16,  0.7071,  1.0,  0.7071,  3.0616e-16,  -0.7071,  -1.0,  -0.7071,  -4.2862e-16,  0.7071,  1.0,  0.7071,  5.5109e-16,  -0.7071,  -1.0,  -0.7071,  -2.4499e-15,  0.7071,  1.0,  0.7071,  -9.8033e-16,  -0.7071,  -1.0,  -0.7071,  -2.6948e-15,  0.7071,  1.0,  0.7071,  -7.3540e-16,  -0.7071,  -1.0,  -0.7071,  -2.9397e-15,  0.7071,  1.0,  0.7071,  -4.9047e-16,  -0.7071,  -1.0,  -0.7071,  -3.1847e-15,  0.7071,  1.0,  0.7071,  -2.4554e-16,  -0.7071,  -1.0,  -0.7071,  -3.4296e-15,  0.7071,  1.0,  0.7071,  -6.1898e-19,  -0.7071,  -1.0,  -0.7071,  -3.6745e-15,  0.7071},   ... };\n    const bool sinLUT[10][64] = {\n        {  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false},\n        {  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  false,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false},  ...};\n\n    for (int i = 0; i &lt; 10; i++) {\n        const int k = topFrequencies[i];\n        const float harmonic = 0.09817477042468103 * k;\n        float re = 0;\n        float im = 0;\n        // optimized case\n        if (k == 0) {\n            for (int n = 0; n &lt; 64; n++) {\n                re += features[n];\n            }\n        }\n\n        else {\n            for (int n = 0; n &lt; 64; n++) {\n                const float cos_n = cosLUT[i][n];\n                const float sin_n = sinLUT[i][n] ? sqrt(1 - cos_n * cos_n) : -sqrt(1 - cos_n * cos_n);\n                re += features[n] * cos_n;\n                im -= features[n] * sin_n;\n            }\n        }\n\n        fft[i] = sqrt(re * re + im * im);\n    }\n}\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n\nThis post required much work to be produced, so I hope I didn't forgot anything  and you found these information useful.\nAs always, there's a Github repo with all the code of this post.\nL'articolo &#8220;Principal&#8221; FFT components as efficient features extrator proviene da Eloquent Arduino Blog.",
            "date_published": "2020-09-05T10:52:02+02:00",
            "date_modified": "2020-09-05T17:14:34+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1282",
            "url": "https://eloquentarduino.github.io/2020/08/better-word-classification-with-arduino-33-ble-sense-and-machine-learning/",
            "title": "Better word classification with Arduino Nano 33 BLE Sense and Machine Learning",
            "content_html": "<p>Let's revamp the post I wrote about <a href=\"/2019/12/word-classification-using-arduino/\">word classification using Machine Learning on Arduino</a>, this time using a proper microphone (the MP34DT05 mounted on the Arduino Nano 33 BLE Sense) instead of a chinese, analog one: will the results improve?</p>\n<div id=\"attachment_653\" style=\"width: 760px\" class=\"wp-caption alignnone\"><img aria-describedby=\"caption-attachment-653\" src=\"https://eloquentarduino.github.io/wp-content/uploads/2019/12/WakeWord.jpg\" width=\"750\" height=\"422\" class=\"size-full wp-image-653\" srcset=\"https://eloquentarduino.github.io/wp-content/uploads/2019/12/WakeWord.jpg 750w, https://eloquentarduino.github.io/wp-content/uploads/2019/12/WakeWord-300x169.jpg 300w\" sizes=\"(max-width: 750px) 100vw, 750px\" /><p id=\"caption-attachment-653\" class=\"wp-caption-text\">from https://www.udemy.com/course/learn-audio-processing-complete-engineers-course/</p></div>\n<p><span id=\"more-1282\"></span></p>\n<p><strong>Updated on 16 October 2020: step by step explanation of the process with ready-made sketch code</strong></p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tocwhat-youll-learn\">What you'll learn</a><li><a href=\"#tocwhat-youll-need\">What you'll need</a><li><a href=\"#tocstep-1-capture-audio-samples\">Step 1. Capture audio samples</a><ol><li><a href=\"#toctheory-pulse-density-modulation-a-k-a-pdm\">Theory: Pulse-density modulation (a.k.a. PDM)</a><li><a href=\"#tocpractice-the-code-to-capture-the-samples\">Practice: the code to capture the samples</a><li><a href=\"#tocaction-capture-the-words-examples\">Action: capture the words examples</a></li></ol><li><a href=\"#tocstep-2-train-the-machine-learning-model\">Step 2. Train the machine learning model</a><li><a href=\"#tocstep-3-deploy-to-your-microcontroller\">Step 3. Deploy to your microcontroller</a></ol></div></p>\n<h2 id=\"tocwhat-youll-learn\">What you'll learn</h2>\n<p>This tutorial will teach you how to capture audio from the Arduino Nano 33 BLE Sense microphone and classify it: at the end of this post, you will have a trained model able to detect in real-time the word you tell, among the ones that you trained it to recognize. The classification will occur directly on your Arduino board.</p>\n<p><em>This is not a general-purpose speech recognizer able to convert speech-to-text: it works only on the words <strong>you</strong> train it on</em>.</p>\n<h2 id=\"tocwhat-youll-need\">What you'll need</h2>\n<ul>\n<li>\n<p><strong>Hardware</strong></p>\n<ol>\n<li><a href=\"https://store.arduino.cc/arduino-nano-33-ble-sense\">Arduino Nano 33 BLE Sense</a></li>\n</ol>\n</li>\n<li>\n<p><strong>Software</strong></p>\n<ol>\n<li>Python</li>\n<li>Python's module <a href=\"https://scikit-learn.org/stable/\">scikit-learn</a></li>\n<li>Python's module <a href=\"https://pypi.org/project/micromlgen/\">micromlgen</a></li>\n</ol>\n</li>\n</ul>\n<p>To install the software, open your terminal and install the libraries.</p>\n<pre><code class=\"language-bash\">pip install -U scikit-learn\npip install -U micromlgen</code></pre>\n<h2 id=\"tocstep-1-capture-audio-samples\">Step 1. Capture audio samples</h2>\n<p>First of all, we need to capture a bunch of examples of the words we want to recognize.</p>\n<p>In the <a href=\"/2019/12/word-classification-using-arduino/\">original post</a>, we used an analog microphone to record the audio. It is for sure the easiest way to interact with audio on a microcontroller since you only need to <code>analogRead()</code> the selected pin to get a value from the sensor.</p>\n<p>This semplicity, however, comes at the cost of a nearly inexistent signal pre-processing from the sensor itself: most of the time, you will get junk - I don't want to be rude, but that's it.</p>\n<h3 id=\"toctheory-pulse-density-modulation-a-k-a-pdm\">Theory: Pulse-density modulation (a.k.a. PDM)</h3>\n<p>The microphone mounted on the Arduino Nano 33 BLE Sense (the <a href=\"https://content.arduino.cc/assets/Nano_BLE_Sense_mp34dt05-a.pdf\">MP34DT05</a>) is fortunately much better than this: it gives you access to a modulated signal much more suitable for our processing needs.</p>\n<p>The modulation used is pulse-density: I won't try to explain you how this works since I'm not an expert in DSP and neither it is the main scope of this article (refer to <a href=\"https://en.wikipedia.org/wiki/Pulse-density_modulation\">Wikipedia</a> for some more information).</p>\n<p>What matters to us is that we can grab an array of bytes from the microphone and extract its <a href=\"https://en.wikipedia.org/wiki/Root_mean_square\">Root Mean Square</a> (a.k.a. RMS) to be used as a feature for our Machine Learning model.</p>\n<p>I had some difficulty finding examples on how to access the microphone on the Arduino Nano 33 BLE Sense board: fortunately, there's a <a href=\"https://github.com/DaleGia/nano-33-sense-serial-example\">Github repo</a> from <em>DelaGia</em> that shows how to access all the sensors of the board.</p>\n<p>I extracted the microphone part and incapsulated it in an easy to use class, so you don't really need to dig into the implementation details if you're not interested.</p>\n<h3 id=\"tocpractice-the-code-to-capture-the-samples\">Practice: the code to capture the samples</h3>\n<p>When loaded on your Arduino Nano 33 BLE Sense, the following sketch will await for you to speak in front of the microphone: once it detects a sound, it will record  64 audio values and print them to the serial monitor.</p>\n<p>From my experience, 64 samples are sufficient to cover short words such as <em>yes</em>, <em>no</em>, <em>play</em>, <em>stop</em>: if you plan to classify longer words, you may need to increase this number.</p>\n<div class=\"watchout\">I suggest you keep the words short: longer words will probably decrease the accuracy of the model. If you want nonetheless a longer duration, at least keep the number of words as low as possible</div>\n<p>Download the <a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/arduino-33-ble-sense-capture-audio-samples.zip\" title=\"Arduino Nano 33 BLE Sense - Capture audio samples\">Arduino Nano 33 BLE Sense - Capture audio samples sketch</a>, open it the Arduino IDE and flash it to your board.</p>\n<p>Here's the main code.</p>\n<pre><code class=\"language-cpp\">#include &quot;Mic.h&quot;\n\n// tune as per your needs\n#define SAMPLES 64\n#define GAIN (1.0f/50)\n#define SOUND_THRESHOLD 2000\n\nfloat features[SAMPLES];\nMic mic;\n\nvoid setup() {\n    Serial.begin(115200);\n    PDM.onReceive(onAudio);\n    mic.begin();\n    delay(3000);\n}\n\nvoid loop() {\n    // await for a word to be pronounced\n    if (recordAudioSample()) {\n        // print features to serial monitor\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            Serial.print(features[i], 6);\n            Serial.print(i == SAMPLES - 1 ? &#039;\\n&#039; : &#039;,&#039;);\n        }\n\n        delay(1000);\n    }\n\n    delay(20);\n}\n\n/**\n * PDM callback to update mic object\n */\nvoid onAudio() {\n    mic.update();\n}\n\n/**\n * Read given number of samples from mic\n */\nbool recordAudioSample() {\n    if (mic.hasData() &amp;&amp; mic.data() &gt; SOUND_THRESHOLD) {\n\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            while (!mic.hasData())\n                delay(1);\n\n            features[i] = mic.pop() * GAIN;\n        }\n\n        return true;\n    }\n\n    return false;\n}</code></pre>\n<p>Now that we have the acquisition logic in place, it's time for you to record some samples of the words you want to classify. </p>\n<h3 id=\"tocaction-capture-the-words-examples\">Action: capture the words examples</h3>\n<p>Now you have to capture as many samples of the words you want to classify as possible.</p>\n<p>Open the serial monitor and pronounce a word near the microphone: a line of numbers will be printed on the monitor.</p>\n<p>This is the <em>description</em> of your word.</p>\n<p>You need many lines like this for an accurate prediction, so keep repeating the same word 15-30 times.</p>\n<div class=\"my-advice\">**My advice**: while recording the samples, vary both the distance of your mounth from the mic and the intensity of your voice: this will produce a more robust classification model later on.</div>\n<p>After you repeated the same words many times, copy the content of the serial monitor and save it in a CSV file named after the word, for example <code>yes.csv</code>.</p>\n<p>Then clear the serial monitor and repeat the process for each word.</p>\n<p>Keep all these files in a folder because we need them to train our classifier.</p>\n<h2 id=\"tocstep-2-train-the-machine-learning-model\">Step 2. Train the machine learning model</h2>\n<p>Now that we have the samples, it's time to train the classifier.</p>\n<p>Create a Python project in your favourite IDE or use your favourite text editor, if you don't have one.</p>\n<p>As described in <a href=\"/2019/11/how-to-train-a-classifier-in-scikit-learn/\">my post about how to train a classifier</a>, we create a Python script that reads all the files inside a folder and concatenates them in a single array you feed to the classifier model.</p>\n<p>Be sure your folder structure is like the following:</p>\n<pre><code>ArduinoWordClassification\n  |-- train_classifier.py\n  |-- data/\n  |---- yes.csv\n  |---- no.csv\n  |---- play.csv\n  |---- any other .csv file you recorded</code></pre>\n<pre><code class=\"language-python\"># file: train_classifier.py\n\nimport numpy as np\nfrom os.path import basename\nfrom glob import glob\nfrom sklearn.svm import SVC\nfrom micromlgen import port\nfrom sklearn.model_selection import train_test_split\n\ndef load_features(folder):\n    dataset = None\n    classmap = {}\n    for class_idx, filename in enumerate(glob(&#039;%s/*.csv&#039; % folder)):\n        class_name = basename(filename)[:-4]\n        classmap[class_idx] = class_name\n        samples = np.loadtxt(filename, dtype=float, delimiter=&#039;,&#039;)\n        labels = np.ones((len(samples), 1)) * class_idx\n        samples = np.hstack((samples, labels))\n        dataset = samples if dataset is None else np.vstack((dataset, samples))\n    return dataset, classmap\n\nnp.random.seed(0)\ndataset, classmap = load_features(&#039;data&#039;)\nX, y = dataset[:, :-1], dataset[:, -1]\n# this line is for testing your accuracy only: once you&#039;re satisfied with the results, set test_size to 1\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\nclf = SVC(kernel=&#039;poly&#039;, degree=2, gamma=0.1, C=100)\nclf.fit(X_train, y_train)\n\nprint(&#039;Accuracy&#039;, clf.score(X_test, y_test))\nprint(&#039;Exported classifier to plain C&#039;)\nprint(port(clf, classmap=classmap))</code></pre>\n<p>Among the classifiers I tried, SVM produced the best accuracy at 96% with 32 support vectors: it's not a super-tiny model, but it's quite small nevertheless.</p>\n<p>If you're not satisifed with SVM, you can use Decision Tree, Random Forest, Gaussian Naive Bayes, Relevant Vector Machines. See my other posts for a detailed description of each.</p>\n<p>In your console, after the accuracy score, you will have the plain C implementation of the classifier you trained. The following reports my SVM model.</p>\n<pre><code class=\"language-cpp\">// File: Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SVM {\n            public:\n                /**\n                * Predict class for features vector\n                */\n                int predict(float *x) {\n                    float kernels[35] = { 0 };\n                    float decisions[6] = { 0 };\n                    int votes[4] = { 0 };\n                    kernels[0] = compute_kernel(x,   33.0  , 41.0  , 47.0  , 54.0  , 59.0  , 61.0  , 56.0  , 51.0  , 50.0  , 51.0  , 44.0  , 32.0  , 23.0  , 15.0  , 12.0  , 8.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 5.0  , 3.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0 );\n                    kernels[1] = compute_kernel(x,   40.0  , 50.0  , 51.0  , 60.0  , 56.0  , 57.0  , 58.0  , 53.0  , 50.0  , 45.0  , 42.0  , 34.0  , 23.0  , 16.0  , 10.0  , 7.0  , 3.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 14.0  , 3.0  , 8.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 3.0 );\n                    kernels[2] = compute_kernel(x,   56.0  , 68.0  , 78.0  , 91.0  , 84.0  , 84.0  , 84.0  , 74.0  , 69.0  , 64.0  , 57.0  , 44.0  , 33.0  , 18.0  , 12.0  , 8.0  , 5.0  , 9.0  , 15.0  , 12.0  , 12.0  , 9.0  , 12.0  , 7.0  , 3.0  , 10.0  , 12.0  , 6.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 6.0  , 3.0  , 6.0  , 10.0  , 10.0  , 8.0  , 3.0  , 9.0  , 9.0  , 9.0  , 8.0  , 9.0  , 9.0  , 11.0  , 3.0  , 8.0  , 9.0  , 8.0  , 8.0  , 8.0  , 6.0  , 7.0  , 3.0  , 3.0  , 8.0  , 5.0  , 3.0  , 0.0  , 3.0  , 0.0  , 0.0 );\n\n                    // ...many other kernels computations...\n\n                    decisions[0] = 0.722587775297\n                                   + kernels[1] * 3.35855e-07\n                                   + kernels[2] * 1.64612e-07\n                                   + kernels[4] * 6.00056e-07\n                                   + kernels[5] * 3.5195e-08\n                                   + kernels[7] * -4.2079e-08\n                                   + kernels[8] * -4.2843e-08\n                                   + kernels[9] * -9.994e-09\n                                   + kernels[10] * -5.11065e-07\n                                   + kernels[11] * -5.979e-09\n                                   + kernels[12] * -4.4672e-08\n                                   + kernels[13] * -1.5606e-08\n                                   + kernels[14] * -1.2941e-08\n                                   + kernels[15] * -2.18903e-07\n                                   + kernels[17] * -2.31635e-07\n                            ;\n                    decisions[1] = -1.658344586719\n                                   + kernels[0] * 2.45018e-07\n                                   + kernels[1] * 4.30223e-07\n                                   + kernels[3] * 1.00277e-07\n                                   + kernels[4] * 2.16524e-07\n                                   + kernels[18] * -4.81187e-07\n                                   + kernels[20] * -5.10856e-07\n                            ;\n                    decisions[2] = -1.968607562265\n                                   + kernels[0] * 3.001833e-06\n                                   + kernels[3] * 4.5201e-08\n                                   + kernels[4] * 1.54493e-06\n                                   + kernels[5] * 2.81834e-07\n                                   + kernels[25] * -5.93581e-07\n                                   + kernels[26] * -2.89779e-07\n                                   + kernels[27] * -1.73958e-06\n                                   + kernels[28] * -1.09552e-07\n                                   + kernels[30] * -3.09126e-07\n                                   + kernels[31] * -1.294219e-06\n                                   + kernels[32] * -5.37961e-07\n                            ;\n                    decisions[3] = -0.720663029823\n                                   + kernels[6] * 1.4362e-08\n                                   + kernels[7] * 6.177e-09\n                                   + kernels[9] * 1.25e-08\n                                   + kernels[10] * 2.05478e-07\n                                   + kernels[12] * 2.501e-08\n                                   + kernels[15] * 4.363e-07\n                                   + kernels[16] * 9.147e-09\n                                   + kernels[18] * -1.82182e-07\n                                   + kernels[20] * -4.93707e-07\n                                   + kernels[21] * -3.3084e-08\n                            ;\n                    decisions[4] = -1.605747746589\n                                   + kernels[6] * 6.182e-09\n                                   + kernels[7] * 1.3853e-08\n                                   + kernels[8] * 2.12e-10\n                                   + kernels[9] * 1.1243e-08\n                                   + kernels[10] * 7.80681e-07\n                                   + kernels[15] * 8.347e-07\n                                   + kernels[17] * 1.64985e-07\n                                   + kernels[23] * -4.25014e-07\n                                   + kernels[25] * -1.134803e-06\n                                   + kernels[34] * -2.52038e-07\n                            ;\n                    decisions[5] = -0.934328303475\n                                   + kernels[19] * 3.3529e-07\n                                   + kernels[20] * 1.121946e-06\n                                   + kernels[21] * 3.44683e-07\n                                   + kernels[22] * -6.23056e-07\n                                   + kernels[24] * -1.4612e-07\n                                   + kernels[28] * -1.24025e-07\n                                   + kernels[29] * -4.31701e-07\n                                   + kernels[31] * -9.2146e-08\n                                   + kernels[33] * -3.8487e-07\n                            ;\n                    votes[decisions[0] &gt; 0 ? 0 : 1] += 1;\n                    votes[decisions[1] &gt; 0 ? 0 : 2] += 1;\n                    votes[decisions[2] &gt; 0 ? 0 : 3] += 1;\n                    votes[decisions[3] &gt; 0 ? 1 : 2] += 1;\n                    votes[decisions[4] &gt; 0 ? 1 : 3] += 1;\n                    votes[decisions[5] &gt; 0 ? 2 : 3] += 1;\n                    int val = votes[0];\n                    int idx = 0;\n\n                    for (int i = 1; i &lt; 4; i++) {\n                        if (votes[i] &gt; val) {\n                            val = votes[i];\n                            idx = i;\n                        }\n                    }\n\n                    return idx;\n                }\n\n                /**\n                * Convert class idx to readable name\n                */\n                const char* predictLabel(float *x) {\n                    switch (predict(x)) {\n                        case 0:\n                            return &quot;no&quot;;\n                        case 1:\n                            return &quot;stop&quot;;\n                        case 2:\n                            return &quot;play&quot;;\n                        case 3:\n                            return &quot;yes&quot;;\n                        default:\n                            return &quot;Houston we have a problem&quot;;\n                    }\n                }\n\n            protected:\n                /**\n                * Compute kernel between feature vector and support vector.\n                * Kernel type: poly\n                */\n                float compute_kernel(float *x, ...) {\n                    va_list w;\n                    va_start(w, 64);\n                    float kernel = 0.0;\n\n                    for (uint16_t i = 0; i &lt; 64; i++) {\n                        kernel += x[i] * va_arg(w, double);\n                    }\n\n                    return pow((0.1 * kernel) + 0.0, 2);\n                }\n            };\n        }\n    }\n}</code></pre>\n<h2 id=\"tocstep-3-deploy-to-your-microcontroller\">Step 3. Deploy to your microcontroller</h2>\n<p>Now we have all the pieces we need to perform word classification on our Arduino board.</p>\n<p>Download <a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/arduino-33-ble-sense-classify-audio.zip\">the Arduino Nano 33 BLE Sense - Audio classification sketch</a>, open it in the Arduino IDE and paste the plain C code you got in the console inside the <code>Classifier.h</code> file (delete all its contents before!).</p>\n<p>Fine: it's time to deploy!</p>\n<p>Hit the upload button: if everything went fine, open the serial monitor and pronounce one of the words you recorded during <code>Step 1</code>.</p>\n<p>Hopefully, you will read the word on the serial monitor.</p>\n<p>Here's a quick demo (please forgive me for the bad video quality).</p>\n<div style=\"width: 576px;\" class=\"wp-video\"><!--[if lt IE 9]><script>document.createElement('video');</script><![endif]-->\n<video class=\"wp-video-shortcode\" id=\"video-1282-1\" width=\"576\" height=\"482\" preload=\"metadata\" controls=\"controls\"><source type=\"video/mp4\" src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4?_=1\" /><a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4\">https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4</a></video></div>\n<hr />\n<p>If you liked this tutorial and it helped you successfully implement word classification on your Arduino Nano 33 BLE Sense, please share it on your social media so others can benefit too.</p>\n<p>If you have troubles or questions, don't hesitate to leave a comment: I will be happy to help you.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/08/better-word-classification-with-arduino-33-ble-sense-and-machine-learning/\">Better word classification with Arduino Nano 33 BLE Sense and Machine Learning</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Let's revamp the post I wrote about word classification using Machine Learning on Arduino, this time using a proper microphone (the MP34DT05 mounted on the Arduino Nano 33 BLE Sense) instead of a chinese, analog one: will the results improve?\nfrom https://www.udemy.com/course/learn-audio-processing-complete-engineers-course/\n\nUpdated on 16 October 2020: step by step explanation of the process with ready-made sketch code\nTable of contentsWhat you'll learnWhat you'll needStep 1. Capture audio samplesTheory: Pulse-density modulation (a.k.a. PDM)Practice: the code to capture the samplesAction: capture the words examplesStep 2. Train the machine learning modelStep 3. Deploy to your microcontroller\nWhat you'll learn\nThis tutorial will teach you how to capture audio from the Arduino Nano 33 BLE Sense microphone and classify it: at the end of this post, you will have a trained model able to detect in real-time the word you tell, among the ones that you trained it to recognize. The classification will occur directly on your Arduino board.\nThis is not a general-purpose speech recognizer able to convert speech-to-text: it works only on the words you train it on.\nWhat you'll need\n\n\nHardware\n\nArduino Nano 33 BLE Sense\n\n\n\nSoftware\n\nPython\nPython's module scikit-learn\nPython's module micromlgen\n\n\n\nTo install the software, open your terminal and install the libraries.\npip install -U scikit-learn\npip install -U micromlgen\nStep 1. Capture audio samples\nFirst of all, we need to capture a bunch of examples of the words we want to recognize.\nIn the original post, we used an analog microphone to record the audio. It is for sure the easiest way to interact with audio on a microcontroller since you only need to analogRead() the selected pin to get a value from the sensor.\nThis semplicity, however, comes at the cost of a nearly inexistent signal pre-processing from the sensor itself: most of the time, you will get junk - I don't want to be rude, but that's it.\nTheory: Pulse-density modulation (a.k.a. PDM)\nThe microphone mounted on the Arduino Nano 33 BLE Sense (the MP34DT05) is fortunately much better than this: it gives you access to a modulated signal much more suitable for our processing needs.\nThe modulation used is pulse-density: I won't try to explain you how this works since I'm not an expert in DSP and neither it is the main scope of this article (refer to Wikipedia for some more information).\nWhat matters to us is that we can grab an array of bytes from the microphone and extract its Root Mean Square (a.k.a. RMS) to be used as a feature for our Machine Learning model.\nI had some difficulty finding examples on how to access the microphone on the Arduino Nano 33 BLE Sense board: fortunately, there's a Github repo from DelaGia that shows how to access all the sensors of the board.\nI extracted the microphone part and incapsulated it in an easy to use class, so you don't really need to dig into the implementation details if you're not interested.\nPractice: the code to capture the samples\nWhen loaded on your Arduino Nano 33 BLE Sense, the following sketch will await for you to speak in front of the microphone: once it detects a sound, it will record  64 audio values and print them to the serial monitor.\nFrom my experience, 64 samples are sufficient to cover short words such as yes, no, play, stop: if you plan to classify longer words, you may need to increase this number.\nI suggest you keep the words short: longer words will probably decrease the accuracy of the model. If you want nonetheless a longer duration, at least keep the number of words as low as possible\nDownload the Arduino Nano 33 BLE Sense - Capture audio samples sketch, open it the Arduino IDE and flash it to your board.\nHere's the main code.\n#include &quot;Mic.h&quot;\n\n// tune as per your needs\n#define SAMPLES 64\n#define GAIN (1.0f/50)\n#define SOUND_THRESHOLD 2000\n\nfloat features[SAMPLES];\nMic mic;\n\nvoid setup() {\n    Serial.begin(115200);\n    PDM.onReceive(onAudio);\n    mic.begin();\n    delay(3000);\n}\n\nvoid loop() {\n    // await for a word to be pronounced\n    if (recordAudioSample()) {\n        // print features to serial monitor\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            Serial.print(features[i], 6);\n            Serial.print(i == SAMPLES - 1 ? &#039;\\n&#039; : &#039;,&#039;);\n        }\n\n        delay(1000);\n    }\n\n    delay(20);\n}\n\n/**\n * PDM callback to update mic object\n */\nvoid onAudio() {\n    mic.update();\n}\n\n/**\n * Read given number of samples from mic\n */\nbool recordAudioSample() {\n    if (mic.hasData() &amp;&amp; mic.data() &gt; SOUND_THRESHOLD) {\n\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            while (!mic.hasData())\n                delay(1);\n\n            features[i] = mic.pop() * GAIN;\n        }\n\n        return true;\n    }\n\n    return false;\n}\nNow that we have the acquisition logic in place, it's time for you to record some samples of the words you want to classify. \nAction: capture the words examples\nNow you have to capture as many samples of the words you want to classify as possible.\nOpen the serial monitor and pronounce a word near the microphone: a line of numbers will be printed on the monitor.\nThis is the description of your word.\nYou need many lines like this for an accurate prediction, so keep repeating the same word 15-30 times.\n**My advice**: while recording the samples, vary both the distance of your mounth from the mic and the intensity of your voice: this will produce a more robust classification model later on.\nAfter you repeated the same words many times, copy the content of the serial monitor and save it in a CSV file named after the word, for example yes.csv.\nThen clear the serial monitor and repeat the process for each word.\nKeep all these files in a folder because we need them to train our classifier.\nStep 2. Train the machine learning model\nNow that we have the samples, it's time to train the classifier.\nCreate a Python project in your favourite IDE or use your favourite text editor, if you don't have one.\nAs described in my post about how to train a classifier, we create a Python script that reads all the files inside a folder and concatenates them in a single array you feed to the classifier model.\nBe sure your folder structure is like the following:\nArduinoWordClassification\n  |-- train_classifier.py\n  |-- data/\n  |---- yes.csv\n  |---- no.csv\n  |---- play.csv\n  |---- any other .csv file you recorded\n# file: train_classifier.py\n\nimport numpy as np\nfrom os.path import basename\nfrom glob import glob\nfrom sklearn.svm import SVC\nfrom micromlgen import port\nfrom sklearn.model_selection import train_test_split\n\ndef load_features(folder):\n    dataset = None\n    classmap = {}\n    for class_idx, filename in enumerate(glob(&#039;%s/*.csv&#039; % folder)):\n        class_name = basename(filename)[:-4]\n        classmap[class_idx] = class_name\n        samples = np.loadtxt(filename, dtype=float, delimiter=&#039;,&#039;)\n        labels = np.ones((len(samples), 1)) * class_idx\n        samples = np.hstack((samples, labels))\n        dataset = samples if dataset is None else np.vstack((dataset, samples))\n    return dataset, classmap\n\nnp.random.seed(0)\ndataset, classmap = load_features(&#039;data&#039;)\nX, y = dataset[:, :-1], dataset[:, -1]\n# this line is for testing your accuracy only: once you&#039;re satisfied with the results, set test_size to 1\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\nclf = SVC(kernel=&#039;poly&#039;, degree=2, gamma=0.1, C=100)\nclf.fit(X_train, y_train)\n\nprint(&#039;Accuracy&#039;, clf.score(X_test, y_test))\nprint(&#039;Exported classifier to plain C&#039;)\nprint(port(clf, classmap=classmap))\nAmong the classifiers I tried, SVM produced the best accuracy at 96% with 32 support vectors: it's not a super-tiny model, but it's quite small nevertheless.\nIf you're not satisifed with SVM, you can use Decision Tree, Random Forest, Gaussian Naive Bayes, Relevant Vector Machines. See my other posts for a detailed description of each.\nIn your console, after the accuracy score, you will have the plain C implementation of the classifier you trained. The following reports my SVM model.\n// File: Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SVM {\n            public:\n                /**\n                * Predict class for features vector\n                */\n                int predict(float *x) {\n                    float kernels[35] = { 0 };\n                    float decisions[6] = { 0 };\n                    int votes[4] = { 0 };\n                    kernels[0] = compute_kernel(x,   33.0  , 41.0  , 47.0  , 54.0  , 59.0  , 61.0  , 56.0  , 51.0  , 50.0  , 51.0  , 44.0  , 32.0  , 23.0  , 15.0  , 12.0  , 8.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 5.0  , 3.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0 );\n                    kernels[1] = compute_kernel(x,   40.0  , 50.0  , 51.0  , 60.0  , 56.0  , 57.0  , 58.0  , 53.0  , 50.0  , 45.0  , 42.0  , 34.0  , 23.0  , 16.0  , 10.0  , 7.0  , 3.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 14.0  , 3.0  , 8.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 3.0 );\n                    kernels[2] = compute_kernel(x,   56.0  , 68.0  , 78.0  , 91.0  , 84.0  , 84.0  , 84.0  , 74.0  , 69.0  , 64.0  , 57.0  , 44.0  , 33.0  , 18.0  , 12.0  , 8.0  , 5.0  , 9.0  , 15.0  , 12.0  , 12.0  , 9.0  , 12.0  , 7.0  , 3.0  , 10.0  , 12.0  , 6.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 6.0  , 3.0  , 6.0  , 10.0  , 10.0  , 8.0  , 3.0  , 9.0  , 9.0  , 9.0  , 8.0  , 9.0  , 9.0  , 11.0  , 3.0  , 8.0  , 9.0  , 8.0  , 8.0  , 8.0  , 6.0  , 7.0  , 3.0  , 3.0  , 8.0  , 5.0  , 3.0  , 0.0  , 3.0  , 0.0  , 0.0 );\n\n                    // ...many other kernels computations...\n\n                    decisions[0] = 0.722587775297\n                                   + kernels[1] * 3.35855e-07\n                                   + kernels[2] * 1.64612e-07\n                                   + kernels[4] * 6.00056e-07\n                                   + kernels[5] * 3.5195e-08\n                                   + kernels[7] * -4.2079e-08\n                                   + kernels[8] * -4.2843e-08\n                                   + kernels[9] * -9.994e-09\n                                   + kernels[10] * -5.11065e-07\n                                   + kernels[11] * -5.979e-09\n                                   + kernels[12] * -4.4672e-08\n                                   + kernels[13] * -1.5606e-08\n                                   + kernels[14] * -1.2941e-08\n                                   + kernels[15] * -2.18903e-07\n                                   + kernels[17] * -2.31635e-07\n                            ;\n                    decisions[1] = -1.658344586719\n                                   + kernels[0] * 2.45018e-07\n                                   + kernels[1] * 4.30223e-07\n                                   + kernels[3] * 1.00277e-07\n                                   + kernels[4] * 2.16524e-07\n                                   + kernels[18] * -4.81187e-07\n                                   + kernels[20] * -5.10856e-07\n                            ;\n                    decisions[2] = -1.968607562265\n                                   + kernels[0] * 3.001833e-06\n                                   + kernels[3] * 4.5201e-08\n                                   + kernels[4] * 1.54493e-06\n                                   + kernels[5] * 2.81834e-07\n                                   + kernels[25] * -5.93581e-07\n                                   + kernels[26] * -2.89779e-07\n                                   + kernels[27] * -1.73958e-06\n                                   + kernels[28] * -1.09552e-07\n                                   + kernels[30] * -3.09126e-07\n                                   + kernels[31] * -1.294219e-06\n                                   + kernels[32] * -5.37961e-07\n                            ;\n                    decisions[3] = -0.720663029823\n                                   + kernels[6] * 1.4362e-08\n                                   + kernels[7] * 6.177e-09\n                                   + kernels[9] * 1.25e-08\n                                   + kernels[10] * 2.05478e-07\n                                   + kernels[12] * 2.501e-08\n                                   + kernels[15] * 4.363e-07\n                                   + kernels[16] * 9.147e-09\n                                   + kernels[18] * -1.82182e-07\n                                   + kernels[20] * -4.93707e-07\n                                   + kernels[21] * -3.3084e-08\n                            ;\n                    decisions[4] = -1.605747746589\n                                   + kernels[6] * 6.182e-09\n                                   + kernels[7] * 1.3853e-08\n                                   + kernels[8] * 2.12e-10\n                                   + kernels[9] * 1.1243e-08\n                                   + kernels[10] * 7.80681e-07\n                                   + kernels[15] * 8.347e-07\n                                   + kernels[17] * 1.64985e-07\n                                   + kernels[23] * -4.25014e-07\n                                   + kernels[25] * -1.134803e-06\n                                   + kernels[34] * -2.52038e-07\n                            ;\n                    decisions[5] = -0.934328303475\n                                   + kernels[19] * 3.3529e-07\n                                   + kernels[20] * 1.121946e-06\n                                   + kernels[21] * 3.44683e-07\n                                   + kernels[22] * -6.23056e-07\n                                   + kernels[24] * -1.4612e-07\n                                   + kernels[28] * -1.24025e-07\n                                   + kernels[29] * -4.31701e-07\n                                   + kernels[31] * -9.2146e-08\n                                   + kernels[33] * -3.8487e-07\n                            ;\n                    votes[decisions[0] &gt; 0 ? 0 : 1] += 1;\n                    votes[decisions[1] &gt; 0 ? 0 : 2] += 1;\n                    votes[decisions[2] &gt; 0 ? 0 : 3] += 1;\n                    votes[decisions[3] &gt; 0 ? 1 : 2] += 1;\n                    votes[decisions[4] &gt; 0 ? 1 : 3] += 1;\n                    votes[decisions[5] &gt; 0 ? 2 : 3] += 1;\n                    int val = votes[0];\n                    int idx = 0;\n\n                    for (int i = 1; i &lt; 4; i++) {\n                        if (votes[i] &gt; val) {\n                            val = votes[i];\n                            idx = i;\n                        }\n                    }\n\n                    return idx;\n                }\n\n                /**\n                * Convert class idx to readable name\n                */\n                const char* predictLabel(float *x) {\n                    switch (predict(x)) {\n                        case 0:\n                            return &quot;no&quot;;\n                        case 1:\n                            return &quot;stop&quot;;\n                        case 2:\n                            return &quot;play&quot;;\n                        case 3:\n                            return &quot;yes&quot;;\n                        default:\n                            return &quot;Houston we have a problem&quot;;\n                    }\n                }\n\n            protected:\n                /**\n                * Compute kernel between feature vector and support vector.\n                * Kernel type: poly\n                */\n                float compute_kernel(float *x, ...) {\n                    va_list w;\n                    va_start(w, 64);\n                    float kernel = 0.0;\n\n                    for (uint16_t i = 0; i &lt; 64; i++) {\n                        kernel += x[i] * va_arg(w, double);\n                    }\n\n                    return pow((0.1 * kernel) + 0.0, 2);\n                }\n            };\n        }\n    }\n}\nStep 3. Deploy to your microcontroller\nNow we have all the pieces we need to perform word classification on our Arduino board.\nDownload the Arduino Nano 33 BLE Sense - Audio classification sketch, open it in the Arduino IDE and paste the plain C code you got in the console inside the Classifier.h file (delete all its contents before!).\nFine: it's time to deploy!\nHit the upload button: if everything went fine, open the serial monitor and pronounce one of the words you recorded during Step 1.\nHopefully, you will read the word on the serial monitor.\nHere's a quick demo (please forgive me for the bad video quality).\n\nhttps://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4\n\nIf you liked this tutorial and it helped you successfully implement word classification on your Arduino Nano 33 BLE Sense, please share it on your social media so others can benefit too.\nIf you have troubles or questions, don't hesitate to leave a comment: I will be happy to help you.\nL'articolo Better word classification with Arduino Nano 33 BLE Sense and Machine Learning proviene da Eloquent Arduino Blog.",
            "date_published": "2020-08-24T19:04:57+02:00",
            "date_modified": "2020-10-17T17:50:13+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning"
            ],
            "attachments": [
                {
                    "url": "https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4",
                    "mime_type": "video/mp4",
                    "size_in_bytes": 5594095
                }
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1237",
            "url": "https://eloquentarduino.com/projects/arduino-indoor-positioning",
            "title": "The Ultimate Guide to Wifi Indoor Positioning using Arduino and Machine Learning",
            "content_html": "<p>This will be the most detailed, easy to follow tutorial over the Web on how to implement Wifi indoor positioning using an Arduino microcontroller and Machine Learning. It contains all the steps, tools and code from the start to the end of the project.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2019/12/illustrations_ambient-wifi-site-survey2.jpg\" alt=\"\" /><br />\n<em>ri-elaborated from <a href=\"https://www.accuware.com/blog/ambient-signals-plus-video-images/\">https://www.accuware.com/blog/ambient-signals-plus-video-images/</a></em></p>\n<p><span id=\"more-1237\"></span></p>\n<p><a href=\"/2019/12/wifi-indoor-positioning-on-arduino/\">My original post</a> abot Wifi indoor positioning is one of my top-performing post of all time (after <a href=\"/2020/01/motion-detection-with-esp32-cam-only-arduino-version/\">motion detection using ESP32 camera</a> and <a href=\"/2019/11/you-can-run-machine-learning-on-arduino/\">the introductory post on Machine Learning for Arduino</a>). This is why I settled to revamp it and add some more details, tools and scripts to create <strong>the most complete free guide</strong> on how to implement such a system, from the beginning to the end.</p>\n<p>This post will cover all the necessary steps and provide all the code you need: for an introduction to the topic, I point you to <a href=\"/2019/12/wifi-indoor-positioning-on-arduino/\">the original post</a>.</p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tocfeatures-definition\">Features definition</a><li><a href=\"#tocdata-gathering\">Data gathering</a><li><a href=\"#tocgenerating-the-features-converter\">Generating the features converter</a><li><a href=\"#tocgenerating-the-classifier\">Generating the classifier</a><li><a href=\"#tocwrapping-it-all-together\">Wrapping it all together</a><ol><li><a href=\"#tocdisclaimer\">Disclaimer</a></ol></div></p>\n<h2 id=\"tocfeatures-definition\">Features definition</h2>\n<p>This part stays the same as the original post: we will use the RSSIs (signal strength) of the nearby Wifi hotspots to classifiy which location we're in.</p>\n<p>Each location will &quot;see&quot; a certain number of networks, each with a RSSI that will stay <em>mostly</em> the same: the unique combination of these RSSIs will become a fingerprint to distinguish the locations from one another.</p>\n<p>Since not all networks will be visible all the time, the shape of our data will be more likely a sparse matrix.<br />\nA <a href=\"https://en.wikipedia.org/wiki/Sparse_matrix\">sparse matrix</a> is a matrix where most of the elements will be zero, meaning the absence of the given feature. Only the relevant elements will be non-zero and will represent the RSSI of the nth network.</p>\n<p>The following example table should give you an idea of what our data will look like.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">Location</th>\n<th style=\"text-align: right;\">Net #1</th>\n<th style=\"text-align: right;\">Net #2</th>\n<th style=\"text-align: right;\">Net #3</th>\n<th style=\"text-align: right;\">Net #4</th>\n<th style=\"text-align: right;\">Net #5</th>\n<th style=\"text-align: right;\">Net #6</th>\n<th style=\"text-align: right;\">Net #7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">Kitchen/1</td>\n<td style=\"text-align: right;\"><strong>50</strong></td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>60</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Kitchen/2</td>\n<td style=\"text-align: right;\"><strong>55</strong></td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>55</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>5</strong></td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Kitchen/3</td>\n<td style=\"text-align: right;\"><strong>50</strong></td>\n<td style=\"text-align: right;\"><strong>35</strong></td>\n<td style=\"text-align: right;\"><strong>65</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>5</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bedroom/1</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>40</strong></td>\n<td style=\"text-align: right;\"><strong>40</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bedroom/2</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>85</strong></td>\n<td style=\"text-align: right;\"><strong>10</strong></td>\n<td style=\"text-align: right;\"><strong>20</strong></td>\n<td style=\"text-align: right;\"><strong>20</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bedroom/3</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>70</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>85</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>40</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bathroom/1</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bathroom/2</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>10</strong></td>\n<td style=\"text-align: right;\"><strong>90</strong></td>\n<td style=\"text-align: right;\"><strong>85</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bathroom/3</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>90</strong></td>\n<td style=\"text-align: right;\"><strong>90</strong></td>\n<td style=\"text-align: right;\"><strong>5</strong></td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n</tbody>\n</table>\n<p>Even though the numbers in this table are fake, you should recognize a pattern:</p>\n<ul>\n<li>each location is characterized by a certain combination of always-visible networks</li>\n<li>some sample could be &quot;noised&quot; by weak networks (the <strong>5</strong> in the table)</li>\n</ul>\n<p>Our machine learning algorithm should be able to extract each location's fingerprint without being fooled by this inconsistent features.</p>\n<h2 id=\"tocdata-gathering\">Data gathering</h2>\n<p>Now that we know what our data should look like, we need to first get it.</p>\n<p>In the original post, this point was the one I'm unhappy with since it's not as straight-forward as I would have liked. The method I present you in this post, instead, is by far way simpler to follow.</p>\n<p>First of all, you will need a Wifi equipped board. I will use an <a href=\"https://store.arduino.cc/arduino-mkr-wifi-1010\">Arduino MKR WiFi 1010</a>, but any ESP8266 / ESP32 or the like will work.</p>\n<p>The following sketch will do the job: it scans the visible networks at a regular interval and prints their RSSIs encoded in JSON format.</p>\n<pre><code class=\"language-cpp\">// file DataGathering.h\n\n#include &quot;WiFi.h&quot;\n\n#define print(string) Serial.print(string);\n#define quote(string) print(&#039;&quot;&#039;); print(string); print(&#039;&quot;&#039;);\n\nString location = &quot;&quot;;\n\n/**\n * \n */\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n  WiFi.disconnect();\n}\n\n/**\n * \n */\nvoid loop() {  \n  // if location is set, scan networks\n  if (location != &quot;&quot;) {\n    int numNetworks = WiFi.scanNetworks();\n\n    // print location\n    print(&#039;{&#039;);\n    quote(&quot;__location&quot;);\n    print(&quot;: &quot;);\n    quote(location);\n    print(&quot;, &quot;);\n\n    // print each network SSID and RSSI\n    for (int i = 0; i &lt; numNetworks; i++) {\n      quote(WiFi.SSID(i));\n      print(&quot;: &quot;);\n      print(WiFi.RSSI(i));\n      print(i == numNetworks - 1 ? &quot;}\\n&quot; : &quot;, &quot;);\n    }\n\n    delay(1000);\n  }\n  // else wait for user to enter the location\n  else {\n    String input;\n\n    Serial.println(&quot;Enter &#039;scan {location}&#039; to start the scanning&quot;);\n\n    while (!Serial.available())\n      delay(200);\n\n    input = Serial.readStringUntil(&#039;\\n&#039;);\n\n    if (input.indexOf(&quot;scan &quot;) == 0) {\n      input.replace(&quot;scan &quot;, &quot;&quot;);\n      location = input;\n    }\n    else {\n      location = &quot;&quot;;\n    }\n  }\n}</code></pre>\n<p>Upload the sketch to your board and start mapping your house / office: go to the target location and type <code>scan {location}</code> in the serial monitor, where <code>{location}</code>is the name you want to give to the current location (so, for example, if you're mapping the kitchen, type <code>scan kitchen</code>).</p>\n<p>Move around the room a bit so you capture a few variations of the visible hotspots: this will lead to a more robust classification later on.</p>\n<p>To stop the recording just type <code>stop</code> in the serial monitor.</p>\n<p>Now repeat this process for each location you want to classify. At this point you should have ended with something similar to the following:</p>\n<pre><code class=\"language-python\">{&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n{&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n{&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n{&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}</code></pre>\n<p>In your case, &quot;N1&quot;, &quot;N2&quot;... will contain the name of the visible networks.</p>\n<p>When you're happy with your training data, it's time to convert it to something useful.</p>\n<h2 id=\"tocgenerating-the-features-converter\">Generating the features converter</h2>\n<p>Given the data we have, we want to generate C code that can convert a Wifi scan result into a feature vector we can use for classification.</p>\n<p>Since I'm a fan of code-generators, I wrote one specifically for this very project. And since I already have a code-generator library I use for Machine Learning code written in Python, I updated it with this new functionality.</p>\n<div class=\"watchout\">You must have Python installed on your system</div>\n<p>Start by installing the library.</p>\n<pre><code class=\"language-bash\"># be sure it installs version &gt;= 1.1.8\npip install --upgrade micromlgen</code></pre>\n<p>Now create a script with the following code:</p>\n<pre><code class=\"language-python\">from micromlgen import port_wifi_indoor_positioning\n\nif __name__ == &#039;__main__&#039;:\n    samples = &#039;&#039;&#039;\n    {&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\n    &#039;&#039;&#039;\n    X, y, classmap, converter_code = port_wifi_indoor_positioning(samples)\n    print(converter_code)</code></pre>\n<p>Of course you have to replace the <code>samples</code> content with the output you got in the previous step. </p>\n<p>In the console you should see a C++ class we will use later in the Arduino sketch. The class should be similar to the following example code.</p>\n<pre><code class=\"language-cpp\">// Save this code in your sketch as Converter.h\n\n#pragma once\nnamespace Eloquent {\n    namespace Projects {\n        class WifiIndoorPositioning {\n            public:\n                /**\n                * Get feature vector\n                */\n                float* getFeatures() {\n                    static float features[5] = {0};\n                    uint8_t numNetworks = WiFi.scanNetworks();\n\n                    for (uint8_t i = 0; i &lt; 5; i++) {\n                        features[i] = 0;\n                    }\n\n                    for (uint8_t i = 0; i &lt; numNetworks; i++) {\n                        int featureIdx = ssidToFeatureIdx(WiFi.SSID(i));\n\n                        if (featureIdx &gt;= 0) {\n                            features[featureIdx] = WiFi.RSSI(i);\n                        }\n                    }\n\n                    return features;\n                }\n\n            protected:\n                /**\n                * Convert SSID to featureIdx\n                */\n                int ssidToFeatureIdx(String ssid) {\n                    if (ssid.equals(&quot;N1&quot;))\n                    return 0;\n\n                    if (ssid.equals(&quot;N2&quot;))\n                    return 1;\n\n                    if (ssid.equals(&quot;N3&quot;))\n                    return 2;\n\n                    if (ssid.equals(&quot;N4&quot;))\n                    return 3;\n\n                    if (ssid.equals(&quot;N5&quot;))\n                    return 4;\n\n                    return -1;\n                }\n            };\n        }\n    }</code></pre>\n<p>I will briefly explain what it does: when you call <code>getFeatures()</code>, it runs a Wifi scan and for each network it finds, it fills the corresponding element in the feature vector (if the network is a known one).</p>\n<p>At the end of the procedure, your feature vector will look something like <code>[0, 10, 0, 0, 50, 0, 0]</code>, each element representing the RSSI of a given network.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the (more than) monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2 id=\"tocgenerating-the-classifier\">Generating the classifier</h2>\n<p>To close the loop of the project, we need to be able to classify the features vector into one of the recorded location. Since we already have <code>micromlgen</code> installed, it will be very easy to do so.</p>\n<p>Let's update the Python code we already have: this time, instead of printing the converter code, we will print the classifier code.</p>\n<pre><code class=\"language-bash\"># install ml package first\npip install scikit-learn</code></pre>\n<pre><code class=\"language-python\">from sklearn.tree import DecisionTreeClassifier\nfrom micromlgen import port_wifi_indoor_positioning, port\n\nif __name__ == &#039;__main__&#039;:\n    samples = &#039;&#039;&#039;\n    {&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\n    &#039;&#039;&#039;\n    X, y, classmap, converter_code = port_wifi_indoor_positioning(samples)\n    clf = DecisionTreeClassifier()\n    clf.fit(X, y)\n    print(port(clf, classmap=classmap))</code></pre>\n<p>Here I chose <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html\">Decision tree</a> because it is a very lightweight algorithm and should work fine for the kind of features we're working with.<br />\nIf you're not satisfied with the results, you can try to use <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html?highlight=svc#sklearn.svm.SVC\">SVM</a> or <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.GaussianNB.html?highlight=gaussiannb#sklearn.naive_bayes.GaussianNB\">Gaussian Naive Bayes</a>, which are both supported by <code>micromlgen</code>.</p>\n<p>In the console you will see the generated code for the classifier you trained. In the case of <code>DecisionTree</code> the code will look like the following.</p>\n<pre><code class=\"language-cpp\">// Save this code in your sketch as Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class DecisionTree {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        if (x[2] &lt;= 25.0) {\n                            if (x[4] &lt;= 50.0) {\n                                return 1;\n                            }\n\n                            else {\n                                return 2;\n                            }\n                        }\n\n                        else {\n                            return 0;\n                        }\n                    }\n\n                    /**\n                    * Convert class idx to readable name\n                    */\n                    const char* predictLabel(float *x) {\n                        switch (predict(x)) {\n                            case 0:\n                            return &quot;Bathroom&quot;;\n                            case 1:\n                            return &quot;Bedroom&quot;;\n                            case 2:\n                            return &quot;Kitchen&quot;;\n                            default:\n                            return &quot;Houston we have a problem&quot;;\n                        }\n                    }\n\n                protected:\n                };\n            }\n        }\n    }</code></pre>\n<h2 id=\"tocwrapping-it-all-together\">Wrapping it all together</h2>\n<p>Now that we have all the pieces together, we only need to merge them to get a complete working example.</p>\n<pre><code class=\"language-cpp\">// file WifiIndoorPositioning.h\n\n#include &quot;WiFi.h&quot;\n#include &quot;Converter.h&quot;\n#include &quot;Classifier.h&quot;\n\nEloquent::Projects::WifiIndoorPositioning positioning;\nEloquent::ML::Port::DecisionTree classifier;\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  Serial.print(&quot;You&#039;re in &quot;);\n  Serial.println(classifier.predictLabel(positioning.getFeatures()));\n  delay(3000);\n}</code></pre>\n<p>To the bare minimum, the above code runs the scan and tells you which location you're in. That's it.</p>\n<h3 id=\"tocdisclaimer\">Disclaimer</h3>\n<p>This system should be pretty accurate and robust if you properly gather the data, though I can quantify how much accurate.</p>\n<p>This is not an <em>indoor navigation system</em>: it can't tell you &quot;the coordinates&quot; of where you are, it can only detect in which room you're in.</p>\n<p>If your location lack of nearby Wifi hotspots, an easy and cheap solution would be to spawn a bunch of ESP8266 / ESP32 boards around your house each acting as Access Point: with this simple trick you should be able to be as accurate as needed by just adding more boards.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the (more than) monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<hr />\n<p>With this in-depth tutorial I hope I helped you going from start to end of setting up a Wifi indoor positioning system using cheap hardware as ESP8266 / ESP32 boards and the Arduino IDE. </p>\n<p>As you can see, Machine learning has not to be intimidating even for beginners: you just need the right tools to get the job done.</p>\n<p>If this guide excited you about Machine learning on microcontrollers, I invite you to read the many other posts I wrote on the topic and share them on the socials.</p>\n<p>You can find the whole project on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/tree/master/examples/TheUltimateGuideToWifiIndoorPositioning\">Github</a>. Don't forget to star the repo if you like it.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.com/projects/arduino-indoor-positioning\">The Ultimate Guide to Wifi Indoor Positioning using Arduino and Machine Learning</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "This will be the most detailed, easy to follow tutorial over the Web on how to implement Wifi indoor positioning using an Arduino microcontroller and Machine Learning. It contains all the steps, tools and code from the start to the end of the project.\n\nri-elaborated from https://www.accuware.com/blog/ambient-signals-plus-video-images/\n\nMy original post abot Wifi indoor positioning is one of my top-performing post of all time (after motion detection using ESP32 camera and the introductory post on Machine Learning for Arduino). This is why I settled to revamp it and add some more details, tools and scripts to create the most complete free guide on how to implement such a system, from the beginning to the end.\nThis post will cover all the necessary steps and provide all the code you need: for an introduction to the topic, I point you to the original post.\nTable of contentsFeatures definitionData gatheringGenerating the features converterGenerating the classifierWrapping it all togetherDisclaimer\nFeatures definition\nThis part stays the same as the original post: we will use the RSSIs (signal strength) of the nearby Wifi hotspots to classifiy which location we're in.\nEach location will &quot;see&quot; a certain number of networks, each with a RSSI that will stay mostly the same: the unique combination of these RSSIs will become a fingerprint to distinguish the locations from one another.\nSince not all networks will be visible all the time, the shape of our data will be more likely a sparse matrix.\nA sparse matrix is a matrix where most of the elements will be zero, meaning the absence of the given feature. Only the relevant elements will be non-zero and will represent the RSSI of the nth network.\nThe following example table should give you an idea of what our data will look like.\n\n\n\nLocation\nNet #1\nNet #2\nNet #3\nNet #4\nNet #5\nNet #6\nNet #7\n\n\n\n\nKitchen/1\n50\n30\n60\n0\n0\n0\n0\n\n\nKitchen/2\n55\n30\n55\n0\n0\n5\n0\n\n\nKitchen/3\n50\n35\n65\n0\n0\n0\n5\n\n\nBedroom/1\n0\n80\n0\n80\n0\n40\n40\n\n\nBedroom/2\n0\n80\n0\n85\n10\n20\n20\n\n\nBedroom/3\n0\n70\n0\n85\n0\n30\n40\n\n\nBathroom/1\n0\n0\n30\n80\n80\n0\n0\n\n\nBathroom/2\n0\n0\n10\n90\n85\n0\n0\n\n\nBathroom/3\n0\n0\n30\n90\n90\n5\n0\n\n\n\nEven though the numbers in this table are fake, you should recognize a pattern:\n\neach location is characterized by a certain combination of always-visible networks\nsome sample could be &quot;noised&quot; by weak networks (the 5 in the table)\n\nOur machine learning algorithm should be able to extract each location's fingerprint without being fooled by this inconsistent features.\nData gathering\nNow that we know what our data should look like, we need to first get it.\nIn the original post, this point was the one I'm unhappy with since it's not as straight-forward as I would have liked. The method I present you in this post, instead, is by far way simpler to follow.\nFirst of all, you will need a Wifi equipped board. I will use an Arduino MKR WiFi 1010, but any ESP8266 / ESP32 or the like will work.\nThe following sketch will do the job: it scans the visible networks at a regular interval and prints their RSSIs encoded in JSON format.\n// file DataGathering.h\n\n#include &quot;WiFi.h&quot;\n\n#define print(string) Serial.print(string);\n#define quote(string) print(&#039;&quot;&#039;); print(string); print(&#039;&quot;&#039;);\n\nString location = &quot;&quot;;\n\n/**\n * \n */\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n  WiFi.disconnect();\n}\n\n/**\n * \n */\nvoid loop() {  \n  // if location is set, scan networks\n  if (location != &quot;&quot;) {\n    int numNetworks = WiFi.scanNetworks();\n\n    // print location\n    print(&#039;{&#039;);\n    quote(&quot;__location&quot;);\n    print(&quot;: &quot;);\n    quote(location);\n    print(&quot;, &quot;);\n\n    // print each network SSID and RSSI\n    for (int i = 0; i &lt; numNetworks; i++) {\n      quote(WiFi.SSID(i));\n      print(&quot;: &quot;);\n      print(WiFi.RSSI(i));\n      print(i == numNetworks - 1 ? &quot;}\\n&quot; : &quot;, &quot;);\n    }\n\n    delay(1000);\n  }\n  // else wait for user to enter the location\n  else {\n    String input;\n\n    Serial.println(&quot;Enter &#039;scan {location}&#039; to start the scanning&quot;);\n\n    while (!Serial.available())\n      delay(200);\n\n    input = Serial.readStringUntil(&#039;\\n&#039;);\n\n    if (input.indexOf(&quot;scan &quot;) == 0) {\n      input.replace(&quot;scan &quot;, &quot;&quot;);\n      location = input;\n    }\n    else {\n      location = &quot;&quot;;\n    }\n  }\n}\nUpload the sketch to your board and start mapping your house / office: go to the target location and type scan {location} in the serial monitor, where {location}is the name you want to give to the current location (so, for example, if you're mapping the kitchen, type scan kitchen).\nMove around the room a bit so you capture a few variations of the visible hotspots: this will lead to a more robust classification later on.\nTo stop the recording just type stop in the serial monitor.\nNow repeat this process for each location you want to classify. At this point you should have ended with something similar to the following:\n{&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n{&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n{&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n{&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\nIn your case, &quot;N1&quot;, &quot;N2&quot;... will contain the name of the visible networks.\nWhen you're happy with your training data, it's time to convert it to something useful.\nGenerating the features converter\nGiven the data we have, we want to generate C code that can convert a Wifi scan result into a feature vector we can use for classification.\nSince I'm a fan of code-generators, I wrote one specifically for this very project. And since I already have a code-generator library I use for Machine Learning code written in Python, I updated it with this new functionality.\nYou must have Python installed on your system\nStart by installing the library.\n# be sure it installs version &gt;= 1.1.8\npip install --upgrade micromlgen\nNow create a script with the following code:\nfrom micromlgen import port_wifi_indoor_positioning\n\nif __name__ == &#039;__main__&#039;:\n    samples = &#039;&#039;&#039;\n    {&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\n    &#039;&#039;&#039;\n    X, y, classmap, converter_code = port_wifi_indoor_positioning(samples)\n    print(converter_code)\nOf course you have to replace the samples content with the output you got in the previous step. \nIn the console you should see a C++ class we will use later in the Arduino sketch. The class should be similar to the following example code.\n// Save this code in your sketch as Converter.h\n\n#pragma once\nnamespace Eloquent {\n    namespace Projects {\n        class WifiIndoorPositioning {\n            public:\n                /**\n                * Get feature vector\n                */\n                float* getFeatures() {\n                    static float features[5] = {0};\n                    uint8_t numNetworks = WiFi.scanNetworks();\n\n                    for (uint8_t i = 0; i &lt; 5; i++) {\n                        features[i] = 0;\n                    }\n\n                    for (uint8_t i = 0; i &lt; numNetworks; i++) {\n                        int featureIdx = ssidToFeatureIdx(WiFi.SSID(i));\n\n                        if (featureIdx &gt;= 0) {\n                            features[featureIdx] = WiFi.RSSI(i);\n                        }\n                    }\n\n                    return features;\n                }\n\n            protected:\n                /**\n                * Convert SSID to featureIdx\n                */\n                int ssidToFeatureIdx(String ssid) {\n                    if (ssid.equals(&quot;N1&quot;))\n                    return 0;\n\n                    if (ssid.equals(&quot;N2&quot;))\n                    return 1;\n\n                    if (ssid.equals(&quot;N3&quot;))\n                    return 2;\n\n                    if (ssid.equals(&quot;N4&quot;))\n                    return 3;\n\n                    if (ssid.equals(&quot;N5&quot;))\n                    return 4;\n\n                    return -1;\n                }\n            };\n        }\n    }\nI will briefly explain what it does: when you call getFeatures(), it runs a Wifi scan and for each network it finds, it fills the corresponding element in the feature vector (if the network is a known one).\nAt the end of the procedure, your feature vector will look something like [0, 10, 0, 0, 50, 0, 0], each element representing the RSSI of a given network.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nGenerating the classifier\nTo close the loop of the project, we need to be able to classify the features vector into one of the recorded location. Since we already have micromlgen installed, it will be very easy to do so.\nLet's update the Python code we already have: this time, instead of printing the converter code, we will print the classifier code.\n# install ml package first\npip install scikit-learn\nfrom sklearn.tree import DecisionTreeClassifier\nfrom micromlgen import port_wifi_indoor_positioning, port\n\nif __name__ == &#039;__main__&#039;:\n    samples = &#039;&#039;&#039;\n    {&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\n    &#039;&#039;&#039;\n    X, y, classmap, converter_code = port_wifi_indoor_positioning(samples)\n    clf = DecisionTreeClassifier()\n    clf.fit(X, y)\n    print(port(clf, classmap=classmap))\nHere I chose Decision tree because it is a very lightweight algorithm and should work fine for the kind of features we're working with.\nIf you're not satisfied with the results, you can try to use SVM or Gaussian Naive Bayes, which are both supported by micromlgen.\nIn the console you will see the generated code for the classifier you trained. In the case of DecisionTree the code will look like the following.\n// Save this code in your sketch as Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class DecisionTree {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        if (x[2] &lt;= 25.0) {\n                            if (x[4] &lt;= 50.0) {\n                                return 1;\n                            }\n\n                            else {\n                                return 2;\n                            }\n                        }\n\n                        else {\n                            return 0;\n                        }\n                    }\n\n                    /**\n                    * Convert class idx to readable name\n                    */\n                    const char* predictLabel(float *x) {\n                        switch (predict(x)) {\n                            case 0:\n                            return &quot;Bathroom&quot;;\n                            case 1:\n                            return &quot;Bedroom&quot;;\n                            case 2:\n                            return &quot;Kitchen&quot;;\n                            default:\n                            return &quot;Houston we have a problem&quot;;\n                        }\n                    }\n\n                protected:\n                };\n            }\n        }\n    }\nWrapping it all together\nNow that we have all the pieces together, we only need to merge them to get a complete working example.\n// file WifiIndoorPositioning.h\n\n#include &quot;WiFi.h&quot;\n#include &quot;Converter.h&quot;\n#include &quot;Classifier.h&quot;\n\nEloquent::Projects::WifiIndoorPositioning positioning;\nEloquent::ML::Port::DecisionTree classifier;\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  Serial.print(&quot;You&#039;re in &quot;);\n  Serial.println(classifier.predictLabel(positioning.getFeatures()));\n  delay(3000);\n}\nTo the bare minimum, the above code runs the scan and tells you which location you're in. That's it.\nDisclaimer\nThis system should be pretty accurate and robust if you properly gather the data, though I can quantify how much accurate.\nThis is not an indoor navigation system: it can't tell you &quot;the coordinates&quot; of where you are, it can only detect in which room you're in.\nIf your location lack of nearby Wifi hotspots, an easy and cheap solution would be to spawn a bunch of ESP8266 / ESP32 boards around your house each acting as Access Point: with this simple trick you should be able to be as accurate as needed by just adding more boards.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n\nWith this in-depth tutorial I hope I helped you going from start to end of setting up a Wifi indoor positioning system using cheap hardware as ESP8266 / ESP32 boards and the Arduino IDE. \nAs you can see, Machine learning has not to be intimidating even for beginners: you just need the right tools to get the job done.\nIf this guide excited you about Machine learning on microcontrollers, I invite you to read the many other posts I wrote on the topic and share them on the socials.\nYou can find the whole project on Github. Don't forget to star the repo if you like it.\nL'articolo The Ultimate Guide to Wifi Indoor Positioning using Arduino and Machine Learning proviene da Eloquent Arduino Blog.",
            "date_published": "2020-08-08T15:21:25+02:00",
            "date_modified": "2020-08-09T16:19:32+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "Senza categoria"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1225",
            "url": "https://eloquentarduino.github.io/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/",
            "title": "EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino",
            "content_html": "<p>Are you looking for a top-performer classifiers with a minimal amount of parameters to tune? Look no further: Gaussian Naive Bayes is what you're looking for. And thanks to EloquentML you can now port it to your microcontroller.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/GaussianNB.png\" alt=\"GaussianNB\" /></p>\n<p><span id=\"more-1225\"></span></p>\n<h2>(Gaussian) Naive Bayes</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Naive_Bayes_classifier\">Naive Bayes</a> classifiers are simple models based on the probability theory that can be used for classification.</p>\n<p>They originate from the assumption of independence among the input variables. Even though this assumption doesn't hold true in the vast majority of the cases, they often perform very good at many classification tasks, so they're quite popular.</p>\n<p>Gaussian Naive Bayes stack another (mostly wrong) assumption: that the variables exhibit a Gaussian probability distribution.</p>\n<p>I (and many others like me) will never understand how it is possible that so many wrong assumptions lead to such good performances!</p>\n<p>Nevertheless, what is important to us is that <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.GaussianNB.html\">sklearn implements GaussianNB</a>, so we easily train such a classifier.<br />\nThe most interesting part is that <code>GaussianNB</code> can be tuned with just a single parameter: <code>var_smoothing</code>.</p>\n<p>Don't ask me what it does in theory: in practice you change it and your accuracy can boost. This leads to an easy tuning process that doesn't involves expensive <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html\">grid search</a>.</p>\n<pre><code class=\"language-python\">import sklearn.datasets as d\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import normalize\nfrom sklearn.naive_bayes import GaussianNB\n\ndef pick_best(X_train, X_test, y_train, y_test):\n    best = (None, 0)\n    for var_smoothing in range(-7, 1):\n        clf = GaussianNB(var_smoothing=pow(10, var_smoothing))\n        clf.fit(X_train, y_train)\n        y_pred = clf.predict(X_test)\n        accuracy = (y_pred == y_test).sum()\n        if accuracy &gt; best[1]:\n            best = (clf, accuracy)\n    print(&#039;best accuracy&#039;, best[1] / len(y_test))\n    return best[0]\n\niris = d.load_iris()\nX = normalize(iris.data)\ny = iris.target\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nclf = pick_best(X_train, X_test, y_train, y_test)</code></pre>\n<p>This simple procedure will train a bunch of classifiers with a different <code>var_smoothing</code> factor and pick the best performing one.</p>\n<h2>EloquentML integration</h2>\n<p>Once you have your trained classifier, porting it to C is as easy as always:</p>\n<pre><code class=\"language-python\">from micromlgen import port\n\nclf = pick_best()\nprint(port(clf))</code></pre>\n<p class=\"watchout\">Always remember to run </p>\n<pre><code>pip install --upgrade micromlgen</code></pre>\n</p>\n<p><code>port</code> is a magic method able to port many classifiers: it will automatically detect the proper converter for you.</p>\n<p>What does the exported code looks like?</p>\n<pre><code class=\"language-cpp\">#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class GaussianNB {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        float votes[3] = { 0.0f };\n                        float theta[4] = { 0 };\n                        float sigma[4] = { 0 };\n                        theta[0] = 0.801139789889; theta[1] = 0.54726920354; theta[2] = 0.234408773313; theta[3] = 0.039178084094;\n                        sigma[0] = 0.000366881742; sigma[1] = 0.000907992556; sigma[2] = 0.000740960787; sigma[3] = 0.000274925514;\n                        votes[0] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.748563871324; theta[1] = 0.349390892644; theta[2] = 0.536186138345; theta[3] = 0.166747384117;\n                        sigma[0] = 0.000529727082; sigma[1] = 0.000847956504; sigma[2] = 0.000690057342; sigma[3] = 0.000311828658;\n                        votes[1] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.704497203305; theta[1] = 0.318862439835; theta[2] = 0.593755956917; theta[3] = 0.217288784452;\n                        sigma[0] = 0.000363782089; sigma[1] = 0.000813846722; sigma[2] = 0.000415475678; sigma[3] = 0.000758478249;\n                        votes[2] = 0.333333333333 - gauss(x, theta, sigma);\n                        // return argmax of votes\n                        uint8_t classIdx = 0;\n                        float maxVotes = votes[0];\n\n                        for (uint8_t i = 1; i &lt; 3; i++) {\n                            if (votes[i] &gt; maxVotes) {\n                                classIdx = i;\n                                maxVotes = votes[i];\n                            }\n                        }\n\n                        return classIdx;\n                    }\n\n                protected:\n                    /**\n                    * Compute gaussian value\n                    */\n                    float gauss(float *x, float *theta, float *sigma) {\n                        float gauss = 0.0f;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            gauss += log(sigma[i]);\n                            gauss += pow(x[i] - theta[i], 2) / sigma[i];\n                        }\n\n                        return gauss;\n                    }\n                };\n            }\n        }\n    }</code></pre>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the (more than) monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<p>As you can see, we need a couple of &quot;weight vectors&quot;:</p>\n<ul>\n<li><code>theta</code> is the mean of each feature</li>\n<li><code>sigma</code> is the standard deviation</li>\n</ul>\n<p>The computation is quite thin: just a couple of operations; the class with the highest score is then selected.</p>\n<h2>Benchmarks</h2>\n<p>Following there's a recap of a couple benchmarks I run on an Arduino Nano 33 Ble Sense.</p>\n<table>\n<thead>\n<tr>\n<th>Classifier</th>\n<th>Dataset</th>\n<th style=\"text-align: center;\">Flash</th>\n<th style=\"text-align: center;\">RAM</th>\n<th style=\"text-align: center;\">Execution time</th>\n<th style=\"text-align: center;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GaussianNB</td>\n<td>Iris (150x4)</td>\n<td style=\"text-align: center;\">82 kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">65 ms</td>\n<td style=\"text-align: center;\">97%</td>\n</tr>\n<tr>\n<td>LinearSVC</td>\n<td>Iris (150x4)</td>\n<td style=\"text-align: center;\">83 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">76 ms</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td>GaussianNB</td>\n<td>Breast cancer (80x40)</td>\n<td style=\"text-align: center;\">90 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">160 ms</td>\n<td style=\"text-align: center;\">77%</td>\n</tr>\n<tr>\n<td>LinearSVC</td>\n<td>Breast cancer (80x40)</td>\n<td style=\"text-align: center;\">112 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">378 ms</td>\n<td style=\"text-align: center;\">73%</td>\n</tr>\n<tr>\n<td>GaussianNB</td>\n<td>Wine (100x13)</td>\n<td style=\"text-align: center;\">85 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">130 ms</td>\n<td style=\"text-align: center;\">97%</td>\n</tr>\n<tr>\n<td>LinearSVC</td>\n<td>Wine (100x13)</td>\n<td style=\"text-align: center;\">89 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">125 ms</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n</tbody>\n</table>\n<p>We can see that the accuracy is on par with a linear SVM, reaching up to 97% on some datasets. Its semplicity shines with high-dimensional datasets (breast cancer) where execution time is half of the LinearSVC: I can see this pattern repeating with other real-world, medium-sized datasets.</p>\n<hr />\n<p>This is it, you can find the example project on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/GaussianNBClassificationExample/GaussianNBClassificationExample.ino\">Github</a>.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Are you looking for a top-performer classifiers with a minimal amount of parameters to tune? Look no further: Gaussian Naive Bayes is what you're looking for. And thanks to EloquentML you can now port it to your microcontroller.\n\n\n(Gaussian) Naive Bayes\nNaive Bayes classifiers are simple models based on the probability theory that can be used for classification.\nThey originate from the assumption of independence among the input variables. Even though this assumption doesn't hold true in the vast majority of the cases, they often perform very good at many classification tasks, so they're quite popular.\nGaussian Naive Bayes stack another (mostly wrong) assumption: that the variables exhibit a Gaussian probability distribution.\nI (and many others like me) will never understand how it is possible that so many wrong assumptions lead to such good performances!\nNevertheless, what is important to us is that sklearn implements GaussianNB, so we easily train such a classifier.\nThe most interesting part is that GaussianNB can be tuned with just a single parameter: var_smoothing.\nDon't ask me what it does in theory: in practice you change it and your accuracy can boost. This leads to an easy tuning process that doesn't involves expensive grid search.\nimport sklearn.datasets as d\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import normalize\nfrom sklearn.naive_bayes import GaussianNB\n\ndef pick_best(X_train, X_test, y_train, y_test):\n    best = (None, 0)\n    for var_smoothing in range(-7, 1):\n        clf = GaussianNB(var_smoothing=pow(10, var_smoothing))\n        clf.fit(X_train, y_train)\n        y_pred = clf.predict(X_test)\n        accuracy = (y_pred == y_test).sum()\n        if accuracy &gt; best[1]:\n            best = (clf, accuracy)\n    print(&#039;best accuracy&#039;, best[1] / len(y_test))\n    return best[0]\n\niris = d.load_iris()\nX = normalize(iris.data)\ny = iris.target\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nclf = pick_best(X_train, X_test, y_train, y_test)\nThis simple procedure will train a bunch of classifiers with a different var_smoothing factor and pick the best performing one.\nEloquentML integration\nOnce you have your trained classifier, porting it to C is as easy as always:\nfrom micromlgen import port\n\nclf = pick_best()\nprint(port(clf))\nAlways remember to run \npip install --upgrade micromlgen\n\nport is a magic method able to port many classifiers: it will automatically detect the proper converter for you.\nWhat does the exported code looks like?\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class GaussianNB {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        float votes[3] = { 0.0f };\n                        float theta[4] = { 0 };\n                        float sigma[4] = { 0 };\n                        theta[0] = 0.801139789889; theta[1] = 0.54726920354; theta[2] = 0.234408773313; theta[3] = 0.039178084094;\n                        sigma[0] = 0.000366881742; sigma[1] = 0.000907992556; sigma[2] = 0.000740960787; sigma[3] = 0.000274925514;\n                        votes[0] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.748563871324; theta[1] = 0.349390892644; theta[2] = 0.536186138345; theta[3] = 0.166747384117;\n                        sigma[0] = 0.000529727082; sigma[1] = 0.000847956504; sigma[2] = 0.000690057342; sigma[3] = 0.000311828658;\n                        votes[1] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.704497203305; theta[1] = 0.318862439835; theta[2] = 0.593755956917; theta[3] = 0.217288784452;\n                        sigma[0] = 0.000363782089; sigma[1] = 0.000813846722; sigma[2] = 0.000415475678; sigma[3] = 0.000758478249;\n                        votes[2] = 0.333333333333 - gauss(x, theta, sigma);\n                        // return argmax of votes\n                        uint8_t classIdx = 0;\n                        float maxVotes = votes[0];\n\n                        for (uint8_t i = 1; i &lt; 3; i++) {\n                            if (votes[i] &gt; maxVotes) {\n                                classIdx = i;\n                                maxVotes = votes[i];\n                            }\n                        }\n\n                        return classIdx;\n                    }\n\n                protected:\n                    /**\n                    * Compute gaussian value\n                    */\n                    float gauss(float *x, float *theta, float *sigma) {\n                        float gauss = 0.0f;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            gauss += log(sigma[i]);\n                            gauss += pow(x[i] - theta[i], 2) / sigma[i];\n                        }\n\n                        return gauss;\n                    }\n                };\n            }\n        }\n    }\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nAs you can see, we need a couple of &quot;weight vectors&quot;:\n\ntheta is the mean of each feature\nsigma is the standard deviation\n\nThe computation is quite thin: just a couple of operations; the class with the highest score is then selected.\nBenchmarks\nFollowing there's a recap of a couple benchmarks I run on an Arduino Nano 33 Ble Sense.\n\n\n\nClassifier\nDataset\nFlash\nRAM\nExecution time\nAccuracy\n\n\n\n\nGaussianNB\nIris (150x4)\n82 kb\n42 Kb\n65 ms\n97%\n\n\nLinearSVC\nIris (150x4)\n83 Kb\n42 Kb\n76 ms\n99%\n\n\nGaussianNB\nBreast cancer (80x40)\n90 Kb\n42 Kb\n160 ms\n77%\n\n\nLinearSVC\nBreast cancer (80x40)\n112 Kb\n42 Kb\n378 ms\n73%\n\n\nGaussianNB\nWine (100x13)\n85 Kb\n42 Kb\n130 ms\n97%\n\n\nLinearSVC\nWine (100x13)\n89 Kb\n42 Kb\n125 ms\n99%\n\n\n\nWe can see that the accuracy is on par with a linear SVM, reaching up to 97% on some datasets. Its semplicity shines with high-dimensional datasets (breast cancer) where execution time is half of the LinearSVC: I can see this pattern repeating with other real-world, medium-sized datasets.\n\nThis is it, you can find the example project on Github.\nL'articolo EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino proviene da Eloquent Arduino Blog.",
            "date_published": "2020-08-02T10:44:36+02:00",
            "date_modified": "2020-08-02T11:36:42+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1214",
            "url": "https://eloquentarduino.github.io/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/",
            "title": "SEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices",
            "content_html": "<p>A brand new binary classifier that's tiny and accurate, perfect for embedded scenarios: easily achieve 90+ % accuracy with a minimal memory footprint!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/07/Binary-classification.png\" alt=\"Binary classification - from https://towardsdatascience.com\" /></p>\n<p><span id=\"more-1214\"></span></p>\n<p>A few weeks ago I was wandering over <a href=\"https://arxiv.org/search/cs?query=microcontroller&amp;searchtype=all&amp;abstracts=show&amp;order=-announced_date_first&amp;size=50\">arxiv.org</a> looking for insipiration relative to Machine learning on microcontrollers when I found exactly what I was looking for.</p>\n<p><a href=\"https://arxiv.org/abs/2006.04620\">SEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices</a> is a paper from Hamidreza Keshavarz, Mohammad Saniee Abadeh, Reza Rawassizadeh where the authors develop a binary classifier that is:</p>\n<ul>\n<li>fast during training</li>\n<li>fast during prediction</li>\n<li>requires minimal memory</li>\n</ul>\n<p>It has been specifically designed for embedded machine learning, so no optimization is required to run in on microcontrollers: it is tiny by design. In short, it uses a combination of the averages of the features as weights plus a bias to distinguish between positive and negative class. If you read the paper you will sure understand it: it's very straightforward.</p>\n<h2>How to use</h2>\n<p>The authors both provided a <a href=\"https://github.com/sefr-classifier/sefr\">C and Python implementation</a> on Github you can read.  I ported the C version &quot;manually&quot; to my <a href=\"https://github.com/eloquentarduino/EloquentMicroML\">Eloquent ML library</a> and created a <a href=\"https://github.com/eloquentarduino/sefr\">Python package called sefr</a> copy-pasting from the original repo.</p>\n<p>Here's a Python example.</p>\n<pre><code class=\"language-python\">from sefr import SEFR\nfrom sklearn.datasets import load_iris\nfrom sklearn.preprocessing import normalize\nfrom sklearn.model_selection import train_test_split\n\nif __name__ == &#039;__main__&#039;:\n    iris = load_iris()\n    X = normalize(iris.data)\n    y = iris.target\n    X = X[y &lt; 2]\n    y = y[y &lt; 2]\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n    clf = SEFR()\n    clf.fit(X_train, y_train)\n    print(&#039;accuracy&#039;, (clf.predict(X_test) == y_test).sum() / len(y_test))</code></pre>\n<p>How good is it?</p>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th style=\"text-align: center;\">No. of features</th>\n<th style=\"text-align: center;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Iris</td>\n<td style=\"text-align: center;\">4</td>\n<td style=\"text-align: center;\">100%</td>\n</tr>\n<tr>\n<td>Breast cancer</td>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">89%</td>\n</tr>\n<tr>\n<td>Wine</td>\n<td style=\"text-align: center;\">13</td>\n<td style=\"text-align: center;\">84%</td>\n</tr>\n<tr>\n<td>Digits</td>\n<td style=\"text-align: center;\">64</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n</tbody>\n</table>\n<p>Considering that the model only needs 1 weight per feature, I think this results are impressive!</p>\n<h2>Micromlgen integration</h2>\n<p>The Python porting was done so I could integrate it easily in my <a href=\"https://github.com/eloquentarduino/micromlgen\">micromlgen</a> package.</p>\n<p>How to use it?</p>\n<pre><code class=\"language-python\">from sefr import SEFR\nfrom sklearn.datasets import load_iris\nfrom micromlgen import port\n\nif __name__ == &#039;__main__&#039;:\n    iris = load_iris()\n    X = iris.data\n    y = iris.target\n    X = X[y &lt; 2]\n    y = y[y &lt; 2]\n    clf = SEFR()\n    clf.fit(X_train, y_train)\n    print(port(clf))</code></pre>\n<p>The produced code is so compact I will report it here.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the (more than) monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<pre><code class=\"language-cpp\">#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SEFR {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        return dot(x,   0.084993602632  , -0.106163278477  , 0.488989863684  , 0.687022900763 ) &lt;= 2.075 ? 0 : 1;\n                    }\n\n                protected:\n                    /**\n                    * Compute dot product between features vector and classifier weights\n                    */\n                    float dot(float *x, ...) {\n                        va_list w;\n                        va_start(w, 4);\n                        float kernel = 0.0;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            kernel += x[i] * va_arg(w, double);\n                        }\n\n                        return kernel;\n                    }\n                };\n            }\n        }\n    }</code></pre>\n<p>In your sketch:</p>\n<pre><code class=\"language-cpp\">#include &quot;IrisSEFR.h&quot;\n#include &quot;IrisTest.h&quot;\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\nvoid loop() {\n    Eloquent::ML::Port::SEFR clf;\n    Eloquent::ML::Test::IrisTestSet testSet;\n\n    testSet.test(clf);\n    Serial.println(testSet.dump());\n    delay(5000);\n}</code></pre>\n<p>You have to clone the <a href=\"https://github.com/eloquentarduino/EloquentMicroML/tree/master/examples/OffboardSEFRExample\">Github example</a> to compile the code.</p>\n<hr />\n<p>That's all for today, I hope you will try this classifier and find a project it fits in: I'm very impressed by the easiness of implementation yet the accuracy it can achieve on benchmark datasets.</p>\n<p>In the next weeks I'm thinking in implementing a multi-class version of this and see how it performs, so stay tuned!</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/\">SEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "A brand new binary classifier that's tiny and accurate, perfect for embedded scenarios: easily achieve 90+ % accuracy with a minimal memory footprint!\n\n\nA few weeks ago I was wandering over arxiv.org looking for insipiration relative to Machine learning on microcontrollers when I found exactly what I was looking for.\nSEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices is a paper from Hamidreza Keshavarz, Mohammad Saniee Abadeh, Reza Rawassizadeh where the authors develop a binary classifier that is:\n\nfast during training\nfast during prediction\nrequires minimal memory\n\nIt has been specifically designed for embedded machine learning, so no optimization is required to run in on microcontrollers: it is tiny by design. In short, it uses a combination of the averages of the features as weights plus a bias to distinguish between positive and negative class. If you read the paper you will sure understand it: it's very straightforward.\nHow to use\nThe authors both provided a C and Python implementation on Github you can read.  I ported the C version &quot;manually&quot; to my Eloquent ML library and created a Python package called sefr copy-pasting from the original repo.\nHere's a Python example.\nfrom sefr import SEFR\nfrom sklearn.datasets import load_iris\nfrom sklearn.preprocessing import normalize\nfrom sklearn.model_selection import train_test_split\n\nif __name__ == &#039;__main__&#039;:\n    iris = load_iris()\n    X = normalize(iris.data)\n    y = iris.target\n    X = X[y &lt; 2]\n    y = y[y &lt; 2]\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n    clf = SEFR()\n    clf.fit(X_train, y_train)\n    print(&#039;accuracy&#039;, (clf.predict(X_test) == y_test).sum() / len(y_test))\nHow good is it?\n\n\n\nDataset\nNo. of features\nAccuracy\n\n\n\n\nIris\n4\n100%\n\n\nBreast cancer\n30\n89%\n\n\nWine\n13\n84%\n\n\nDigits\n64\n99%\n\n\n\nConsidering that the model only needs 1 weight per feature, I think this results are impressive!\nMicromlgen integration\nThe Python porting was done so I could integrate it easily in my micromlgen package.\nHow to use it?\nfrom sefr import SEFR\nfrom sklearn.datasets import load_iris\nfrom micromlgen import port\n\nif __name__ == &#039;__main__&#039;:\n    iris = load_iris()\n    X = iris.data\n    y = iris.target\n    X = X[y &lt; 2]\n    y = y[y &lt; 2]\n    clf = SEFR()\n    clf.fit(X_train, y_train)\n    print(port(clf))\nThe produced code is so compact I will report it here.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SEFR {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        return dot(x,   0.084993602632  , -0.106163278477  , 0.488989863684  , 0.687022900763 ) &lt;= 2.075 ? 0 : 1;\n                    }\n\n                protected:\n                    /**\n                    * Compute dot product between features vector and classifier weights\n                    */\n                    float dot(float *x, ...) {\n                        va_list w;\n                        va_start(w, 4);\n                        float kernel = 0.0;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            kernel += x[i] * va_arg(w, double);\n                        }\n\n                        return kernel;\n                    }\n                };\n            }\n        }\n    }\nIn your sketch:\n#include &quot;IrisSEFR.h&quot;\n#include &quot;IrisTest.h&quot;\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\nvoid loop() {\n    Eloquent::ML::Port::SEFR clf;\n    Eloquent::ML::Test::IrisTestSet testSet;\n\n    testSet.test(clf);\n    Serial.println(testSet.dump());\n    delay(5000);\n}\nYou have to clone the Github example to compile the code.\n\nThat's all for today, I hope you will try this classifier and find a project it fits in: I'm very impressed by the easiness of implementation yet the accuracy it can achieve on benchmark datasets.\nIn the next weeks I'm thinking in implementing a multi-class version of this and see how it performs, so stay tuned!\nL'articolo SEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices proviene da Eloquent Arduino Blog.",
            "date_published": "2020-07-10T17:09:58+02:00",
            "date_modified": "2020-07-12T17:04:14+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1203",
            "url": "https://eloquentarduino.github.io/2020/06/easy-esp32-camera-http-video-streaming-server/",
            "title": "Easy ESP32 camera HTTP video streaming server",
            "content_html": "<p>This will be a short post where I introduce a new addition to the Arduino Eloquent library aimed to make video streaming from an ESP32 camera over HTTP super easy. It will be the first component of a larger project I'm going to implement.</p>\n<p><span id=\"more-1203\"></span></p>\n<p>If you Google &quot;esp32 video streaming&quot; you will get a bunch of results that are essentialy copy-pasted from the official Espressif repo: many of them neither copy-pasted the code, just tell you to load the example sketch.</p>\n<p>And if you try to read it and try to modify just a bit for your own use-case, you won't understand much.</p>\n<p>This is the exact environment for an Eloquent component to live: make it painfully easy what's messy.</p>\n<p>I still have to find a good naming scheme for my libraries since Arduino IDE doesn't allow nested imports, so forgive me if &quot;ESP32CameraHTTPVideoStreamingServer.h&quot; was the best that came to mind.</p>\n<p>How easy is it to use?</p>\n<p>1 line of code if used in conjuction with my other library <a href=\"https://github.com/eloquentarduino/EloquentVision\">EloquentVision</a>.</p>\n<pre><code class=\"language-cpp\">#define CAMERA_MODEL_M5STACK_WIDE\n#include &quot;WiFi.h&quot;\n#include &quot;EloquentVision.h&quot;\n#include &quot;ESP32CameraHTTPVideoStreamingServer.h&quot;\n\nusing namespace Eloquent::Vision;\nusing namespace Eloquent::Vision::Camera;\n\nESP32Camera camera;\nHTTPVideoStreamingServer server(81);\n\n/**\n *\n */\nvoid setup() {\n    Serial.begin(115200);\n    WiFi.softAP(&quot;ESP32&quot;, &quot;12345678&quot;);\n\n    camera.begin(FRAMESIZE_QVGA, PIXFORMAT_JPEG);\n    server.start();\n\n    Serial.print(&quot;Camera Ready! Use &#039;http://&quot;);\n    Serial.print(WiFi.softAPIP());\n    Serial.println(&quot;:81&#039; to stream&quot;);\n}\n\nvoid loop() {\n}</code></pre>\n<p><code>HTTPVideoStreamingServer</code> assumes you already initialized your camera. You can achieve this task in the way you prefer: <code>ESP32Camera</code> class makes this a breeze.</p>\n<p><code>81</code> in the server constructor is the port you want the server to be listening to.</p>\n<p>Once connected to WiFi or started in AP mode, all you have to do is call <code>start()</code>: that's it!</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the (more than) monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<p>What else is it good for?</p>\n<p>The main reason I wrote this piece of library is because one of you reader commented on the <a href=\"/2020/05/easier-faster-pure-video-esp32-cam-motion-detection/\">motion detection post</a> asking if it would be possible to start the video streaming once motion is detected.</p>\n<p>Of course it is.</p>\n<p>It's just a matter of composing the Eloquent pieces.</p>\n<pre><code class=\"language-cpp\">// not workings AS-IS, needs refactoring\n\n#define CAMERA_MODEL_M5STACK_WIDE\n#include &quot;WiFi.h&quot;\n#include &quot;EloquentVision.h&quot;\n#include &quot;ESP32CameraHTTPVideoStreamingServer.h&quot;\n\n#define FRAME_SIZE FRAMESIZE_QVGA\n#define SOURCE_WIDTH 320\n#define SOURCE_HEIGHT 240\n#define CHANNELS 1\n#define DEST_WIDTH 32\n#define DEST_HEIGHT 24\n#define BLOCK_VARIATION_THRESHOLD 0.3\n#define MOTION_THRESHOLD 0.2\n\n// we&#039;re using the Eloquent::Vision namespace a lot!\nusing namespace Eloquent::Vision;\nusing namespace Eloquent::Vision::Camera;\nusing namespace Eloquent::Vision::ImageProcessing;\nusing namespace Eloquent::Vision::ImageProcessing::Downscale;\nusing namespace Eloquent::Vision::ImageProcessing::DownscaleStrategies;\n\nESP32Camera camera;\nHTTPVideoStreamingServer server(81);\n// the buffer to store the downscaled version of the image\nuint8_t resized[DEST_HEIGHT][DEST_WIDTH];\n// the downscaler algorithm\n// for more details see https://eloquentarduino.github.io/2020/05/easier-faster-pure-video-esp32-cam-motion-detection\nCross&lt;SOURCE_WIDTH, SOURCE_HEIGHT, DEST_WIDTH, DEST_HEIGHT&gt; crossStrategy;\n// the downscaler container\nDownscaler&lt;SOURCE_WIDTH, SOURCE_HEIGHT, CHANNELS, DEST_WIDTH, DEST_HEIGHT&gt; downscaler(&amp;crossStrategy);\n// the motion detection algorithm\nMotionDetection&lt;DEST_WIDTH, DEST_HEIGHT&gt; motion;\n\n/**\n *\n */\nvoid setup() {\n    Serial.begin(115200);\n    WiFi.softAP(&quot;ESP32&quot;, &quot;12345678&quot;);\n\n    camera.begin(FRAMESIZE_QVGA, PIXFORMAT_GRAYSCALE);\n    motion.setBlockVariationThreshold(BLOCK_VARIATION_THRESHOLD);\n\n    Serial.print(&quot;Camera Ready! Use &#039;http://&quot;);\n    Serial.print(WiFi.softAPIP());\n    Serial.println(&quot;:81&#039; to stream&quot;);\n}\n\nvoid loop() {\n    camera_fb_t *frame = camera.capture();\n\n    // resize image and detect motion\n    downscaler.downscale(frame-&gt;buf, resized);\n    motion.update(resized);\n    motion.detect();\n\n    if (motion.ratio() &gt; MOTION_THRESHOLD) {\n        Serial.print(&quot;Motion detected&quot;);\n        // start the streaming server when motion is detected\n        // shutdown after 20 seconds if no one connects\n        camera.begin(FRAMESIZE_QVGA, PIXFORMAT_JPEG);\n        delay(2000);\n        Serial.print(&quot;Camera Server ready! Use &#039;http://&quot;);\n        Serial.print(WiFi.softAPIP());\n        Serial.println(&quot;:81&#039; to stream&quot;);\n        server.start();\n        delay(20000);\n        server.stop();\n        camera.begin(FRAMESIZE_QVGA, PIXFORMAT_GRAYSCALE);\n        delay(2000);\n    }\n\n    // probably we don&#039;t need 30 fps, save some power\n    delay(300);\n}</code></pre>\n<p>Does it look good?</p>\n<p>Now the rationale behind Eloquent components should be starting to be clear to you: easy to use objects you can compose the way it fits to achieve the result you want.</p>\n<p>Would you suggest me more piece of functionality you would like to see wrapped in an Eloquent component?</p>\n<hr />\n<p>You can find the <a href=\"https://github.com/eloquentarduino/EloquentVision/blob/master/src/ESP32CameraHTTPVideoStreamingServer.h\">class code</a> and the <a href=\"https://github.com/eloquentarduino/EloquentVision/blob/master/examples/ESP32CameraHTTPVideoStreamingServerExample/ESP32CameraHTTPVideoStreamingServerExample.ino\">example sketch</a> on the <a href=\"https://github.com/eloquentarduino/EloquentVision\">Github repo</a>.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/06/easy-esp32-camera-http-video-streaming-server/\">Easy ESP32 camera HTTP video streaming server</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "This will be a short post where I introduce a new addition to the Arduino Eloquent library aimed to make video streaming from an ESP32 camera over HTTP super easy. It will be the first component of a larger project I'm going to implement.\n\nIf you Google &quot;esp32 video streaming&quot; you will get a bunch of results that are essentialy copy-pasted from the official Espressif repo: many of them neither copy-pasted the code, just tell you to load the example sketch.\nAnd if you try to read it and try to modify just a bit for your own use-case, you won't understand much.\nThis is the exact environment for an Eloquent component to live: make it painfully easy what's messy.\nI still have to find a good naming scheme for my libraries since Arduino IDE doesn't allow nested imports, so forgive me if &quot;ESP32CameraHTTPVideoStreamingServer.h&quot; was the best that came to mind.\nHow easy is it to use?\n1 line of code if used in conjuction with my other library EloquentVision.\n#define CAMERA_MODEL_M5STACK_WIDE\n#include &quot;WiFi.h&quot;\n#include &quot;EloquentVision.h&quot;\n#include &quot;ESP32CameraHTTPVideoStreamingServer.h&quot;\n\nusing namespace Eloquent::Vision;\nusing namespace Eloquent::Vision::Camera;\n\nESP32Camera camera;\nHTTPVideoStreamingServer server(81);\n\n/**\n *\n */\nvoid setup() {\n    Serial.begin(115200);\n    WiFi.softAP(&quot;ESP32&quot;, &quot;12345678&quot;);\n\n    camera.begin(FRAMESIZE_QVGA, PIXFORMAT_JPEG);\n    server.start();\n\n    Serial.print(&quot;Camera Ready! Use &#039;http://&quot;);\n    Serial.print(WiFi.softAPIP());\n    Serial.println(&quot;:81&#039; to stream&quot;);\n}\n\nvoid loop() {\n}\nHTTPVideoStreamingServer assumes you already initialized your camera. You can achieve this task in the way you prefer: ESP32Camera class makes this a breeze.\n81 in the server constructor is the port you want the server to be listening to.\nOnce connected to WiFi or started in AP mode, all you have to do is call start(): that's it!\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nWhat else is it good for?\nThe main reason I wrote this piece of library is because one of you reader commented on the motion detection post asking if it would be possible to start the video streaming once motion is detected.\nOf course it is.\nIt's just a matter of composing the Eloquent pieces.\n// not workings AS-IS, needs refactoring\n\n#define CAMERA_MODEL_M5STACK_WIDE\n#include &quot;WiFi.h&quot;\n#include &quot;EloquentVision.h&quot;\n#include &quot;ESP32CameraHTTPVideoStreamingServer.h&quot;\n\n#define FRAME_SIZE FRAMESIZE_QVGA\n#define SOURCE_WIDTH 320\n#define SOURCE_HEIGHT 240\n#define CHANNELS 1\n#define DEST_WIDTH 32\n#define DEST_HEIGHT 24\n#define BLOCK_VARIATION_THRESHOLD 0.3\n#define MOTION_THRESHOLD 0.2\n\n// we&#039;re using the Eloquent::Vision namespace a lot!\nusing namespace Eloquent::Vision;\nusing namespace Eloquent::Vision::Camera;\nusing namespace Eloquent::Vision::ImageProcessing;\nusing namespace Eloquent::Vision::ImageProcessing::Downscale;\nusing namespace Eloquent::Vision::ImageProcessing::DownscaleStrategies;\n\nESP32Camera camera;\nHTTPVideoStreamingServer server(81);\n// the buffer to store the downscaled version of the image\nuint8_t resized[DEST_HEIGHT][DEST_WIDTH];\n// the downscaler algorithm\n// for more details see https://eloquentarduino.github.io/2020/05/easier-faster-pure-video-esp32-cam-motion-detection\nCross&lt;SOURCE_WIDTH, SOURCE_HEIGHT, DEST_WIDTH, DEST_HEIGHT&gt; crossStrategy;\n// the downscaler container\nDownscaler&lt;SOURCE_WIDTH, SOURCE_HEIGHT, CHANNELS, DEST_WIDTH, DEST_HEIGHT&gt; downscaler(&amp;crossStrategy);\n// the motion detection algorithm\nMotionDetection&lt;DEST_WIDTH, DEST_HEIGHT&gt; motion;\n\n/**\n *\n */\nvoid setup() {\n    Serial.begin(115200);\n    WiFi.softAP(&quot;ESP32&quot;, &quot;12345678&quot;);\n\n    camera.begin(FRAMESIZE_QVGA, PIXFORMAT_GRAYSCALE);\n    motion.setBlockVariationThreshold(BLOCK_VARIATION_THRESHOLD);\n\n    Serial.print(&quot;Camera Ready! Use &#039;http://&quot;);\n    Serial.print(WiFi.softAPIP());\n    Serial.println(&quot;:81&#039; to stream&quot;);\n}\n\nvoid loop() {\n    camera_fb_t *frame = camera.capture();\n\n    // resize image and detect motion\n    downscaler.downscale(frame-&gt;buf, resized);\n    motion.update(resized);\n    motion.detect();\n\n    if (motion.ratio() &gt; MOTION_THRESHOLD) {\n        Serial.print(&quot;Motion detected&quot;);\n        // start the streaming server when motion is detected\n        // shutdown after 20 seconds if no one connects\n        camera.begin(FRAMESIZE_QVGA, PIXFORMAT_JPEG);\n        delay(2000);\n        Serial.print(&quot;Camera Server ready! Use &#039;http://&quot;);\n        Serial.print(WiFi.softAPIP());\n        Serial.println(&quot;:81&#039; to stream&quot;);\n        server.start();\n        delay(20000);\n        server.stop();\n        camera.begin(FRAMESIZE_QVGA, PIXFORMAT_GRAYSCALE);\n        delay(2000);\n    }\n\n    // probably we don&#039;t need 30 fps, save some power\n    delay(300);\n}\nDoes it look good?\nNow the rationale behind Eloquent components should be starting to be clear to you: easy to use objects you can compose the way it fits to achieve the result you want.\nWould you suggest me more piece of functionality you would like to see wrapped in an Eloquent component?\n\nYou can find the class code and the example sketch on the Github repo.\nL'articolo Easy ESP32 camera HTTP video streaming server proviene da Eloquent Arduino Blog.",
            "date_published": "2020-06-24T19:27:33+02:00",
            "date_modified": "2020-12-16T21:29:52+01:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "camera",
                "esp32",
                "Eloquent library"
            ]
        }
    ]
}