{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/category/programming/arduino-machine-learning/arduino-machine-learning-tutorial/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/category/programming/arduino-machine-learning/arduino-machine-learning-tutorial/",
    "feed_url": "https://eloquentarduino.github.io/category/programming/arduino-machine-learning/arduino-machine-learning-tutorial/feed/json/",
    "language": "en-US",
    "title": "Arduino Machine Learning tutorial &#8211; Eloquent Arduino Blog",
    "description": "Machine learning on Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/?p=1264",
            "url": "https://eloquentarduino.github.io/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/",
            "title": "Decision Tree, Random Forest and XGBoost on Arduino",
            "content_html": "<p>You will be surprised by how much accuracy you can achieve in just a few kylobytes of resources: <strong>Decision Tree, Random Forest and XGBoost (Extreme Gradient Boosting)</strong> are now available on your microcontrollers: highly RAM-optmized implementations for super-fast classification on embedded devices.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/DecisionTree.png\" alt=\"DecisionTree\" /></p>\n<p><span id=\"more-1264\"></span></p>\n<h2>Decision Tree</h2>\n<p><strong>Decision Tree</strong> is without doubt one of the most well-known classification algorithms out there. It is so simple to understand that it was probably the first classifier you encountered in any Machine Learning course.</p>\n<p>I won't go into the details of how a Decision Tree classifier trains and selects the splits for the input features: here I will explain how a RAM-efficient porting of such a classifier is implemented.</p>\n<p>To an introduction visit <a href=\"https://en.wikipedia.org/wiki/Decision_tree_learning\">Wikipedia</a>; for a more in-depth guide visit <a href=\"https://www.kdnuggets.com/2020/01/decision-tree-algorithm-explained.html\">KDNuggets</a>.</p>\n<p>Since we're willing to sacrifice program space (a.k.a flash) in favor of memory (a.k.a RAM), because RAM is the most scarce resource in the vast majority of microcontrollers, the smart way to port a Decision Tree classifier from Python to C is &quot;hard-coding&quot; the splits in code, without keeping any reference to them into variables.</p>\n<p>Here's what it looks like for a Decision tree that classifies the Iris dataset.</p>\n<p>As you can see, we're using <strong>0 bytes of RAM</strong> to get the classification result, since no variable is being allocated. On the other side, the program space will grow almost linearly with the number of splits.</p>\n<p>Since program space is often much greater than RAM on microcontrollers, this implementation exploits its abundance to be able to deploy larger models. How much large? It will depend on the flash size available: many new generations board (Arduino Nano 33 BLE Sense, ESP32, ST Nucleus...) have 1 Mb of flash, which will hold tens of thousands of splits. </p>\n<h2>Random Forest</h2>\n<p><strong><a href=\"https://en.wikipedia.org/wiki/Random_forest\">Random Forest</a></strong> is just many Decision Trees joined together in a voting scheme. The core idea is that of <em>&quot;the wisdom of the corwd&quot;</em>, such that if many trees vote for a given class (having being trained on different subsets of the training set), that class is probably the true class.</p>\n<p><a href=\"https://towardsdatascience.com/understanding-random-forest-58381e0602d2\">Towards Data Science</a> has a more detailed guide on Random Forest and how it balances the trees with the<em>bagging</em> tecnique.</p>\n<p>As easy as Decision Trees, Random Forest gets the exact same implementation with <strong>0 bytes of RAM</strong> required (it actually needs as many bytes as the number of classes to store the votes, but that's really negligible): it just hard-codes all its composing trees.</p>\n<h2>XGBoost (Extreme Gradient Boosting)</h2>\n<p>Extreme Gradient Boosting is <em>&quot;Gradient Boosting on steroids&quot;</em> and has gained much attention from the Machine learning community due to its top results in many data competitions.</p>\n<ol>\n<li>&quot;gradient boosting&quot; refers to the process of chaining a number of trees so that each tree tries to learn from the errors of the previous</li>\n<li>&quot;extreme&quot; refers to many software and hardware optimizations that greatly reduce the time it takes to train the model</li>\n</ol>\n<p>You can read <a href=\"https://www.kdd.org/kdd2016/papers/files/rfp0697-chenAemb.pdf\">the original paper about XGBoost here</a>. For a discursive description head to <a href=\"https://www.kdnuggets.com/2019/05/xgboost-algorithm.html\">KDNuggets</a>, if you want some more math refer to <a href=\"https://medium.com/@gabrieltseng/gradient-boosting-and-xgboost-c306c1bcfaf5\">this blog post on Medium</a>.</p>\n<h2>Porting to plain C</h2>\n<p>If you followed my earlier posts on <a href=\"/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">Gaussian Naive Bayes</a>, <a href=\"https://eloquentarduino.github.io/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/\">SEFR</a>, <a href=\"/2020/02/even-smaller-machine-learning-models-for-your-mcu/\">Relevant Vector Machine</a> and <a href=\"/2019/11/you-can-run-machine-learning-on-arduino/\">Support Vector Machines</a>, you already know how to port these new classifiers.</p>\n<p>If you're new, you will need a couple things:</p>\n<ol>\n<li>install the <a href=\"https://pypi.org/project/micromlgen/\">micromlgen</a> package with </li>\n</ol>\n<pre><code class=\"language-bash\">pip install micromlgen</code></pre>\n<ol start=\"2\">\n<li>(optionally, if you want to use Extreme Gradient Boosting) install the <a href=\"https://pypi.org/project/xgboost/\">xgboost</a> package with </li>\n</ol>\n<pre><code class=\"language-bash\">pip install xgboost</code></pre>\n<ol start=\"3\">\n<li>use the <code>micromlgen.port</code> function to generate your plain C code</li>\n</ol>\n<pre><code class=\"language-python\">from micromlgen import port\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n\nclf = DecisionTreeClassifier()\nX, y = load_iris(return_X_y=True)\nclf.fit(X, y)\nprint(port(clf))</code></pre>\n<p>You can then copy-past the C code and import it in your sketch.</p>\n<h2>Using in the Arduino sketch</h2>\n<p>Once you have the classifier code, create a new project named <code>TreeClassifierExample</code> and copy the classifier code into a file named <code>DecisionTree.h</code> (or <code>RandomForest.h</code> or <code>XGBoost.h</code> depending on the model you chose).</p>\n<p>The copy the following to the main ino file.</p>\n<pre><code class=\"language-cpp\">#include &quot;DecisionTree.h&quot;\n\nEloquent::ML::Port::DecisionTree clf;\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;Begin&quot;);\n}\n\nvoid loop() {\n    float irisSample[4] = {6.2, 2.8, 4.8, 1.8};\n\n    Serial.print(&quot;Predicted label (you should see &#039;2&#039;: &quot;);\n    Serial.println(clf.predict(irisSample));\n    delay(1000);\n}</code></pre>\n<h2>Bechmarks</h2>\n<p>How do the 3 classifiers compare against each other?</p>\n<p>We will evaluate a few keypoints:</p>\n<ul>\n<li>training time</li>\n<li>accuracy</li>\n<li>needed RAM</li>\n<li>needed Flash</li>\n</ul>\n<p>for each classifier on a variety of datasets. I will report the results for RAM and Flash on the Arduino Nano old generation, so you should consider more the relative figures than the absolute ones.</p>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th style=\"text-align: center;\">Classifier</th>\n<th style=\"text-align: center;\">Training <br />time (s)</th>\n<th style=\"text-align: center;\">Accuracy</th>\n<th style=\"text-align: center;\">RAM <br />(bytes)</th>\n<th style=\"text-align: center;\">Flash <br />(bytes)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Gas Sensor Array Drift Dataset </strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">1,6</td>\n<td style=\"text-align: center;\">0.781 \u00b1 0.12</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">5722</td>\n</tr>\n<tr>\n<td>13910 samples x 128 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">3</td>\n<td style=\"text-align: center;\">0.865 \u00b1 0.083</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">6438</td>\n</tr>\n<tr>\n<td>6 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">18,8</td>\n<td style=\"text-align: center;\"><strong>0.878 \u00b1 0.074</strong></td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">6506</td>\n</tr>\n<tr>\n<td><strong>Gesture Phase Segmentation Dataset</strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">0,1</td>\n<td style=\"text-align: center;\">0.943 \u00b1 0.005</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">5638</td>\n</tr>\n<tr>\n<td>10000 samples x 19 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">0,7</td>\n<td style=\"text-align: center;\"><strong>0.970 \u00b1 0.004</strong></td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6466</td>\n</tr>\n<tr>\n<td>5 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">18,9</td>\n<td style=\"text-align: center;\">0.969 \u00b1 0.003</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6536</td>\n</tr>\n<tr>\n<td><strong>Drive Diagnosis Dataset</strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">0,6</td>\n<td style=\"text-align: center;\">0.946 \u00b1 0.005</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">5850</td>\n</tr>\n<tr>\n<td>10000 samples x 48 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">2,6</td>\n<td style=\"text-align: center;\"><strong>0.983 \u00b1 0.003</strong></td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6526</td>\n</tr>\n<tr>\n<td>11 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">68,9</td>\n<td style=\"text-align: center;\">0.977 \u00b1 0.005</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6698</td>\n</tr>\n</tbody>\n</table>\n<p>* <em>all datasets are taken from the <a href=\"https://archive.ics.uci.edu/ml//datasets.php\">UCI Machine Learning datasets archive</a></em></p>\n<p>I'm collecting more data for a complete benchmark, but in the meantime you can see that both Random Forest and XGBoost are on par: if not that XGBoost takes 5 to 25 times longer to train.</p>\n<p>I've never used XGBoost, so I may be missing some tuning parameters, but for now Random Forest remains my favourite classifier.</p>\n<h2>Code listings</h2>\n<pre><code class=\"language-cpp\">// example IRIS dataset classification with Decision Tree\nint predict(float *x) {\n  if (x[3] &lt;= 0.800000011920929) {\n      return 0;\n  }\n  else {\n      if (x[3] &lt;= 1.75) {\n          if (x[2] &lt;= 4.950000047683716) {\n              if (x[0] &lt;= 5.049999952316284) {\n                  return 1;\n              }\n              else {\n                  return 1;\n              }\n          }\n          else {\n              return 2;\n          }\n      }\n      else {\n          if (x[2] &lt;= 4.950000047683716) {\n              return 2;\n          }\n          else {\n              return 2;\n          }\n      }\n  }\n}</code></pre>\n<pre><code class=\"language-cpp\">// example IRIS dataset classification with Random Forest of 3 trees\n\nint predict(float *x) {\n  uint16_t votes[3] = { 0 };\n\n  // tree #1\n  if (x[0] &lt;= 5.450000047683716) {\n      if (x[1] &lt;= 2.950000047683716) {\n          votes[1] += 1;\n      }\n      else {\n          votes[0] += 1;\n      }\n  }\n  else {\n      if (x[0] &lt;= 6.049999952316284) {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[2] &lt;= 3.549999952316284) {\n                  votes[0] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n      else {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[3] &lt;= 1.449999988079071) {\n                  if (x[0] &lt;= 6.1499998569488525) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #2\n  if (x[0] &lt;= 5.549999952316284) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 3.950000047683716) {\n              votes[1] += 1;\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[3] &lt;= 1.699999988079071) {\n          if (x[1] &lt;= 2.649999976158142) {\n              if (x[3] &lt;= 1.25) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              if (x[2] &lt;= 4.1499998569488525) {\n                  votes[1] += 1;\n              }\n              else {\n                  if (x[0] &lt;= 6.75) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n          }\n      }\n      else {\n          if (x[0] &lt;= 6.0) {\n              votes[2] += 1;\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #3\n  if (x[3] &lt;= 1.75) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 4.8500001430511475) {\n              if (x[0] &lt;= 5.299999952316284) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[0] &lt;= 5.950000047683716) {\n          votes[2] += 1;\n      }\n      else {\n          votes[2] += 1;\n      }\n  }\n\n  // return argmax of votes\n  uint8_t classIdx = 0;\n  float maxVotes = votes[0];\n\n  for (uint8_t i = 1; i &lt; 3; i++) {\n      if (votes[i] &gt; maxVotes) {\n          classIdx = i;\n          maxVotes = votes[i];\n      }\n  }\n\n  return classIdx;\n}</code></pre>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/\">Decision Tree, Random Forest and XGBoost on Arduino</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "You will be surprised by how much accuracy you can achieve in just a few kylobytes of resources: Decision Tree, Random Forest and XGBoost (Extreme Gradient Boosting) are now available on your microcontrollers: highly RAM-optmized implementations for super-fast classification on embedded devices.\n\n\nDecision Tree\nDecision Tree is without doubt one of the most well-known classification algorithms out there. It is so simple to understand that it was probably the first classifier you encountered in any Machine Learning course.\nI won't go into the details of how a Decision Tree classifier trains and selects the splits for the input features: here I will explain how a RAM-efficient porting of such a classifier is implemented.\nTo an introduction visit Wikipedia; for a more in-depth guide visit KDNuggets.\nSince we're willing to sacrifice program space (a.k.a flash) in favor of memory (a.k.a RAM), because RAM is the most scarce resource in the vast majority of microcontrollers, the smart way to port a Decision Tree classifier from Python to C is &quot;hard-coding&quot; the splits in code, without keeping any reference to them into variables.\nHere's what it looks like for a Decision tree that classifies the Iris dataset.\nAs you can see, we're using 0 bytes of RAM to get the classification result, since no variable is being allocated. On the other side, the program space will grow almost linearly with the number of splits.\nSince program space is often much greater than RAM on microcontrollers, this implementation exploits its abundance to be able to deploy larger models. How much large? It will depend on the flash size available: many new generations board (Arduino Nano 33 BLE Sense, ESP32, ST Nucleus...) have 1 Mb of flash, which will hold tens of thousands of splits. \nRandom Forest\nRandom Forest is just many Decision Trees joined together in a voting scheme. The core idea is that of &quot;the wisdom of the corwd&quot;, such that if many trees vote for a given class (having being trained on different subsets of the training set), that class is probably the true class.\nTowards Data Science has a more detailed guide on Random Forest and how it balances the trees with thebagging tecnique.\nAs easy as Decision Trees, Random Forest gets the exact same implementation with 0 bytes of RAM required (it actually needs as many bytes as the number of classes to store the votes, but that's really negligible): it just hard-codes all its composing trees.\nXGBoost (Extreme Gradient Boosting)\nExtreme Gradient Boosting is &quot;Gradient Boosting on steroids&quot; and has gained much attention from the Machine learning community due to its top results in many data competitions.\n\n&quot;gradient boosting&quot; refers to the process of chaining a number of trees so that each tree tries to learn from the errors of the previous\n&quot;extreme&quot; refers to many software and hardware optimizations that greatly reduce the time it takes to train the model\n\nYou can read the original paper about XGBoost here. For a discursive description head to KDNuggets, if you want some more math refer to this blog post on Medium.\nPorting to plain C\nIf you followed my earlier posts on Gaussian Naive Bayes, SEFR, Relevant Vector Machine and Support Vector Machines, you already know how to port these new classifiers.\nIf you're new, you will need a couple things:\n\ninstall the micromlgen package with \n\npip install micromlgen\n\n(optionally, if you want to use Extreme Gradient Boosting) install the xgboost package with \n\npip install xgboost\n\nuse the micromlgen.port function to generate your plain C code\n\nfrom micromlgen import port\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n\nclf = DecisionTreeClassifier()\nX, y = load_iris(return_X_y=True)\nclf.fit(X, y)\nprint(port(clf))\nYou can then copy-past the C code and import it in your sketch.\nUsing in the Arduino sketch\nOnce you have the classifier code, create a new project named TreeClassifierExample and copy the classifier code into a file named DecisionTree.h (or RandomForest.h or XGBoost.h depending on the model you chose).\nThe copy the following to the main ino file.\n#include &quot;DecisionTree.h&quot;\n\nEloquent::ML::Port::DecisionTree clf;\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;Begin&quot;);\n}\n\nvoid loop() {\n    float irisSample[4] = {6.2, 2.8, 4.8, 1.8};\n\n    Serial.print(&quot;Predicted label (you should see &#039;2&#039;: &quot;);\n    Serial.println(clf.predict(irisSample));\n    delay(1000);\n}\nBechmarks\nHow do the 3 classifiers compare against each other?\nWe will evaluate a few keypoints:\n\ntraining time\naccuracy\nneeded RAM\nneeded Flash\n\nfor each classifier on a variety of datasets. I will report the results for RAM and Flash on the Arduino Nano old generation, so you should consider more the relative figures than the absolute ones.\n\n\n\nDataset\nClassifier\nTraining time (s)\nAccuracy\nRAM (bytes)\nFlash (bytes)\n\n\n\n\nGas Sensor Array Drift Dataset \nDecision Tree\n1,6\n0.781 \u00b1 0.12\n290\n5722\n\n\n13910 samples x 128 features\nRandom Forest\n3\n0.865 \u00b1 0.083\n290\n6438\n\n\n6 classes\nXGBoost\n18,8\n0.878 \u00b1 0.074\n290\n6506\n\n\nGesture Phase Segmentation Dataset\nDecision Tree\n0,1\n0.943 \u00b1 0.005\n290\n5638\n\n\n10000 samples x 19 features\nRandom Forest\n0,7\n0.970 \u00b1 0.004\n306\n6466\n\n\n5 classes\nXGBoost\n18,9\n0.969 \u00b1 0.003\n306\n6536\n\n\nDrive Diagnosis Dataset\nDecision Tree\n0,6\n0.946 \u00b1 0.005\n306\n5850\n\n\n10000 samples x 48 features\nRandom Forest\n2,6\n0.983 \u00b1 0.003\n306\n6526\n\n\n11 classes\nXGBoost\n68,9\n0.977 \u00b1 0.005\n306\n6698\n\n\n\n* all datasets are taken from the UCI Machine Learning datasets archive\nI'm collecting more data for a complete benchmark, but in the meantime you can see that both Random Forest and XGBoost are on par: if not that XGBoost takes 5 to 25 times longer to train.\nI've never used XGBoost, so I may be missing some tuning parameters, but for now Random Forest remains my favourite classifier.\nCode listings\n// example IRIS dataset classification with Decision Tree\nint predict(float *x) {\n  if (x[3] &lt;= 0.800000011920929) {\n      return 0;\n  }\n  else {\n      if (x[3] &lt;= 1.75) {\n          if (x[2] &lt;= 4.950000047683716) {\n              if (x[0] &lt;= 5.049999952316284) {\n                  return 1;\n              }\n              else {\n                  return 1;\n              }\n          }\n          else {\n              return 2;\n          }\n      }\n      else {\n          if (x[2] &lt;= 4.950000047683716) {\n              return 2;\n          }\n          else {\n              return 2;\n          }\n      }\n  }\n}\n// example IRIS dataset classification with Random Forest of 3 trees\n\nint predict(float *x) {\n  uint16_t votes[3] = { 0 };\n\n  // tree #1\n  if (x[0] &lt;= 5.450000047683716) {\n      if (x[1] &lt;= 2.950000047683716) {\n          votes[1] += 1;\n      }\n      else {\n          votes[0] += 1;\n      }\n  }\n  else {\n      if (x[0] &lt;= 6.049999952316284) {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[2] &lt;= 3.549999952316284) {\n                  votes[0] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n      else {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[3] &lt;= 1.449999988079071) {\n                  if (x[0] &lt;= 6.1499998569488525) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #2\n  if (x[0] &lt;= 5.549999952316284) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 3.950000047683716) {\n              votes[1] += 1;\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[3] &lt;= 1.699999988079071) {\n          if (x[1] &lt;= 2.649999976158142) {\n              if (x[3] &lt;= 1.25) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              if (x[2] &lt;= 4.1499998569488525) {\n                  votes[1] += 1;\n              }\n              else {\n                  if (x[0] &lt;= 6.75) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n          }\n      }\n      else {\n          if (x[0] &lt;= 6.0) {\n              votes[2] += 1;\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #3\n  if (x[3] &lt;= 1.75) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 4.8500001430511475) {\n              if (x[0] &lt;= 5.299999952316284) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[0] &lt;= 5.950000047683716) {\n          votes[2] += 1;\n      }\n      else {\n          votes[2] += 1;\n      }\n  }\n\n  // return argmax of votes\n  uint8_t classIdx = 0;\n  float maxVotes = votes[0];\n\n  for (uint8_t i = 1; i &lt; 3; i++) {\n      if (votes[i] &gt; maxVotes) {\n          classIdx = i;\n          maxVotes = votes[i];\n      }\n  }\n\n  return classIdx;\n}\nL'articolo Decision Tree, Random Forest and XGBoost on Arduino proviene da Eloquent Arduino Blog.",
            "date_published": "2020-10-19T19:31:02+02:00",
            "date_modified": "2020-12-10T12:26:23+01:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning",
                "Arduino Machine Learning tutorial"
            ]
        }
    ]
}