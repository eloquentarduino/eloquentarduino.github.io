{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/tag/microml/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/tag/microml/",
    "feed_url": "https://eloquentarduino.github.io/tag/microml/feed/json/",
    "language": "en-US",
    "title": "microml &#8211; Eloquent Arduino Blog",
    "description": "Machine learning on Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/?p=1264",
            "url": "https://eloquentarduino.github.io/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/",
            "title": "Decision Tree, Random Forest and XGBoost on Arduino",
            "content_html": "<p>You will be surprised by how much accuracy you can achieve in just a few kylobytes of resources: <strong>Decision Tree, Random Forest and XGBoost (Extreme Gradient Boosting)</strong> are now available on your microcontrollers: highly RAM-optmized implementations for super-fast classification on embedded devices.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/DecisionTree.png\" alt=\"DecisionTree\" /></p>\n<p><span id=\"more-1264\"></span></p>\n<h2>Decision Tree</h2>\n<p><strong>Decision Tree</strong> is without doubt one of the most well-known classification algorithms out there. It is so simple to understand that it was probably the first classifier you encountered in any Machine Learning course.</p>\n<p>I won't go into the details of how a Decision Tree classifier trains and selects the splits for the input features: here I will explain how a RAM-efficient porting of such a classifier is implemented.</p>\n<p>To an introduction visit <a href=\"https://en.wikipedia.org/wiki/Decision_tree_learning\">Wikipedia</a>; for a more in-depth guide visit <a href=\"https://www.kdnuggets.com/2020/01/decision-tree-algorithm-explained.html\">KDNuggets</a>.</p>\n<p>Since we're willing to sacrifice program space (a.k.a flash) in favor of memory (a.k.a RAM), because RAM is the most scarce resource in the vast majority of microcontrollers, the smart way to port a Decision Tree classifier from Python to C is &quot;hard-coding&quot; the splits in code, without keeping any reference to them into variables.</p>\n<p>Here's what it looks like for a Decision tree that classifies the Iris dataset.</p>\n<p>As you can see, we're using <strong>0 bytes of RAM</strong> to get the classification result, since no variable is being allocated. On the other side, the program space will grow almost linearly with the number of splits.</p>\n<p>Since program space is often much greater than RAM on microcontrollers, this implementation exploits its abundance to be able to deploy larger models. How much large? It will depend on the flash size available: many new generations board (Arduino Nano 33 BLE Sense, ESP32, ST Nucleus...) have 1 Mb of flash, which will hold tens of thousands of splits. </p>\n<h2>Random Forest</h2>\n<p><strong><a href=\"https://en.wikipedia.org/wiki/Random_forest\">Random Forest</a></strong> is just many Decision Trees joined together in a voting scheme. The core idea is that of <em>&quot;the wisdom of the corwd&quot;</em>, such that if many trees vote for a given class (having being trained on different subsets of the training set), that class is probably the true class.</p>\n<p><a href=\"https://towardsdatascience.com/understanding-random-forest-58381e0602d2\">Towards Data Science</a> has a more detailed guide on Random Forest and how it balances the trees with the<em>bagging</em> tecnique.</p>\n<p>As easy as Decision Trees, Random Forest gets the exact same implementation with <strong>0 bytes of RAM</strong> required (it actually needs as many bytes as the number of classes to store the votes, but that's really negligible): it just hard-codes all its composing trees.</p>\n<h2>XGBoost (Extreme Gradient Boosting)</h2>\n<p>Extreme Gradient Boosting is <em>&quot;Gradient Boosting on steroids&quot;</em> and has gained much attention from the Machine learning community due to its top results in many data competitions.</p>\n<ol>\n<li>&quot;gradient boosting&quot; refers to the process of chaining a number of trees so that each tree tries to learn from the errors of the previous</li>\n<li>&quot;extreme&quot; refers to many software and hardware optimizations that greatly reduce the time it takes to train the model</li>\n</ol>\n<p>You can read <a href=\"https://www.kdd.org/kdd2016/papers/files/rfp0697-chenAemb.pdf\">the original paper about XGBoost here</a>. For a discursive description head to <a href=\"https://www.kdnuggets.com/2019/05/xgboost-algorithm.html\">KDNuggets</a>, if you want some more math refer to <a href=\"https://medium.com/@gabrieltseng/gradient-boosting-and-xgboost-c306c1bcfaf5\">this blog post on Medium</a>.</p>\n<h2>Porting to plain C</h2>\n<p>If you followed my earlier posts on <a href=\"/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">Gaussian Naive Bayes</a>, <a href=\"https://eloquentarduino.github.io/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/\">SEFR</a>, <a href=\"/2020/02/even-smaller-machine-learning-models-for-your-mcu/\">Relevant Vector Machine</a> and <a href=\"/2019/11/you-can-run-machine-learning-on-arduino/\">Support Vector Machines</a>, you already know how to port these new classifiers.</p>\n<p>If you're new, you will need a couple things:</p>\n<ol>\n<li>install the <a href=\"https://pypi.org/project/micromlgen/\">micromlgen</a> package with </li>\n</ol>\n<pre><code class=\"language-bash\">pip install micromlgen</code></pre>\n<ol start=\"2\">\n<li>(optionally, if you want to use Extreme Gradient Boosting) install the <a href=\"https://pypi.org/project/xgboost/\">xgboost</a> package with </li>\n</ol>\n<pre><code class=\"language-bash\">pip install xgboost</code></pre>\n<ol start=\"3\">\n<li>use the <code>micromlgen.port</code> function to generate your plain C code</li>\n</ol>\n<pre><code class=\"language-python\">from micromlgen import port\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n\nclf = DecisionTreeClassifier\nX, y = load_iris(return_X_y=True)\nclf.fit(X, y)\nprint(port(clf))</code></pre>\n<p>You can then copy-past the C code and import it in your sketch.</p>\n<h2>Using in the Arduino sketch</h2>\n<p>Once you have the classifier code, create a new project named <code>TreeClassifierExample</code> and copy the classifier code into a file named <code>DecisionTree.h</code> (or <code>RandomForest.h</code> or <code>XGBoost.h</code> depending on the model you chose).</p>\n<p>The copy the following to the main ino file.</p>\n<pre><code class=\"language-cpp\">#include &quot;DecisionTree.h&quot;\n\nEloquent::ML::Port::DecisionTree clf;\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;Begin&quot;);\n}\n\nvoid loop() {\n    float irisSample[4] = {6.2, 2.8, 4.8, 1.8};\n\n    Serial.print(&quot;Predicted label (you should see &#039;2&#039;: &quot;);\n    Serial.println(clf.predict(irisSample));\n    delay(1000);\n}</code></pre>\n<h2>Bechmarks</h2>\n<p>How do the 3 classifiers compare against each other?</p>\n<p>We will evaluate a few keypoints:</p>\n<ul>\n<li>training time</li>\n<li>accuracy</li>\n<li>needed RAM</li>\n<li>needed Flash</li>\n</ul>\n<p>for each classifier on a variety of datasets. I will report the results for RAM and Flash on the Arduino Nano old generation, so you should consider more the relative figures than the absolute ones.</p>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th style=\"text-align: center;\">Classifier</th>\n<th style=\"text-align: center;\">Training <br />time (s)</th>\n<th style=\"text-align: center;\">Accuracy</th>\n<th style=\"text-align: center;\">RAM <br />(bytes)</th>\n<th style=\"text-align: center;\">Flash <br />(bytes)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Gas Sensor Array Drift Dataset </strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">1,6</td>\n<td style=\"text-align: center;\">0.781 \u00b1 0.12</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">5722</td>\n</tr>\n<tr>\n<td>13910 samples x 128 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">3</td>\n<td style=\"text-align: center;\">0.865 \u00b1 0.083</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">6438</td>\n</tr>\n<tr>\n<td>6 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">18,8</td>\n<td style=\"text-align: center;\"><strong>0.878 \u00b1 0.074</strong></td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">6506</td>\n</tr>\n<tr>\n<td><strong>Gesture Phase Segmentation Dataset</strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">0,1</td>\n<td style=\"text-align: center;\">0.943 \u00b1 0.005</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">5638</td>\n</tr>\n<tr>\n<td>10000 samples x 19 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">0,7</td>\n<td style=\"text-align: center;\"><strong>0.970 \u00b1 0.004</strong></td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6466</td>\n</tr>\n<tr>\n<td>5 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">18,9</td>\n<td style=\"text-align: center;\">0.969 \u00b1 0.003</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6536</td>\n</tr>\n<tr>\n<td><strong>Drive Diagnosis Dataset</strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">0,6</td>\n<td style=\"text-align: center;\">0.946 \u00b1 0.005</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">5850</td>\n</tr>\n<tr>\n<td>10000 samples x 48 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">2,6</td>\n<td style=\"text-align: center;\"><strong>0.983 \u00b1 0.003</strong></td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6526</td>\n</tr>\n<tr>\n<td>11 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">68,9</td>\n<td style=\"text-align: center;\">0.977 \u00b1 0.005</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6698</td>\n</tr>\n</tbody>\n</table>\n<p>* <em>all datasets are taken from the <a href=\"https://archive.ics.uci.edu/ml//datasets.php\">UCI Machine Learning datasets archive</a></em></p>\n<p>I'm collecting more data for a complete benchmark, but in the meantime you can see that both Random Forest and XGBoost are on par: if not that XGBoost takes 5 to 25 times longer to train.</p>\n<p>I've never used XGBoost, so I may be missing some tuning parameters, but for now Random Forest remains my favourite classifier.</p>\n<h2>Code listings</h2>\n<pre><code class=\"language-cpp\">// example IRIS dataset classification with Decision Tree\nint predict(float *x) {\n  if (x[3] &lt;= 0.800000011920929) {\n      return 0;\n  }\n  else {\n      if (x[3] &lt;= 1.75) {\n          if (x[2] &lt;= 4.950000047683716) {\n              if (x[0] &lt;= 5.049999952316284) {\n                  return 1;\n              }\n              else {\n                  return 1;\n              }\n          }\n          else {\n              return 2;\n          }\n      }\n      else {\n          if (x[2] &lt;= 4.950000047683716) {\n              return 2;\n          }\n          else {\n              return 2;\n          }\n      }\n  }\n}</code></pre>\n<pre><code class=\"language-cpp\">// example IRIS dataset classification with Random Forest of 3 trees\n\nint predict(float *x) {\n  uint16_t votes[3] = { 0 };\n\n  // tree #1\n  if (x[0] &lt;= 5.450000047683716) {\n      if (x[1] &lt;= 2.950000047683716) {\n          votes[1] += 1;\n      }\n      else {\n          votes[0] += 1;\n      }\n  }\n  else {\n      if (x[0] &lt;= 6.049999952316284) {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[2] &lt;= 3.549999952316284) {\n                  votes[0] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n      else {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[3] &lt;= 1.449999988079071) {\n                  if (x[0] &lt;= 6.1499998569488525) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #2\n  if (x[0] &lt;= 5.549999952316284) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 3.950000047683716) {\n              votes[1] += 1;\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[3] &lt;= 1.699999988079071) {\n          if (x[1] &lt;= 2.649999976158142) {\n              if (x[3] &lt;= 1.25) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              if (x[2] &lt;= 4.1499998569488525) {\n                  votes[1] += 1;\n              }\n              else {\n                  if (x[0] &lt;= 6.75) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n          }\n      }\n      else {\n          if (x[0] &lt;= 6.0) {\n              votes[2] += 1;\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #3\n  if (x[3] &lt;= 1.75) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 4.8500001430511475) {\n              if (x[0] &lt;= 5.299999952316284) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[0] &lt;= 5.950000047683716) {\n          votes[2] += 1;\n      }\n      else {\n          votes[2] += 1;\n      }\n  }\n\n  // return argmax of votes\n  uint8_t classIdx = 0;\n  float maxVotes = votes[0];\n\n  for (uint8_t i = 1; i &lt; 3; i++) {\n      if (votes[i] &gt; maxVotes) {\n          classIdx = i;\n          maxVotes = votes[i];\n      }\n  }\n\n  return classIdx;\n}</code></pre>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/\">Decision Tree, Random Forest and XGBoost on Arduino</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "You will be surprised by how much accuracy you can achieve in just a few kylobytes of resources: Decision Tree, Random Forest and XGBoost (Extreme Gradient Boosting) are now available on your microcontrollers: highly RAM-optmized implementations for super-fast classification on embedded devices.\n\n\nDecision Tree\nDecision Tree is without doubt one of the most well-known classification algorithms out there. It is so simple to understand that it was probably the first classifier you encountered in any Machine Learning course.\nI won't go into the details of how a Decision Tree classifier trains and selects the splits for the input features: here I will explain how a RAM-efficient porting of such a classifier is implemented.\nTo an introduction visit Wikipedia; for a more in-depth guide visit KDNuggets.\nSince we're willing to sacrifice program space (a.k.a flash) in favor of memory (a.k.a RAM), because RAM is the most scarce resource in the vast majority of microcontrollers, the smart way to port a Decision Tree classifier from Python to C is &quot;hard-coding&quot; the splits in code, without keeping any reference to them into variables.\nHere's what it looks like for a Decision tree that classifies the Iris dataset.\nAs you can see, we're using 0 bytes of RAM to get the classification result, since no variable is being allocated. On the other side, the program space will grow almost linearly with the number of splits.\nSince program space is often much greater than RAM on microcontrollers, this implementation exploits its abundance to be able to deploy larger models. How much large? It will depend on the flash size available: many new generations board (Arduino Nano 33 BLE Sense, ESP32, ST Nucleus...) have 1 Mb of flash, which will hold tens of thousands of splits. \nRandom Forest\nRandom Forest is just many Decision Trees joined together in a voting scheme. The core idea is that of &quot;the wisdom of the corwd&quot;, such that if many trees vote for a given class (having being trained on different subsets of the training set), that class is probably the true class.\nTowards Data Science has a more detailed guide on Random Forest and how it balances the trees with thebagging tecnique.\nAs easy as Decision Trees, Random Forest gets the exact same implementation with 0 bytes of RAM required (it actually needs as many bytes as the number of classes to store the votes, but that's really negligible): it just hard-codes all its composing trees.\nXGBoost (Extreme Gradient Boosting)\nExtreme Gradient Boosting is &quot;Gradient Boosting on steroids&quot; and has gained much attention from the Machine learning community due to its top results in many data competitions.\n\n&quot;gradient boosting&quot; refers to the process of chaining a number of trees so that each tree tries to learn from the errors of the previous\n&quot;extreme&quot; refers to many software and hardware optimizations that greatly reduce the time it takes to train the model\n\nYou can read the original paper about XGBoost here. For a discursive description head to KDNuggets, if you want some more math refer to this blog post on Medium.\nPorting to plain C\nIf you followed my earlier posts on Gaussian Naive Bayes, SEFR, Relevant Vector Machine and Support Vector Machines, you already know how to port these new classifiers.\nIf you're new, you will need a couple things:\n\ninstall the micromlgen package with \n\npip install micromlgen\n\n(optionally, if you want to use Extreme Gradient Boosting) install the xgboost package with \n\npip install xgboost\n\nuse the micromlgen.port function to generate your plain C code\n\nfrom micromlgen import port\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n\nclf = DecisionTreeClassifier\nX, y = load_iris(return_X_y=True)\nclf.fit(X, y)\nprint(port(clf))\nYou can then copy-past the C code and import it in your sketch.\nUsing in the Arduino sketch\nOnce you have the classifier code, create a new project named TreeClassifierExample and copy the classifier code into a file named DecisionTree.h (or RandomForest.h or XGBoost.h depending on the model you chose).\nThe copy the following to the main ino file.\n#include &quot;DecisionTree.h&quot;\n\nEloquent::ML::Port::DecisionTree clf;\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;Begin&quot;);\n}\n\nvoid loop() {\n    float irisSample[4] = {6.2, 2.8, 4.8, 1.8};\n\n    Serial.print(&quot;Predicted label (you should see &#039;2&#039;: &quot;);\n    Serial.println(clf.predict(irisSample));\n    delay(1000);\n}\nBechmarks\nHow do the 3 classifiers compare against each other?\nWe will evaluate a few keypoints:\n\ntraining time\naccuracy\nneeded RAM\nneeded Flash\n\nfor each classifier on a variety of datasets. I will report the results for RAM and Flash on the Arduino Nano old generation, so you should consider more the relative figures than the absolute ones.\n\n\n\nDataset\nClassifier\nTraining time (s)\nAccuracy\nRAM (bytes)\nFlash (bytes)\n\n\n\n\nGas Sensor Array Drift Dataset \nDecision Tree\n1,6\n0.781 \u00b1 0.12\n290\n5722\n\n\n13910 samples x 128 features\nRandom Forest\n3\n0.865 \u00b1 0.083\n290\n6438\n\n\n6 classes\nXGBoost\n18,8\n0.878 \u00b1 0.074\n290\n6506\n\n\nGesture Phase Segmentation Dataset\nDecision Tree\n0,1\n0.943 \u00b1 0.005\n290\n5638\n\n\n10000 samples x 19 features\nRandom Forest\n0,7\n0.970 \u00b1 0.004\n306\n6466\n\n\n5 classes\nXGBoost\n18,9\n0.969 \u00b1 0.003\n306\n6536\n\n\nDrive Diagnosis Dataset\nDecision Tree\n0,6\n0.946 \u00b1 0.005\n306\n5850\n\n\n10000 samples x 48 features\nRandom Forest\n2,6\n0.983 \u00b1 0.003\n306\n6526\n\n\n11 classes\nXGBoost\n68,9\n0.977 \u00b1 0.005\n306\n6698\n\n\n\n* all datasets are taken from the UCI Machine Learning datasets archive\nI'm collecting more data for a complete benchmark, but in the meantime you can see that both Random Forest and XGBoost are on par: if not that XGBoost takes 5 to 25 times longer to train.\nI've never used XGBoost, so I may be missing some tuning parameters, but for now Random Forest remains my favourite classifier.\nCode listings\n// example IRIS dataset classification with Decision Tree\nint predict(float *x) {\n  if (x[3] &lt;= 0.800000011920929) {\n      return 0;\n  }\n  else {\n      if (x[3] &lt;= 1.75) {\n          if (x[2] &lt;= 4.950000047683716) {\n              if (x[0] &lt;= 5.049999952316284) {\n                  return 1;\n              }\n              else {\n                  return 1;\n              }\n          }\n          else {\n              return 2;\n          }\n      }\n      else {\n          if (x[2] &lt;= 4.950000047683716) {\n              return 2;\n          }\n          else {\n              return 2;\n          }\n      }\n  }\n}\n// example IRIS dataset classification with Random Forest of 3 trees\n\nint predict(float *x) {\n  uint16_t votes[3] = { 0 };\n\n  // tree #1\n  if (x[0] &lt;= 5.450000047683716) {\n      if (x[1] &lt;= 2.950000047683716) {\n          votes[1] += 1;\n      }\n      else {\n          votes[0] += 1;\n      }\n  }\n  else {\n      if (x[0] &lt;= 6.049999952316284) {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[2] &lt;= 3.549999952316284) {\n                  votes[0] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n      else {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[3] &lt;= 1.449999988079071) {\n                  if (x[0] &lt;= 6.1499998569488525) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #2\n  if (x[0] &lt;= 5.549999952316284) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 3.950000047683716) {\n              votes[1] += 1;\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[3] &lt;= 1.699999988079071) {\n          if (x[1] &lt;= 2.649999976158142) {\n              if (x[3] &lt;= 1.25) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              if (x[2] &lt;= 4.1499998569488525) {\n                  votes[1] += 1;\n              }\n              else {\n                  if (x[0] &lt;= 6.75) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n          }\n      }\n      else {\n          if (x[0] &lt;= 6.0) {\n              votes[2] += 1;\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #3\n  if (x[3] &lt;= 1.75) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 4.8500001430511475) {\n              if (x[0] &lt;= 5.299999952316284) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[0] &lt;= 5.950000047683716) {\n          votes[2] += 1;\n      }\n      else {\n          votes[2] += 1;\n      }\n  }\n\n  // return argmax of votes\n  uint8_t classIdx = 0;\n  float maxVotes = votes[0];\n\n  for (uint8_t i = 1; i &lt; 3; i++) {\n      if (votes[i] &gt; maxVotes) {\n          classIdx = i;\n          maxVotes = votes[i];\n      }\n  }\n\n  return classIdx;\n}\nL'articolo Decision Tree, Random Forest and XGBoost on Arduino proviene da Eloquent Arduino Blog.",
            "date_published": "2020-10-19T19:31:02+02:00",
            "date_modified": "2020-10-21T13:59:20+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning",
                "Arduino Machine Learning tutorial"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1297",
            "url": "https://eloquentarduino.github.io/2020/09/principal-fft-components-as-efficient-features-extrator/",
            "title": "\u201cPrincipal\u201d FFT components as efficient features extrator",
            "content_html": "<p><a href=\"https://en.wikipedia.org/wiki/Fourier_transform\">Fourier Transform</a> is probably the most well known algorithm for feature extraction from time-dependent data (in particular speech data), where frequency holds a great deal of information. Sadly, computing the transform over the whole spectrum of the signal still requires O(NlogN) with the best implementation (<a href=\"https://en.wikipedia.org/wiki/Fast_Fourier_transform\">FFT - Fast Fourier Transform</a>); we would like to achieve faster computation on our microcontrollers.</p>\n<p>In this post I propose a partial, naive <strong>linear-time</strong> implementation of the Fourier Transform you can use to extract features from your data for Machine Learning models.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/09/FFT-spectrum.png\" alt=\"FFT spectrum example\" /></p>\n<p><span id=\"more-1297\"></span></p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#toctraining-aware-fft\">Training-aware FFT</a><li><a href=\"#tocaccuracy-comparison\">Accuracy comparison</a><li><a href=\"#tochow-to-use-principal-fft-in-python\">How to use Principal FFT in Python</a><li><a href=\"#tochow-to-use-principal-fft-in-c\">How to use Principal FFT in C</a><ol><li><a href=\"#tocbenchmarking\">Benchmarking</a></ol></div></p>\n<p><strong>DISCLAIMER</strong></p>\n<p><em>The contents of this post represent my own knowledge and are not supported by any academic work (as far as I know). It may really be the case that the findings of my work don't apply to your own projects; yet, I think this idea can turn useful in solving certain kind of problems.</em></p>\n<h2 id=\"toctraining-aware-fft\">Training-aware FFT</h2>\n<p>Fourier transform is used to describe a signal over its entire frequency range. This is useful in a number of applications, but here we're focused on the FT for the sole purpose of extracting features to be used with Machine learning models.</p>\n<p>For this reason, we don't actually need a full description of the input signal: we're only interested in extracting some kind of signature that a ML model can use to distinguish among the different classes. Noticing that in a signal spectrum most frequencies have a low magnitude (as you can see in the picture above), the idea to only keep the <em>most important</em> frequencies came to my mind as a mean to speed up the computation on resource constrained microcontrollers.</p>\n<p>I was thinking to a kind of PCA (Principal Component Analysis), but using FFT spectrum as features.</p>\n<p>Since we will have a training set with the raw signals, we would like to select the most prominent frequencies among all the samples and apply the computation only on those: even using the naive implementation of FFT, this will yield a linear-time implementation.</p>\n<h2 id=\"tocaccuracy-comparison\">Accuracy comparison</h2>\n<p>How does this <em>Principal FFT</em> compare to, let's say, PCA as a dimensionality reduction algorithm w.r.t model accuracy? Let's see the numbers!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/09/FFT-vs-PCA.png\" alt=\"FFT vs PCA accuracy comparison on various datasets\" /></p>\n<p><a href=\"/wp-content/uploads/2020/09/Principal-FFT-benchmark.ods\" title=\"Principal FFT benchmark spreadsheet\">Download the Principal FFT benchmark spreadsheet</a></p>\n<p>I couldn't find many examples of the kind of datasets I wished to test, but in the image you can see different types of data:</p>\n<ul>\n<li>human activity classification from smartphone data</li>\n<li>gesture classification by IMU data</li>\n<li>MNIST handwritten digits image data</li>\n<li>free speech audio data</li>\n</ul>\n<p>We can note a couple findings:</p>\n<ol>\n<li>Principal FFT is almost on par with PCA after a certain number of components</li>\n<li>PrincipalFFT definitely leaves PCA behind on audio data</li>\n</ol>\n<p>From even this simple analysis you should be convinced that Principal FFT can be (under certain cases) a fast, performant features extractor for your projects that involve time-dependant data.</p>\n<h2 id=\"tochow-to-use-principal-fft-in-python\">How to use Principal FFT in Python</h2>\n<p>I created a Python package to use Principal FFT, called <code>principal-fft</code>.</p>\n<pre><code class=\"language-bash\">pip install principal-fft</code></pre>\n<p>The class follows the <code>Transformer</code> API from <code>scikit-learn</code>, so it has <code>fit</code> and <code>transform</code> methods.</p>\n<pre><code class=\"language-python\">from principalfft import PrincipalFFT\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import load_digits\nfrom sklearn.ensemble import RandomForestClassifier\n\nmnist = load_digits()\nX, y = mnist.data, mnist.target\nXfft = PrincipalFFT(n_components=10).fit_transform(X)\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nXfft_train, Xfft_test, y_train, y_test = train_test_split(Xfft, y, test_size=0.3)\n\nclf = RandomForestClassifier(50, min_samples_leaf=5).fit(X_train, y_train)\nprint(&quot;Raw score&quot;, clf.score(X_test, y_test))\n\nclf = RandomForestClassifier(50, min_samples_leaf=5).fit(Xfft_train, y_train)\nprint(&quot;FFT score&quot;, clf.score(Xfft_test, y_test))</code></pre>\n<p>My results are <code>0.09</code> for raw data and <code>0.78</code> for FFT transformed: quite a big difference!</p>\n<p>As with any dimensionality reduction, <code>n_components</code> is an hyperparameter you have to tune for your specific project: from my experiments, you shouldn't go lower than <code>8</code> to achieve a reasonable accuracy.</p>\n<h2 id=\"tochow-to-use-principal-fft-in-c\">How to use Principal FFT in C</h2>\n<p>So, now that we tested our Principal FFT transformer in Python and achieved good results, how do we use it on our microcontroller? Of course with the <code>micromlgen</code> porter: it is now (<code>version 1.1.9</code>) able to port PrincipalFFT objects to plain C.</p>\n<pre><code class=\"language-bash\">pip install micromlgen==1.1.9</code></pre>\n<p>What does the C code look like?</p>\n<pre><code class=\"language-cpp\">void principalFFT(float *features, float *fft) {\n    // apply principal FFT (naive implementation for the top 10 frequencies only)\n    const int topFrequencies[] = { 0, 8, 17, 16, 1, 9, 2, 7, 15, 6 };\n\n    for (int i = 0; i &lt; 10; i++) {\n        const int k = topFrequencies[i];\n        const float harmonic = 0.09817477042468103 * k;\n        float re = 0;\n        float im = 0;\n\n        // optimized case\n        if (k == 0) {\n            for (int n = 0; n &lt; 64; n++) {\n                re += features[n];\n            }\n        }\n\n        else {\n            for (int n = 0; n &lt; 64; n++) {\n                const float harmonic_n = harmonic * n;\n                const float cos_n = cos(harmonic_n);\n                const float sin_n = sin(harmonic_n);\n                re += features[n] * cos_n;\n                im -= features[n] * sin_n;\n            }\n        }\n\n        fft[i] = sqrt(re * re + im * im);\n    }\n}</code></pre>\n<p>This is the most direct porting available.</p>\n<p>In the <em>Benchmarks</em> section, we'll see how this implementation can be speed-up with alternative implementations.</p>\n<h3 id=\"tocbenchmarking\">Benchmarking</h3>\n<p>The following table reports the benchmark on the MNIST dataset (64 features) with 10 principal FFT components vs various tecniques to decrease the computation time at the expense of memory usage.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th style=\"text-align: center;\">Flash (Kb)</th>\n<th style=\"text-align: center;\">Execution time (micros)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>None</td>\n<td style=\"text-align: center;\">137420</td>\n<td style=\"text-align: center;\">-</td>\n</tr>\n<tr>\n<td>arduinoFFT library</td>\n<td style=\"text-align: center;\">147812</td>\n<td style=\"text-align: center;\">3200</td>\n</tr>\n<tr>\n<td>principalFFT</td>\n<td style=\"text-align: center;\">151404</td>\n<td style=\"text-align: center;\">4400</td>\n</tr>\n<tr>\n<td>principalFFT w/ cos+sin LUT</td>\n<td style=\"text-align: center;\">152124</td>\n<td style=\"text-align: center;\">900</td>\n</tr>\n<tr>\n<td>principalFFT w/ cos LUT + sin sign LUT</td>\n<td style=\"text-align: center;\">150220</td>\n<td style=\"text-align: center;\">1250</td>\n</tr>\n</tbody>\n</table>\n<p>*<em>all the benchmarks were run on the Arduino 33 Nano BLE Sense</em></p>\n<p>Some thoughts:</p>\n<ol start=\"2\">\n<li><code>principalFFT w/ cos+sin LUT</code> means I pre-compute the values of <code>sin</code> and <code>cos</code> at compile time, so there's no computation on the board; of course these lookup tables will eat some memory</li>\n<li><code>principalFFT w/ cos LUT + sin sign LUT</code> means I pre-compute the <code>cos</code> values only and compute <code>sin</code> using <code>sqrt(1 - cos(x)^2)</code>; it adds some microseconds to the computation, but requires less memory</li>\n<li><code>arduinoFFT library</code> is faster than <code>principalFFT</code> in the execution time and requires less memory, even if <code>principalFFT</code> is only computing 10 frequencies: I need to investigate how it can achieve such performances</li>\n</ol>\n<p>You can activate the LUT functionality with:</p>\n<pre><code class=\"language-python\">from micromlgen import port\nfrom principalfft import PrincipalFFT\n\nfft = PrincipalFFT(n_components=10).fit(X)\n\n# cos lookup, sin computed\nport(fft, lookup_cos=True)\n\n# cos + sin lookup\nport(fft, lookup_cos=True, lookup_sin=True)</code></pre>\n<p>Here's how the C code looks like with LUT.</p>\n<pre><code class=\"language-cpp\">void principalFFT(float *features, float *fft) {\n    // apply principal FFT (naive implementation for the top N frequencies only)\n    const int topFrequencies[] = { 0, 8, 17, 16, 1, 9, 2, 7, 15, 6 };\n    const float cosLUT[10][64] = {\n        {  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0},\n        {  1.0,  0.7071,  6.1232e-17,  -0.7071,  -1.0,  -0.7071,  -1.8369e-16,  0.7071,  1.0,  0.7071,  3.0616e-16,  -0.7071,  -1.0,  -0.7071,  -4.2862e-16,  0.7071,  1.0,  0.7071,  5.5109e-16,  -0.7071,  -1.0,  -0.7071,  -2.4499e-15,  0.7071,  1.0,  0.7071,  -9.8033e-16,  -0.7071,  -1.0,  -0.7071,  -2.6948e-15,  0.7071,  1.0,  0.7071,  -7.3540e-16,  -0.7071,  -1.0,  -0.7071,  -2.9397e-15,  0.7071,  1.0,  0.7071,  -4.9047e-16,  -0.7071,  -1.0,  -0.7071,  -3.1847e-15,  0.7071,  1.0,  0.7071,  -2.4554e-16,  -0.7071,  -1.0,  -0.7071,  -3.4296e-15,  0.7071,  1.0,  0.7071,  -6.1898e-19,  -0.7071,  -1.0,  -0.7071,  -3.6745e-15,  0.7071},   ... };\n    const bool sinLUT[10][64] = {\n        {  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false},\n        {  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  false,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false},  ...};\n\n    for (int i = 0; i &lt; 10; i++) {\n        const int k = topFrequencies[i];\n        const float harmonic = 0.09817477042468103 * k;\n        float re = 0;\n        float im = 0;\n        // optimized case\n        if (k == 0) {\n            for (int n = 0; n &lt; 64; n++) {\n                re += features[n];\n            }\n        }\n\n        else {\n            for (int n = 0; n &lt; 64; n++) {\n                const float cos_n = cosLUT[i][n];\n                const float sin_n = sinLUT[i][n] ? sqrt(1 - cos_n * cos_n) : -sqrt(1 - cos_n * cos_n);\n                re += features[n] * cos_n;\n                im -= features[n] * sin_n;\n            }\n        }\n\n        fft[i] = sqrt(re * re + im * im);\n    }\n}</code></pre>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<hr />\n<p>This post required much work to be produced, so I hope I didn't forgot anything  and you found these information useful.<br />\nAs always, there's a <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PrincipalFFTExample/PrincipalFFTExample.ino\">Github repo</a> with all the code of this post.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/09/principal-fft-components-as-efficient-features-extrator/\">&#8220;Principal&#8221; FFT components as efficient features extrator</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Fourier Transform is probably the most well known algorithm for feature extraction from time-dependent data (in particular speech data), where frequency holds a great deal of information. Sadly, computing the transform over the whole spectrum of the signal still requires O(NlogN) with the best implementation (FFT - Fast Fourier Transform); we would like to achieve faster computation on our microcontrollers.\nIn this post I propose a partial, naive linear-time implementation of the Fourier Transform you can use to extract features from your data for Machine Learning models.\n\n\nTable of contentsTraining-aware FFTAccuracy comparisonHow to use Principal FFT in PythonHow to use Principal FFT in CBenchmarking\nDISCLAIMER\nThe contents of this post represent my own knowledge and are not supported by any academic work (as far as I know). It may really be the case that the findings of my work don't apply to your own projects; yet, I think this idea can turn useful in solving certain kind of problems.\nTraining-aware FFT\nFourier transform is used to describe a signal over its entire frequency range. This is useful in a number of applications, but here we're focused on the FT for the sole purpose of extracting features to be used with Machine learning models.\nFor this reason, we don't actually need a full description of the input signal: we're only interested in extracting some kind of signature that a ML model can use to distinguish among the different classes. Noticing that in a signal spectrum most frequencies have a low magnitude (as you can see in the picture above), the idea to only keep the most important frequencies came to my mind as a mean to speed up the computation on resource constrained microcontrollers.\nI was thinking to a kind of PCA (Principal Component Analysis), but using FFT spectrum as features.\nSince we will have a training set with the raw signals, we would like to select the most prominent frequencies among all the samples and apply the computation only on those: even using the naive implementation of FFT, this will yield a linear-time implementation.\nAccuracy comparison\nHow does this Principal FFT compare to, let's say, PCA as a dimensionality reduction algorithm w.r.t model accuracy? Let's see the numbers!\n\nDownload the Principal FFT benchmark spreadsheet\nI couldn't find many examples of the kind of datasets I wished to test, but in the image you can see different types of data:\n\nhuman activity classification from smartphone data\ngesture classification by IMU data\nMNIST handwritten digits image data\nfree speech audio data\n\nWe can note a couple findings:\n\nPrincipal FFT is almost on par with PCA after a certain number of components\nPrincipalFFT definitely leaves PCA behind on audio data\n\nFrom even this simple analysis you should be convinced that Principal FFT can be (under certain cases) a fast, performant features extractor for your projects that involve time-dependant data.\nHow to use Principal FFT in Python\nI created a Python package to use Principal FFT, called principal-fft.\npip install principal-fft\nThe class follows the Transformer API from scikit-learn, so it has fit and transform methods.\nfrom principalfft import PrincipalFFT\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import load_digits\nfrom sklearn.ensemble import RandomForestClassifier\n\nmnist = load_digits()\nX, y = mnist.data, mnist.target\nXfft = PrincipalFFT(n_components=10).fit_transform(X)\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nXfft_train, Xfft_test, y_train, y_test = train_test_split(Xfft, y, test_size=0.3)\n\nclf = RandomForestClassifier(50, min_samples_leaf=5).fit(X_train, y_train)\nprint(&quot;Raw score&quot;, clf.score(X_test, y_test))\n\nclf = RandomForestClassifier(50, min_samples_leaf=5).fit(Xfft_train, y_train)\nprint(&quot;FFT score&quot;, clf.score(Xfft_test, y_test))\nMy results are 0.09 for raw data and 0.78 for FFT transformed: quite a big difference!\nAs with any dimensionality reduction, n_components is an hyperparameter you have to tune for your specific project: from my experiments, you shouldn't go lower than 8 to achieve a reasonable accuracy.\nHow to use Principal FFT in C\nSo, now that we tested our Principal FFT transformer in Python and achieved good results, how do we use it on our microcontroller? Of course with the micromlgen porter: it is now (version 1.1.9) able to port PrincipalFFT objects to plain C.\npip install micromlgen==1.1.9\nWhat does the C code look like?\nvoid principalFFT(float *features, float *fft) {\n    // apply principal FFT (naive implementation for the top 10 frequencies only)\n    const int topFrequencies[] = { 0, 8, 17, 16, 1, 9, 2, 7, 15, 6 };\n\n    for (int i = 0; i &lt; 10; i++) {\n        const int k = topFrequencies[i];\n        const float harmonic = 0.09817477042468103 * k;\n        float re = 0;\n        float im = 0;\n\n        // optimized case\n        if (k == 0) {\n            for (int n = 0; n &lt; 64; n++) {\n                re += features[n];\n            }\n        }\n\n        else {\n            for (int n = 0; n &lt; 64; n++) {\n                const float harmonic_n = harmonic * n;\n                const float cos_n = cos(harmonic_n);\n                const float sin_n = sin(harmonic_n);\n                re += features[n] * cos_n;\n                im -= features[n] * sin_n;\n            }\n        }\n\n        fft[i] = sqrt(re * re + im * im);\n    }\n}\nThis is the most direct porting available.\nIn the Benchmarks section, we'll see how this implementation can be speed-up with alternative implementations.\nBenchmarking\nThe following table reports the benchmark on the MNIST dataset (64 features) with 10 principal FFT components vs various tecniques to decrease the computation time at the expense of memory usage.\n\n\n\nAlgorithm\nFlash (Kb)\nExecution time (micros)\n\n\n\n\nNone\n137420\n-\n\n\narduinoFFT library\n147812\n3200\n\n\nprincipalFFT\n151404\n4400\n\n\nprincipalFFT w/ cos+sin LUT\n152124\n900\n\n\nprincipalFFT w/ cos LUT + sin sign LUT\n150220\n1250\n\n\n\n*all the benchmarks were run on the Arduino 33 Nano BLE Sense\nSome thoughts:\n\nprincipalFFT w/ cos+sin LUT means I pre-compute the values of sin and cos at compile time, so there's no computation on the board; of course these lookup tables will eat some memory\nprincipalFFT w/ cos LUT + sin sign LUT means I pre-compute the cos values only and compute sin using sqrt(1 - cos(x)^2); it adds some microseconds to the computation, but requires less memory\narduinoFFT library is faster than principalFFT in the execution time and requires less memory, even if principalFFT is only computing 10 frequencies: I need to investigate how it can achieve such performances\n\nYou can activate the LUT functionality with:\nfrom micromlgen import port\nfrom principalfft import PrincipalFFT\n\nfft = PrincipalFFT(n_components=10).fit(X)\n\n# cos lookup, sin computed\nport(fft, lookup_cos=True)\n\n# cos + sin lookup\nport(fft, lookup_cos=True, lookup_sin=True)\nHere's how the C code looks like with LUT.\nvoid principalFFT(float *features, float *fft) {\n    // apply principal FFT (naive implementation for the top N frequencies only)\n    const int topFrequencies[] = { 0, 8, 17, 16, 1, 9, 2, 7, 15, 6 };\n    const float cosLUT[10][64] = {\n        {  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0},\n        {  1.0,  0.7071,  6.1232e-17,  -0.7071,  -1.0,  -0.7071,  -1.8369e-16,  0.7071,  1.0,  0.7071,  3.0616e-16,  -0.7071,  -1.0,  -0.7071,  -4.2862e-16,  0.7071,  1.0,  0.7071,  5.5109e-16,  -0.7071,  -1.0,  -0.7071,  -2.4499e-15,  0.7071,  1.0,  0.7071,  -9.8033e-16,  -0.7071,  -1.0,  -0.7071,  -2.6948e-15,  0.7071,  1.0,  0.7071,  -7.3540e-16,  -0.7071,  -1.0,  -0.7071,  -2.9397e-15,  0.7071,  1.0,  0.7071,  -4.9047e-16,  -0.7071,  -1.0,  -0.7071,  -3.1847e-15,  0.7071,  1.0,  0.7071,  -2.4554e-16,  -0.7071,  -1.0,  -0.7071,  -3.4296e-15,  0.7071,  1.0,  0.7071,  -6.1898e-19,  -0.7071,  -1.0,  -0.7071,  -3.6745e-15,  0.7071},   ... };\n    const bool sinLUT[10][64] = {\n        {  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false},\n        {  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false,  false,  true,  true,  true,  false,  false,  false,  false,  false,  true,  true,  true,  true,  false,  false,  false},  ...};\n\n    for (int i = 0; i &lt; 10; i++) {\n        const int k = topFrequencies[i];\n        const float harmonic = 0.09817477042468103 * k;\n        float re = 0;\n        float im = 0;\n        // optimized case\n        if (k == 0) {\n            for (int n = 0; n &lt; 64; n++) {\n                re += features[n];\n            }\n        }\n\n        else {\n            for (int n = 0; n &lt; 64; n++) {\n                const float cos_n = cosLUT[i][n];\n                const float sin_n = sinLUT[i][n] ? sqrt(1 - cos_n * cos_n) : -sqrt(1 - cos_n * cos_n);\n                re += features[n] * cos_n;\n                im -= features[n] * sin_n;\n            }\n        }\n\n        fft[i] = sqrt(re * re + im * im);\n    }\n}\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n\nThis post required much work to be produced, so I hope I didn't forgot anything  and you found these information useful.\nAs always, there's a Github repo with all the code of this post.\nL'articolo &#8220;Principal&#8221; FFT components as efficient features extrator proviene da Eloquent Arduino Blog.",
            "date_published": "2020-09-05T10:52:02+02:00",
            "date_modified": "2020-09-05T17:14:34+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1282",
            "url": "https://eloquentarduino.github.io/2020/08/better-word-classification-with-arduino-33-ble-sense-and-machine-learning/",
            "title": "Better word classification with Arduino Nano 33 BLE Sense and Machine Learning",
            "content_html": "<p>Let's revamp the post I wrote about <a href=\"/2019/12/word-classification-using-arduino/\">word classification using Machine Learning on Arduino</a>, this time using a proper microphone (the MP34DT05 mounted on the Arduino Nano 33 BLE Sense) instead of a chinese, analog one: will the results improve?</p>\n<div id=\"attachment_653\" style=\"width: 760px\" class=\"wp-caption alignnone\"><img aria-describedby=\"caption-attachment-653\" src=\"https://eloquentarduino.github.io/wp-content/uploads/2019/12/WakeWord.jpg\" width=\"750\" height=\"422\" class=\"size-full wp-image-653\" srcset=\"https://eloquentarduino.github.io/wp-content/uploads/2019/12/WakeWord.jpg 750w, https://eloquentarduino.github.io/wp-content/uploads/2019/12/WakeWord-300x169.jpg 300w\" sizes=\"(max-width: 750px) 100vw, 750px\" /><p id=\"caption-attachment-653\" class=\"wp-caption-text\">from https://www.udemy.com/course/learn-audio-processing-complete-engineers-course/</p></div>\n<p><span id=\"more-1282\"></span></p>\n<p><strong>Updated on 16 October 2020: step by step explanation of the process with ready-made sketch code</strong></p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tocwhat-youll-learn\">What you'll learn</a><li><a href=\"#tocwhat-youll-need\">What you'll need</a><li><a href=\"#tocstep-1-capture-audio-samples\">Step 1. Capture audio samples</a><ol><li><a href=\"#toctheory-pulse-density-modulation-a-k-a-pdm\">Theory: Pulse-density modulation (a.k.a. PDM)</a><li><a href=\"#tocpractice-the-code-to-capture-the-samples\">Practice: the code to capture the samples</a><li><a href=\"#tocaction-capture-the-words-examples\">Action: capture the words examples</a></li></ol><li><a href=\"#tocstep-2-train-the-machine-learning-model\">Step 2. Train the machine learning model</a><li><a href=\"#tocstep-3-deploy-to-your-microcontroller\">Step 3. Deploy to your microcontroller</a></ol></div></p>\n<h2 id=\"tocwhat-youll-learn\">What you'll learn</h2>\n<p>This tutorial will teach you how to capture audio from the Arduino Nano 33 BLE Sense microphone and classify it: at the end of this post, you will have a trained model able to detect in real-time the word you tell, among the ones that you trained it to recognize. The classification will occur directly on your Arduino board.</p>\n<p><em>This is not a general-purpose speech recognizer able to convert speech-to-text: it works only on the words <strong>you</strong> train it on</em>.</p>\n<h2 id=\"tocwhat-youll-need\">What you'll need</h2>\n<ul>\n<li>\n<p><strong>Hardware</strong></p>\n<ol>\n<li><a href=\"https://store.arduino.cc/arduino-nano-33-ble-sense\">Arduino Nano 33 BLE Sense</a></li>\n</ol>\n</li>\n<li>\n<p><strong>Software</strong></p>\n<ol>\n<li>Python</li>\n<li>Python's module <a href=\"https://scikit-learn.org/stable/\">scikit-learn</a></li>\n<li>Python's module <a href=\"https://pypi.org/project/micromlgen/\">micromlgen</a></li>\n</ol>\n</li>\n</ul>\n<p>To install the software, open your terminal and install the libraries.</p>\n<pre><code class=\"language-bash\">pip install -U scikit-learn\npip install -U micromlgen</code></pre>\n<h2 id=\"tocstep-1-capture-audio-samples\">Step 1. Capture audio samples</h2>\n<p>First of all, we need to capture a bunch of examples of the words we want to recognize.</p>\n<p>In the <a href=\"/2019/12/word-classification-using-arduino/\">original post</a>, we used an analog microphone to record the audio. It is for sure the easiest way to interact with audio on a microcontroller since you only need to <code>analogRead()</code> the selected pin to get a value from the sensor.</p>\n<p>This semplicity, however, comes at the cost of a nearly inexistent signal pre-processing from the sensor itself: most of the time, you will get junk - I don't want to be rude, but that's it.</p>\n<h3 id=\"toctheory-pulse-density-modulation-a-k-a-pdm\">Theory: Pulse-density modulation (a.k.a. PDM)</h3>\n<p>The microphone mounted on the Arduino Nano 33 BLE Sense (the <a href=\"https://content.arduino.cc/assets/Nano_BLE_Sense_mp34dt05-a.pdf\">MP34DT05</a>) is fortunately much better than this: it gives you access to a modulated signal much more suitable for our processing needs.</p>\n<p>The modulation used is pulse-density: I won't try to explain you how this works since I'm not an expert in DSP and neither it is the main scope of this article (refer to <a href=\"https://en.wikipedia.org/wiki/Pulse-density_modulation\">Wikipedia</a> for some more information).</p>\n<p>What matters to us is that we can grab an array of bytes from the microphone and extract its <a href=\"https://en.wikipedia.org/wiki/Root_mean_square\">Root Mean Square</a> (a.k.a. RMS) to be used as a feature for our Machine Learning model.</p>\n<p>I had some difficulty finding examples on how to access the microphone on the Arduino Nano 33 BLE Sense board: fortunately, there's a <a href=\"https://github.com/DaleGia/nano-33-sense-serial-example\">Github repo</a> from <em>DelaGia</em> that shows how to access all the sensors of the board.</p>\n<p>I extracted the microphone part and incapsulated it in an easy to use class, so you don't really need to dig into the implementation details if you're not interested.</p>\n<h3 id=\"tocpractice-the-code-to-capture-the-samples\">Practice: the code to capture the samples</h3>\n<p>When loaded on your Arduino Nano 33 BLE Sense, the following sketch will await for you to speak in front of the microphone: once it detects a sound, it will record  64 audio values and print them to the serial monitor.</p>\n<p>From my experience, 64 samples are sufficient to cover short words such as <em>yes</em>, <em>no</em>, <em>play</em>, <em>stop</em>: if you plan to classify longer words, you may need to increase this number.</p>\n<div class=\"watchout\">I suggest you keep the words short: longer words will probably decrease the accuracy of the model. If you want nonetheless a longer duration, at least keep the number of words as low as possible</div>\n<p>Download the <a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/arduino-33-ble-sense-capture-audio-samples.zip\" title=\"Arduino Nano 33 BLE Sense - Capture audio samples\">Arduino Nano 33 BLE Sense - Capture audio samples sketch</a>, open it the Arduino IDE and flash it to your board.</p>\n<p>Here's the main code.</p>\n<pre><code class=\"language-cpp\">#include &quot;Mic.h&quot;\n\n// tune as per your needs\n#define SAMPLES 64\n#define GAIN (1.0f/50)\n#define SOUND_THRESHOLD 2000\n\nfloat features[SAMPLES];\nMic mic;\n\nvoid setup() {\n    Serial.begin(115200);\n    PDM.onReceive(onAudio);\n    mic.begin();\n    delay(3000);\n}\n\nvoid loop() {\n    // await for a word to be pronounced\n    if (recordAudioSample()) {\n        // print features to serial monitor\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            Serial.print(features[i], 6);\n            Serial.print(i == SAMPLES - 1 ? &#039;\\n&#039; : &#039;,&#039;);\n        }\n\n        delay(1000);\n    }\n\n    delay(20);\n}\n\n/**\n * PDM callback to update mic object\n */\nvoid onAudio() {\n    mic.update();\n}\n\n/**\n * Read given number of samples from mic\n */\nbool recordAudioSample() {\n    if (mic.hasData() &amp;&amp; mic.data() &gt; SOUND_THRESHOLD) {\n\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            while (!mic.hasData())\n                delay(1);\n\n            features[i] = mic.pop() * GAIN;\n        }\n\n        return true;\n    }\n\n    return false;\n}</code></pre>\n<p>Now that we have the acquisition logic in place, it's time for you to record some samples of the words you want to classify. </p>\n<h3 id=\"tocaction-capture-the-words-examples\">Action: capture the words examples</h3>\n<p>Now you have to capture as many samples of the words you want to classify as possible.</p>\n<p>Open the serial monitor and pronounce a word near the microphone: a line of numbers will be printed on the monitor.</p>\n<p>This is the <em>description</em> of your word.</p>\n<p>You need many lines like this for an accurate prediction, so keep repeating the same word 15-30 times.</p>\n<div class=\"my-advice\">**My advice**: while recording the samples, vary both the distance of your mounth from the mic and the intensity of your voice: this will produce a more robust classification model later on.</div>\n<p>After you repeated the same words many times, copy the content of the serial monitor and save it in a CSV file named after the word, for example <code>yes.csv</code>.</p>\n<p>Then clear the serial monitor and repeat the process for each word.</p>\n<p>Keep all these files in a folder because we need them to train our classifier.</p>\n<h2 id=\"tocstep-2-train-the-machine-learning-model\">Step 2. Train the machine learning model</h2>\n<p>Now that we have the samples, it's time to train the classifier.</p>\n<p>Create a Python project in your favourite IDE or use your favourite text editor, if you don't have one.</p>\n<p>As described in <a href=\"/2019/11/how-to-train-a-classifier-in-scikit-learn/\">my post about how to train a classifier</a>, we create a Python script that reads all the files inside a folder and concatenates them in a single array you feed to the classifier model.</p>\n<p>Be sure your folder structure is like the following:</p>\n<pre><code>ArduinoWordClassification\n  |-- train_classifier.py\n  |-- data/\n  |---- yes.csv\n  |---- no.csv\n  |---- play.csv\n  |---- any other .csv file you recorded</code></pre>\n<pre><code class=\"language-python\"># file: train_classifier.py\n\nimport numpy as np\nfrom os.path import basename\nfrom glob import glob\nfrom sklearn.svm import SVC\nfrom micromlgen import port\nfrom sklearn.model_selection import train_test_split\n\ndef load_features(folder):\n    dataset = None\n    classmap = {}\n    for class_idx, filename in enumerate(glob(&#039;%s/*.csv&#039; % folder)):\n        class_name = basename(filename)[:-4]\n        classmap[class_idx] = class_name\n        samples = np.loadtxt(filename, dtype=float, delimiter=&#039;,&#039;)\n        labels = np.ones((len(samples), 1)) * class_idx\n        samples = np.hstack((samples, labels))\n        dataset = samples if dataset is None else np.vstack((dataset, samples))\n    return dataset, classmap\n\nnp.random.seed(0)\ndataset, classmap = load_features(&#039;data&#039;)\nX, y = dataset[:, :-1], dataset[:, -1]\n# this line is for testing your accuracy only: once you&#039;re satisfied with the results, set test_size to 1\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\nclf = SVC(kernel=&#039;poly&#039;, degree=2, gamma=0.1, C=100)\nclf.fit(X_train, y_train)\n\nprint(&#039;Accuracy&#039;, clf.score(X_test, y_test))\nprint(&#039;Exported classifier to plain C&#039;)\nprint(port(clf, classmap=classmap))</code></pre>\n<p>Among the classifiers I tried, SVM produced the best accuracy at 96% with 32 support vectors: it's not a super-tiny model, but it's quite small nevertheless.</p>\n<p>If you're not satisifed with SVM, you can use Decision Tree, Random Forest, Gaussian Naive Bayes, Relevant Vector Machines. See my other posts for a detailed description of each.</p>\n<p>In your console, after the accuracy score, you will have the plain C implementation of the classifier you trained. The following reports my SVM model.</p>\n<pre><code class=\"language-cpp\">// File: Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SVM {\n            public:\n                /**\n                * Predict class for features vector\n                */\n                int predict(float *x) {\n                    float kernels[35] = { 0 };\n                    float decisions[6] = { 0 };\n                    int votes[4] = { 0 };\n                    kernels[0] = compute_kernel(x,   33.0  , 41.0  , 47.0  , 54.0  , 59.0  , 61.0  , 56.0  , 51.0  , 50.0  , 51.0  , 44.0  , 32.0  , 23.0  , 15.0  , 12.0  , 8.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 5.0  , 3.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0 );\n                    kernels[1] = compute_kernel(x,   40.0  , 50.0  , 51.0  , 60.0  , 56.0  , 57.0  , 58.0  , 53.0  , 50.0  , 45.0  , 42.0  , 34.0  , 23.0  , 16.0  , 10.0  , 7.0  , 3.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 14.0  , 3.0  , 8.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 3.0 );\n                    kernels[2] = compute_kernel(x,   56.0  , 68.0  , 78.0  , 91.0  , 84.0  , 84.0  , 84.0  , 74.0  , 69.0  , 64.0  , 57.0  , 44.0  , 33.0  , 18.0  , 12.0  , 8.0  , 5.0  , 9.0  , 15.0  , 12.0  , 12.0  , 9.0  , 12.0  , 7.0  , 3.0  , 10.0  , 12.0  , 6.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 6.0  , 3.0  , 6.0  , 10.0  , 10.0  , 8.0  , 3.0  , 9.0  , 9.0  , 9.0  , 8.0  , 9.0  , 9.0  , 11.0  , 3.0  , 8.0  , 9.0  , 8.0  , 8.0  , 8.0  , 6.0  , 7.0  , 3.0  , 3.0  , 8.0  , 5.0  , 3.0  , 0.0  , 3.0  , 0.0  , 0.0 );\n\n                    // ...many other kernels computations...\n\n                    decisions[0] = 0.722587775297\n                                   + kernels[1] * 3.35855e-07\n                                   + kernels[2] * 1.64612e-07\n                                   + kernels[4] * 6.00056e-07\n                                   + kernels[5] * 3.5195e-08\n                                   + kernels[7] * -4.2079e-08\n                                   + kernels[8] * -4.2843e-08\n                                   + kernels[9] * -9.994e-09\n                                   + kernels[10] * -5.11065e-07\n                                   + kernels[11] * -5.979e-09\n                                   + kernels[12] * -4.4672e-08\n                                   + kernels[13] * -1.5606e-08\n                                   + kernels[14] * -1.2941e-08\n                                   + kernels[15] * -2.18903e-07\n                                   + kernels[17] * -2.31635e-07\n                            ;\n                    decisions[1] = -1.658344586719\n                                   + kernels[0] * 2.45018e-07\n                                   + kernels[1] * 4.30223e-07\n                                   + kernels[3] * 1.00277e-07\n                                   + kernels[4] * 2.16524e-07\n                                   + kernels[18] * -4.81187e-07\n                                   + kernels[20] * -5.10856e-07\n                            ;\n                    decisions[2] = -1.968607562265\n                                   + kernels[0] * 3.001833e-06\n                                   + kernels[3] * 4.5201e-08\n                                   + kernels[4] * 1.54493e-06\n                                   + kernels[5] * 2.81834e-07\n                                   + kernels[25] * -5.93581e-07\n                                   + kernels[26] * -2.89779e-07\n                                   + kernels[27] * -1.73958e-06\n                                   + kernels[28] * -1.09552e-07\n                                   + kernels[30] * -3.09126e-07\n                                   + kernels[31] * -1.294219e-06\n                                   + kernels[32] * -5.37961e-07\n                            ;\n                    decisions[3] = -0.720663029823\n                                   + kernels[6] * 1.4362e-08\n                                   + kernels[7] * 6.177e-09\n                                   + kernels[9] * 1.25e-08\n                                   + kernels[10] * 2.05478e-07\n                                   + kernels[12] * 2.501e-08\n                                   + kernels[15] * 4.363e-07\n                                   + kernels[16] * 9.147e-09\n                                   + kernels[18] * -1.82182e-07\n                                   + kernels[20] * -4.93707e-07\n                                   + kernels[21] * -3.3084e-08\n                            ;\n                    decisions[4] = -1.605747746589\n                                   + kernels[6] * 6.182e-09\n                                   + kernels[7] * 1.3853e-08\n                                   + kernels[8] * 2.12e-10\n                                   + kernels[9] * 1.1243e-08\n                                   + kernels[10] * 7.80681e-07\n                                   + kernels[15] * 8.347e-07\n                                   + kernels[17] * 1.64985e-07\n                                   + kernels[23] * -4.25014e-07\n                                   + kernels[25] * -1.134803e-06\n                                   + kernels[34] * -2.52038e-07\n                            ;\n                    decisions[5] = -0.934328303475\n                                   + kernels[19] * 3.3529e-07\n                                   + kernels[20] * 1.121946e-06\n                                   + kernels[21] * 3.44683e-07\n                                   + kernels[22] * -6.23056e-07\n                                   + kernels[24] * -1.4612e-07\n                                   + kernels[28] * -1.24025e-07\n                                   + kernels[29] * -4.31701e-07\n                                   + kernels[31] * -9.2146e-08\n                                   + kernels[33] * -3.8487e-07\n                            ;\n                    votes[decisions[0] &gt; 0 ? 0 : 1] += 1;\n                    votes[decisions[1] &gt; 0 ? 0 : 2] += 1;\n                    votes[decisions[2] &gt; 0 ? 0 : 3] += 1;\n                    votes[decisions[3] &gt; 0 ? 1 : 2] += 1;\n                    votes[decisions[4] &gt; 0 ? 1 : 3] += 1;\n                    votes[decisions[5] &gt; 0 ? 2 : 3] += 1;\n                    int val = votes[0];\n                    int idx = 0;\n\n                    for (int i = 1; i &lt; 4; i++) {\n                        if (votes[i] &gt; val) {\n                            val = votes[i];\n                            idx = i;\n                        }\n                    }\n\n                    return idx;\n                }\n\n                /**\n                * Convert class idx to readable name\n                */\n                const char* predictLabel(float *x) {\n                    switch (predict(x)) {\n                        case 0:\n                            return &quot;no&quot;;\n                        case 1:\n                            return &quot;stop&quot;;\n                        case 2:\n                            return &quot;play&quot;;\n                        case 3:\n                            return &quot;yes&quot;;\n                        default:\n                            return &quot;Houston we have a problem&quot;;\n                    }\n                }\n\n            protected:\n                /**\n                * Compute kernel between feature vector and support vector.\n                * Kernel type: poly\n                */\n                float compute_kernel(float *x, ...) {\n                    va_list w;\n                    va_start(w, 64);\n                    float kernel = 0.0;\n\n                    for (uint16_t i = 0; i &lt; 64; i++) {\n                        kernel += x[i] * va_arg(w, double);\n                    }\n\n                    return pow((0.1 * kernel) + 0.0, 2);\n                }\n            };\n        }\n    }\n}</code></pre>\n<h2 id=\"tocstep-3-deploy-to-your-microcontroller\">Step 3. Deploy to your microcontroller</h2>\n<p>Now we have all the pieces we need to perform word classification on our Arduino board.</p>\n<p>Download <a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/arduino-33-ble-sense-classify-audio.zip\">the Arduino Nano 33 BLE Sense - Audio classification sketch</a>, open it in the Arduino IDE and paste the plain C code you got in the console inside the <code>Classifier.h</code> file (delete all its contents before!).</p>\n<p>Fine: it's time to deploy!</p>\n<p>Hit the upload button: if everything went fine, open the serial monitor and pronounce one of the words you recorded during <code>Step 1</code>.</p>\n<p>Hopefully, you will read the word on the serial monitor.</p>\n<p>Here's a quick demo (please forgive me for the bad video quality).</p>\n<div style=\"width: 576px;\" class=\"wp-video\"><!--[if lt IE 9]><script>document.createElement('video');</script><![endif]-->\n<video class=\"wp-video-shortcode\" id=\"video-1282-1\" width=\"576\" height=\"482\" preload=\"metadata\" controls=\"controls\"><source type=\"video/mp4\" src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4?_=1\" /><a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4\">https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4</a></video></div>\n<hr />\n<p>If you liked this tutorial and it helped you successfully implement word classification on your Arduino Nano 33 BLE Sense, please share it on your social media so others can benefit too.</p>\n<p>If you have troubles or questions, don't hesitate to leave a comment: I will be happy to help you.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/08/better-word-classification-with-arduino-33-ble-sense-and-machine-learning/\">Better word classification with Arduino Nano 33 BLE Sense and Machine Learning</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Let's revamp the post I wrote about word classification using Machine Learning on Arduino, this time using a proper microphone (the MP34DT05 mounted on the Arduino Nano 33 BLE Sense) instead of a chinese, analog one: will the results improve?\nfrom https://www.udemy.com/course/learn-audio-processing-complete-engineers-course/\n\nUpdated on 16 October 2020: step by step explanation of the process with ready-made sketch code\nTable of contentsWhat you'll learnWhat you'll needStep 1. Capture audio samplesTheory: Pulse-density modulation (a.k.a. PDM)Practice: the code to capture the samplesAction: capture the words examplesStep 2. Train the machine learning modelStep 3. Deploy to your microcontroller\nWhat you'll learn\nThis tutorial will teach you how to capture audio from the Arduino Nano 33 BLE Sense microphone and classify it: at the end of this post, you will have a trained model able to detect in real-time the word you tell, among the ones that you trained it to recognize. The classification will occur directly on your Arduino board.\nThis is not a general-purpose speech recognizer able to convert speech-to-text: it works only on the words you train it on.\nWhat you'll need\n\n\nHardware\n\nArduino Nano 33 BLE Sense\n\n\n\nSoftware\n\nPython\nPython's module scikit-learn\nPython's module micromlgen\n\n\n\nTo install the software, open your terminal and install the libraries.\npip install -U scikit-learn\npip install -U micromlgen\nStep 1. Capture audio samples\nFirst of all, we need to capture a bunch of examples of the words we want to recognize.\nIn the original post, we used an analog microphone to record the audio. It is for sure the easiest way to interact with audio on a microcontroller since you only need to analogRead() the selected pin to get a value from the sensor.\nThis semplicity, however, comes at the cost of a nearly inexistent signal pre-processing from the sensor itself: most of the time, you will get junk - I don't want to be rude, but that's it.\nTheory: Pulse-density modulation (a.k.a. PDM)\nThe microphone mounted on the Arduino Nano 33 BLE Sense (the MP34DT05) is fortunately much better than this: it gives you access to a modulated signal much more suitable for our processing needs.\nThe modulation used is pulse-density: I won't try to explain you how this works since I'm not an expert in DSP and neither it is the main scope of this article (refer to Wikipedia for some more information).\nWhat matters to us is that we can grab an array of bytes from the microphone and extract its Root Mean Square (a.k.a. RMS) to be used as a feature for our Machine Learning model.\nI had some difficulty finding examples on how to access the microphone on the Arduino Nano 33 BLE Sense board: fortunately, there's a Github repo from DelaGia that shows how to access all the sensors of the board.\nI extracted the microphone part and incapsulated it in an easy to use class, so you don't really need to dig into the implementation details if you're not interested.\nPractice: the code to capture the samples\nWhen loaded on your Arduino Nano 33 BLE Sense, the following sketch will await for you to speak in front of the microphone: once it detects a sound, it will record  64 audio values and print them to the serial monitor.\nFrom my experience, 64 samples are sufficient to cover short words such as yes, no, play, stop: if you plan to classify longer words, you may need to increase this number.\nI suggest you keep the words short: longer words will probably decrease the accuracy of the model. If you want nonetheless a longer duration, at least keep the number of words as low as possible\nDownload the Arduino Nano 33 BLE Sense - Capture audio samples sketch, open it the Arduino IDE and flash it to your board.\nHere's the main code.\n#include &quot;Mic.h&quot;\n\n// tune as per your needs\n#define SAMPLES 64\n#define GAIN (1.0f/50)\n#define SOUND_THRESHOLD 2000\n\nfloat features[SAMPLES];\nMic mic;\n\nvoid setup() {\n    Serial.begin(115200);\n    PDM.onReceive(onAudio);\n    mic.begin();\n    delay(3000);\n}\n\nvoid loop() {\n    // await for a word to be pronounced\n    if (recordAudioSample()) {\n        // print features to serial monitor\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            Serial.print(features[i], 6);\n            Serial.print(i == SAMPLES - 1 ? &#039;\\n&#039; : &#039;,&#039;);\n        }\n\n        delay(1000);\n    }\n\n    delay(20);\n}\n\n/**\n * PDM callback to update mic object\n */\nvoid onAudio() {\n    mic.update();\n}\n\n/**\n * Read given number of samples from mic\n */\nbool recordAudioSample() {\n    if (mic.hasData() &amp;&amp; mic.data() &gt; SOUND_THRESHOLD) {\n\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            while (!mic.hasData())\n                delay(1);\n\n            features[i] = mic.pop() * GAIN;\n        }\n\n        return true;\n    }\n\n    return false;\n}\nNow that we have the acquisition logic in place, it's time for you to record some samples of the words you want to classify. \nAction: capture the words examples\nNow you have to capture as many samples of the words you want to classify as possible.\nOpen the serial monitor and pronounce a word near the microphone: a line of numbers will be printed on the monitor.\nThis is the description of your word.\nYou need many lines like this for an accurate prediction, so keep repeating the same word 15-30 times.\n**My advice**: while recording the samples, vary both the distance of your mounth from the mic and the intensity of your voice: this will produce a more robust classification model later on.\nAfter you repeated the same words many times, copy the content of the serial monitor and save it in a CSV file named after the word, for example yes.csv.\nThen clear the serial monitor and repeat the process for each word.\nKeep all these files in a folder because we need them to train our classifier.\nStep 2. Train the machine learning model\nNow that we have the samples, it's time to train the classifier.\nCreate a Python project in your favourite IDE or use your favourite text editor, if you don't have one.\nAs described in my post about how to train a classifier, we create a Python script that reads all the files inside a folder and concatenates them in a single array you feed to the classifier model.\nBe sure your folder structure is like the following:\nArduinoWordClassification\n  |-- train_classifier.py\n  |-- data/\n  |---- yes.csv\n  |---- no.csv\n  |---- play.csv\n  |---- any other .csv file you recorded\n# file: train_classifier.py\n\nimport numpy as np\nfrom os.path import basename\nfrom glob import glob\nfrom sklearn.svm import SVC\nfrom micromlgen import port\nfrom sklearn.model_selection import train_test_split\n\ndef load_features(folder):\n    dataset = None\n    classmap = {}\n    for class_idx, filename in enumerate(glob(&#039;%s/*.csv&#039; % folder)):\n        class_name = basename(filename)[:-4]\n        classmap[class_idx] = class_name\n        samples = np.loadtxt(filename, dtype=float, delimiter=&#039;,&#039;)\n        labels = np.ones((len(samples), 1)) * class_idx\n        samples = np.hstack((samples, labels))\n        dataset = samples if dataset is None else np.vstack((dataset, samples))\n    return dataset, classmap\n\nnp.random.seed(0)\ndataset, classmap = load_features(&#039;data&#039;)\nX, y = dataset[:, :-1], dataset[:, -1]\n# this line is for testing your accuracy only: once you&#039;re satisfied with the results, set test_size to 1\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\nclf = SVC(kernel=&#039;poly&#039;, degree=2, gamma=0.1, C=100)\nclf.fit(X_train, y_train)\n\nprint(&#039;Accuracy&#039;, clf.score(X_test, y_test))\nprint(&#039;Exported classifier to plain C&#039;)\nprint(port(clf, classmap=classmap))\nAmong the classifiers I tried, SVM produced the best accuracy at 96% with 32 support vectors: it's not a super-tiny model, but it's quite small nevertheless.\nIf you're not satisifed with SVM, you can use Decision Tree, Random Forest, Gaussian Naive Bayes, Relevant Vector Machines. See my other posts for a detailed description of each.\nIn your console, after the accuracy score, you will have the plain C implementation of the classifier you trained. The following reports my SVM model.\n// File: Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SVM {\n            public:\n                /**\n                * Predict class for features vector\n                */\n                int predict(float *x) {\n                    float kernels[35] = { 0 };\n                    float decisions[6] = { 0 };\n                    int votes[4] = { 0 };\n                    kernels[0] = compute_kernel(x,   33.0  , 41.0  , 47.0  , 54.0  , 59.0  , 61.0  , 56.0  , 51.0  , 50.0  , 51.0  , 44.0  , 32.0  , 23.0  , 15.0  , 12.0  , 8.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 5.0  , 3.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0 );\n                    kernels[1] = compute_kernel(x,   40.0  , 50.0  , 51.0  , 60.0  , 56.0  , 57.0  , 58.0  , 53.0  , 50.0  , 45.0  , 42.0  , 34.0  , 23.0  , 16.0  , 10.0  , 7.0  , 3.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 14.0  , 3.0  , 8.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 3.0 );\n                    kernels[2] = compute_kernel(x,   56.0  , 68.0  , 78.0  , 91.0  , 84.0  , 84.0  , 84.0  , 74.0  , 69.0  , 64.0  , 57.0  , 44.0  , 33.0  , 18.0  , 12.0  , 8.0  , 5.0  , 9.0  , 15.0  , 12.0  , 12.0  , 9.0  , 12.0  , 7.0  , 3.0  , 10.0  , 12.0  , 6.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 6.0  , 3.0  , 6.0  , 10.0  , 10.0  , 8.0  , 3.0  , 9.0  , 9.0  , 9.0  , 8.0  , 9.0  , 9.0  , 11.0  , 3.0  , 8.0  , 9.0  , 8.0  , 8.0  , 8.0  , 6.0  , 7.0  , 3.0  , 3.0  , 8.0  , 5.0  , 3.0  , 0.0  , 3.0  , 0.0  , 0.0 );\n\n                    // ...many other kernels computations...\n\n                    decisions[0] = 0.722587775297\n                                   + kernels[1] * 3.35855e-07\n                                   + kernels[2] * 1.64612e-07\n                                   + kernels[4] * 6.00056e-07\n                                   + kernels[5] * 3.5195e-08\n                                   + kernels[7] * -4.2079e-08\n                                   + kernels[8] * -4.2843e-08\n                                   + kernels[9] * -9.994e-09\n                                   + kernels[10] * -5.11065e-07\n                                   + kernels[11] * -5.979e-09\n                                   + kernels[12] * -4.4672e-08\n                                   + kernels[13] * -1.5606e-08\n                                   + kernels[14] * -1.2941e-08\n                                   + kernels[15] * -2.18903e-07\n                                   + kernels[17] * -2.31635e-07\n                            ;\n                    decisions[1] = -1.658344586719\n                                   + kernels[0] * 2.45018e-07\n                                   + kernels[1] * 4.30223e-07\n                                   + kernels[3] * 1.00277e-07\n                                   + kernels[4] * 2.16524e-07\n                                   + kernels[18] * -4.81187e-07\n                                   + kernels[20] * -5.10856e-07\n                            ;\n                    decisions[2] = -1.968607562265\n                                   + kernels[0] * 3.001833e-06\n                                   + kernels[3] * 4.5201e-08\n                                   + kernels[4] * 1.54493e-06\n                                   + kernels[5] * 2.81834e-07\n                                   + kernels[25] * -5.93581e-07\n                                   + kernels[26] * -2.89779e-07\n                                   + kernels[27] * -1.73958e-06\n                                   + kernels[28] * -1.09552e-07\n                                   + kernels[30] * -3.09126e-07\n                                   + kernels[31] * -1.294219e-06\n                                   + kernels[32] * -5.37961e-07\n                            ;\n                    decisions[3] = -0.720663029823\n                                   + kernels[6] * 1.4362e-08\n                                   + kernels[7] * 6.177e-09\n                                   + kernels[9] * 1.25e-08\n                                   + kernels[10] * 2.05478e-07\n                                   + kernels[12] * 2.501e-08\n                                   + kernels[15] * 4.363e-07\n                                   + kernels[16] * 9.147e-09\n                                   + kernels[18] * -1.82182e-07\n                                   + kernels[20] * -4.93707e-07\n                                   + kernels[21] * -3.3084e-08\n                            ;\n                    decisions[4] = -1.605747746589\n                                   + kernels[6] * 6.182e-09\n                                   + kernels[7] * 1.3853e-08\n                                   + kernels[8] * 2.12e-10\n                                   + kernels[9] * 1.1243e-08\n                                   + kernels[10] * 7.80681e-07\n                                   + kernels[15] * 8.347e-07\n                                   + kernels[17] * 1.64985e-07\n                                   + kernels[23] * -4.25014e-07\n                                   + kernels[25] * -1.134803e-06\n                                   + kernels[34] * -2.52038e-07\n                            ;\n                    decisions[5] = -0.934328303475\n                                   + kernels[19] * 3.3529e-07\n                                   + kernels[20] * 1.121946e-06\n                                   + kernels[21] * 3.44683e-07\n                                   + kernels[22] * -6.23056e-07\n                                   + kernels[24] * -1.4612e-07\n                                   + kernels[28] * -1.24025e-07\n                                   + kernels[29] * -4.31701e-07\n                                   + kernels[31] * -9.2146e-08\n                                   + kernels[33] * -3.8487e-07\n                            ;\n                    votes[decisions[0] &gt; 0 ? 0 : 1] += 1;\n                    votes[decisions[1] &gt; 0 ? 0 : 2] += 1;\n                    votes[decisions[2] &gt; 0 ? 0 : 3] += 1;\n                    votes[decisions[3] &gt; 0 ? 1 : 2] += 1;\n                    votes[decisions[4] &gt; 0 ? 1 : 3] += 1;\n                    votes[decisions[5] &gt; 0 ? 2 : 3] += 1;\n                    int val = votes[0];\n                    int idx = 0;\n\n                    for (int i = 1; i &lt; 4; i++) {\n                        if (votes[i] &gt; val) {\n                            val = votes[i];\n                            idx = i;\n                        }\n                    }\n\n                    return idx;\n                }\n\n                /**\n                * Convert class idx to readable name\n                */\n                const char* predictLabel(float *x) {\n                    switch (predict(x)) {\n                        case 0:\n                            return &quot;no&quot;;\n                        case 1:\n                            return &quot;stop&quot;;\n                        case 2:\n                            return &quot;play&quot;;\n                        case 3:\n                            return &quot;yes&quot;;\n                        default:\n                            return &quot;Houston we have a problem&quot;;\n                    }\n                }\n\n            protected:\n                /**\n                * Compute kernel between feature vector and support vector.\n                * Kernel type: poly\n                */\n                float compute_kernel(float *x, ...) {\n                    va_list w;\n                    va_start(w, 64);\n                    float kernel = 0.0;\n\n                    for (uint16_t i = 0; i &lt; 64; i++) {\n                        kernel += x[i] * va_arg(w, double);\n                    }\n\n                    return pow((0.1 * kernel) + 0.0, 2);\n                }\n            };\n        }\n    }\n}\nStep 3. Deploy to your microcontroller\nNow we have all the pieces we need to perform word classification on our Arduino board.\nDownload the Arduino Nano 33 BLE Sense - Audio classification sketch, open it in the Arduino IDE and paste the plain C code you got in the console inside the Classifier.h file (delete all its contents before!).\nFine: it's time to deploy!\nHit the upload button: if everything went fine, open the serial monitor and pronounce one of the words you recorded during Step 1.\nHopefully, you will read the word on the serial monitor.\nHere's a quick demo (please forgive me for the bad video quality).\n\nhttps://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4\n\nIf you liked this tutorial and it helped you successfully implement word classification on your Arduino Nano 33 BLE Sense, please share it on your social media so others can benefit too.\nIf you have troubles or questions, don't hesitate to leave a comment: I will be happy to help you.\nL'articolo Better word classification with Arduino Nano 33 BLE Sense and Machine Learning proviene da Eloquent Arduino Blog.",
            "date_published": "2020-08-24T19:04:57+02:00",
            "date_modified": "2020-10-17T17:50:13+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning"
            ],
            "attachments": [
                {
                    "url": "https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4",
                    "mime_type": "video/mp4",
                    "size_in_bytes": 5594095
                }
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1225",
            "url": "https://eloquentarduino.github.io/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/",
            "title": "EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino",
            "content_html": "<p>Are you looking for a top-performer classifiers with a minimal amount of parameters to tune? Look no further: Gaussian Naive Bayes is what you're looking for. And thanks to EloquentML you can now port it to your microcontroller.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/GaussianNB.png\" alt=\"GaussianNB\" /></p>\n<p><span id=\"more-1225\"></span></p>\n<h2>(Gaussian) Naive Bayes</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Naive_Bayes_classifier\">Naive Bayes</a> classifiers are simple models based on the probability theory that can be used for classification.</p>\n<p>They originate from the assumption of independence among the input variables. Even though this assumption doesn't hold true in the vast majority of the cases, they often perform very good at many classification tasks, so they're quite popular.</p>\n<p>Gaussian Naive Bayes stack another (mostly wrong) assumption: that the variables exhibit a Gaussian probability distribution.</p>\n<p>I (and many others like me) will never understand how it is possible that so many wrong assumptions lead to such good performances!</p>\n<p>Nevertheless, what is important to us is that <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.GaussianNB.html\">sklearn implements GaussianNB</a>, so we easily train such a classifier.<br />\nThe most interesting part is that <code>GaussianNB</code> can be tuned with just a single parameter: <code>var_smoothing</code>.</p>\n<p>Don't ask me what it does in theory: in practice you change it and your accuracy can boost. This leads to an easy tuning process that doesn't involves expensive <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html\">grid search</a>.</p>\n<pre><code class=\"language-python\">import sklearn.datasets as d\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import normalize\nfrom sklearn.naive_bayes import GaussianNB\n\ndef pick_best(X_train, X_test, y_train, y_test):\n    best = (None, 0)\n    for var_smoothing in range(-7, 1):\n        clf = GaussianNB(var_smoothing=pow(10, var_smoothing))\n        clf.fit(X_train, y_train)\n        y_pred = clf.predict(X_test)\n        accuracy = (y_pred == y_test).sum()\n        if accuracy &gt; best[1]:\n            best = (clf, accuracy)\n    print(&#039;best accuracy&#039;, best[1] / len(y_test))\n    return best[0]\n\niris = d.load_iris()\nX = normalize(iris.data)\ny = iris.target\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nclf = pick_best(X_train, X_test, y_train, y_test)</code></pre>\n<p>This simple procedure will train a bunch of classifiers with a different <code>var_smoothing</code> factor and pick the best performing one.</p>\n<h2>EloquentML integration</h2>\n<p>Once you have your trained classifier, porting it to C is as easy as always:</p>\n<pre><code class=\"language-python\">from micromlgen import port\n\nclf = pick_best()\nprint(port(clf))</code></pre>\n<p class=\"watchout\">Always remember to run </p>\n<pre><code>pip install --upgrade micromlgen</code></pre>\n</p>\n<p><code>port</code> is a magic method able to port many classifiers: it will automatically detect the proper converter for you.</p>\n<p>What does the exported code looks like?</p>\n<pre><code class=\"language-cpp\">#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class GaussianNB {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        float votes[3] = { 0.0f };\n                        float theta[4] = { 0 };\n                        float sigma[4] = { 0 };\n                        theta[0] = 0.801139789889; theta[1] = 0.54726920354; theta[2] = 0.234408773313; theta[3] = 0.039178084094;\n                        sigma[0] = 0.000366881742; sigma[1] = 0.000907992556; sigma[2] = 0.000740960787; sigma[3] = 0.000274925514;\n                        votes[0] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.748563871324; theta[1] = 0.349390892644; theta[2] = 0.536186138345; theta[3] = 0.166747384117;\n                        sigma[0] = 0.000529727082; sigma[1] = 0.000847956504; sigma[2] = 0.000690057342; sigma[3] = 0.000311828658;\n                        votes[1] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.704497203305; theta[1] = 0.318862439835; theta[2] = 0.593755956917; theta[3] = 0.217288784452;\n                        sigma[0] = 0.000363782089; sigma[1] = 0.000813846722; sigma[2] = 0.000415475678; sigma[3] = 0.000758478249;\n                        votes[2] = 0.333333333333 - gauss(x, theta, sigma);\n                        // return argmax of votes\n                        uint8_t classIdx = 0;\n                        float maxVotes = votes[0];\n\n                        for (uint8_t i = 1; i &lt; 3; i++) {\n                            if (votes[i] &gt; maxVotes) {\n                                classIdx = i;\n                                maxVotes = votes[i];\n                            }\n                        }\n\n                        return classIdx;\n                    }\n\n                protected:\n                    /**\n                    * Compute gaussian value\n                    */\n                    float gauss(float *x, float *theta, float *sigma) {\n                        float gauss = 0.0f;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            gauss += log(sigma[i]);\n                            gauss += pow(x[i] - theta[i], 2) / sigma[i];\n                        }\n\n                        return gauss;\n                    }\n                };\n            }\n        }\n    }</code></pre>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<p>As you can see, we need a couple of &quot;weight vectors&quot;:</p>\n<ul>\n<li><code>theta</code> is the mean of each feature</li>\n<li><code>sigma</code> is the standard deviation</li>\n</ul>\n<p>The computation is quite thin: just a couple of operations; the class with the highest score is then selected.</p>\n<h2>Benchmarks</h2>\n<p>Following there's a recap of a couple benchmarks I run on an Arduino Nano 33 Ble Sense.</p>\n<table>\n<thead>\n<tr>\n<th>Classifier</th>\n<th>Dataset</th>\n<th style=\"text-align: center;\">Flash</th>\n<th style=\"text-align: center;\">RAM</th>\n<th style=\"text-align: center;\">Execution time</th>\n<th style=\"text-align: center;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GaussianNB</td>\n<td>Iris (150x4)</td>\n<td style=\"text-align: center;\">82 kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">65 ms</td>\n<td style=\"text-align: center;\">97%</td>\n</tr>\n<tr>\n<td>LinearSVC</td>\n<td>Iris (150x4)</td>\n<td style=\"text-align: center;\">83 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">76 ms</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td>GaussianNB</td>\n<td>Breast cancer (80x40)</td>\n<td style=\"text-align: center;\">90 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">160 ms</td>\n<td style=\"text-align: center;\">77%</td>\n</tr>\n<tr>\n<td>LinearSVC</td>\n<td>Breast cancer (80x40)</td>\n<td style=\"text-align: center;\">112 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">378 ms</td>\n<td style=\"text-align: center;\">73%</td>\n</tr>\n<tr>\n<td>GaussianNB</td>\n<td>Wine (100x13)</td>\n<td style=\"text-align: center;\">85 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">130 ms</td>\n<td style=\"text-align: center;\">97%</td>\n</tr>\n<tr>\n<td>LinearSVC</td>\n<td>Wine (100x13)</td>\n<td style=\"text-align: center;\">89 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">125 ms</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n</tbody>\n</table>\n<p>We can see that the accuracy is on par with a linear SVM, reaching up to 97% on some datasets. Its semplicity shines with high-dimensional datasets (breast cancer) where execution time is half of the LinearSVC: I can see this pattern repeating with other real-world, medium-sized datasets.</p>\n<hr />\n<p>This is it, you can find the example project on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/GaussianNBClassificationExample/GaussianNBClassificationExample.ino\">Github</a>.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Are you looking for a top-performer classifiers with a minimal amount of parameters to tune? Look no further: Gaussian Naive Bayes is what you're looking for. And thanks to EloquentML you can now port it to your microcontroller.\n\n\n(Gaussian) Naive Bayes\nNaive Bayes classifiers are simple models based on the probability theory that can be used for classification.\nThey originate from the assumption of independence among the input variables. Even though this assumption doesn't hold true in the vast majority of the cases, they often perform very good at many classification tasks, so they're quite popular.\nGaussian Naive Bayes stack another (mostly wrong) assumption: that the variables exhibit a Gaussian probability distribution.\nI (and many others like me) will never understand how it is possible that so many wrong assumptions lead to such good performances!\nNevertheless, what is important to us is that sklearn implements GaussianNB, so we easily train such a classifier.\nThe most interesting part is that GaussianNB can be tuned with just a single parameter: var_smoothing.\nDon't ask me what it does in theory: in practice you change it and your accuracy can boost. This leads to an easy tuning process that doesn't involves expensive grid search.\nimport sklearn.datasets as d\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import normalize\nfrom sklearn.naive_bayes import GaussianNB\n\ndef pick_best(X_train, X_test, y_train, y_test):\n    best = (None, 0)\n    for var_smoothing in range(-7, 1):\n        clf = GaussianNB(var_smoothing=pow(10, var_smoothing))\n        clf.fit(X_train, y_train)\n        y_pred = clf.predict(X_test)\n        accuracy = (y_pred == y_test).sum()\n        if accuracy &gt; best[1]:\n            best = (clf, accuracy)\n    print(&#039;best accuracy&#039;, best[1] / len(y_test))\n    return best[0]\n\niris = d.load_iris()\nX = normalize(iris.data)\ny = iris.target\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nclf = pick_best(X_train, X_test, y_train, y_test)\nThis simple procedure will train a bunch of classifiers with a different var_smoothing factor and pick the best performing one.\nEloquentML integration\nOnce you have your trained classifier, porting it to C is as easy as always:\nfrom micromlgen import port\n\nclf = pick_best()\nprint(port(clf))\nAlways remember to run \npip install --upgrade micromlgen\n\nport is a magic method able to port many classifiers: it will automatically detect the proper converter for you.\nWhat does the exported code looks like?\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class GaussianNB {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        float votes[3] = { 0.0f };\n                        float theta[4] = { 0 };\n                        float sigma[4] = { 0 };\n                        theta[0] = 0.801139789889; theta[1] = 0.54726920354; theta[2] = 0.234408773313; theta[3] = 0.039178084094;\n                        sigma[0] = 0.000366881742; sigma[1] = 0.000907992556; sigma[2] = 0.000740960787; sigma[3] = 0.000274925514;\n                        votes[0] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.748563871324; theta[1] = 0.349390892644; theta[2] = 0.536186138345; theta[3] = 0.166747384117;\n                        sigma[0] = 0.000529727082; sigma[1] = 0.000847956504; sigma[2] = 0.000690057342; sigma[3] = 0.000311828658;\n                        votes[1] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.704497203305; theta[1] = 0.318862439835; theta[2] = 0.593755956917; theta[3] = 0.217288784452;\n                        sigma[0] = 0.000363782089; sigma[1] = 0.000813846722; sigma[2] = 0.000415475678; sigma[3] = 0.000758478249;\n                        votes[2] = 0.333333333333 - gauss(x, theta, sigma);\n                        // return argmax of votes\n                        uint8_t classIdx = 0;\n                        float maxVotes = votes[0];\n\n                        for (uint8_t i = 1; i &lt; 3; i++) {\n                            if (votes[i] &gt; maxVotes) {\n                                classIdx = i;\n                                maxVotes = votes[i];\n                            }\n                        }\n\n                        return classIdx;\n                    }\n\n                protected:\n                    /**\n                    * Compute gaussian value\n                    */\n                    float gauss(float *x, float *theta, float *sigma) {\n                        float gauss = 0.0f;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            gauss += log(sigma[i]);\n                            gauss += pow(x[i] - theta[i], 2) / sigma[i];\n                        }\n\n                        return gauss;\n                    }\n                };\n            }\n        }\n    }\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nAs you can see, we need a couple of &quot;weight vectors&quot;:\n\ntheta is the mean of each feature\nsigma is the standard deviation\n\nThe computation is quite thin: just a couple of operations; the class with the highest score is then selected.\nBenchmarks\nFollowing there's a recap of a couple benchmarks I run on an Arduino Nano 33 Ble Sense.\n\n\n\nClassifier\nDataset\nFlash\nRAM\nExecution time\nAccuracy\n\n\n\n\nGaussianNB\nIris (150x4)\n82 kb\n42 Kb\n65 ms\n97%\n\n\nLinearSVC\nIris (150x4)\n83 Kb\n42 Kb\n76 ms\n99%\n\n\nGaussianNB\nBreast cancer (80x40)\n90 Kb\n42 Kb\n160 ms\n77%\n\n\nLinearSVC\nBreast cancer (80x40)\n112 Kb\n42 Kb\n378 ms\n73%\n\n\nGaussianNB\nWine (100x13)\n85 Kb\n42 Kb\n130 ms\n97%\n\n\nLinearSVC\nWine (100x13)\n89 Kb\n42 Kb\n125 ms\n99%\n\n\n\nWe can see that the accuracy is on par with a linear SVM, reaching up to 97% on some datasets. Its semplicity shines with high-dimensional datasets (breast cancer) where execution time is half of the LinearSVC: I can see this pattern repeating with other real-world, medium-sized datasets.\n\nThis is it, you can find the example project on Github.\nL'articolo EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino proviene da Eloquent Arduino Blog.",
            "date_published": "2020-08-02T10:44:36+02:00",
            "date_modified": "2020-08-02T11:36:42+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1214",
            "url": "https://eloquentarduino.github.io/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/",
            "title": "SEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices",
            "content_html": "<p>A brand new binary classifier that's tiny and accurate, perfect for embedded scenarios: easily achieve 90+ % accuracy with a minimal memory footprint!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/07/Binary-classification.png\" alt=\"Binary classification - from https://towardsdatascience.com\" /></p>\n<p><span id=\"more-1214\"></span></p>\n<p>A few weeks ago I was wandering over <a href=\"https://arxiv.org/search/cs?query=microcontroller&amp;searchtype=all&amp;abstracts=show&amp;order=-announced_date_first&amp;size=50\">arxiv.org</a> looking for insipiration relative to Machine learning on microcontrollers when I found exactly what I was looking for.</p>\n<p><a href=\"https://arxiv.org/abs/2006.04620\">SEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices</a> is a paper from Hamidreza Keshavarz, Mohammad Saniee Abadeh, Reza Rawassizadeh where the authors develop a binary classifier that is:</p>\n<ul>\n<li>fast during training</li>\n<li>fast during prediction</li>\n<li>requires minimal memory</li>\n</ul>\n<p>It has been specifically designed for embedded machine learning, so no optimization is required to run in on microcontrollers: it is tiny by design. In short, it uses a combination of the averages of the features as weights plus a bias to distinguish between positive and negative class. If you read the paper you will sure understand it: it's very straightforward.</p>\n<h2>How to use</h2>\n<p>The authors both provided a <a href=\"https://github.com/sefr-classifier/sefr\">C and Python implementation</a> on Github you can read.  I ported the C version &quot;manually&quot; to my <a href=\"https://github.com/eloquentarduino/EloquentMicroML\">Eloquent ML library</a> and created a <a href=\"https://github.com/eloquentarduino/sefr\">Python package called sefr</a> copy-pasting from the original repo.</p>\n<p>Here's a Python example.</p>\n<pre><code class=\"language-python\">from sefr import SEFR\nfrom sklearn.datasets import load_iris\nfrom sklearn.preprocessing import normalize\nfrom sklearn.model_selection import train_test_split\n\nif __name__ == &#039;__main__&#039;:\n    iris = load_iris()\n    X = normalize(iris.data)\n    y = iris.target\n    X = X[y &lt; 2]\n    y = y[y &lt; 2]\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n    clf = SEFR()\n    clf.fit(X_train, y_train)\n    print(&#039;accuracy&#039;, (clf.predict(X_test) == y_test).sum() / len(y_test))</code></pre>\n<p>How good is it?</p>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th style=\"text-align: center;\">No. of features</th>\n<th style=\"text-align: center;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Iris</td>\n<td style=\"text-align: center;\">4</td>\n<td style=\"text-align: center;\">100%</td>\n</tr>\n<tr>\n<td>Breast cancer</td>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">89%</td>\n</tr>\n<tr>\n<td>Wine</td>\n<td style=\"text-align: center;\">13</td>\n<td style=\"text-align: center;\">84%</td>\n</tr>\n<tr>\n<td>Digits</td>\n<td style=\"text-align: center;\">64</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n</tbody>\n</table>\n<p>Considering that the model only needs 1 weight per feature, I think this results are impressive!</p>\n<h2>Micromlgen integration</h2>\n<p>The Python porting was done so I could integrate it easily in my <a href=\"https://github.com/eloquentarduino/micromlgen\">micromlgen</a> package.</p>\n<p>How to use it?</p>\n<pre><code class=\"language-python\">from sefr import SEFR\nfrom sklearn.datasets import load_iris\nfrom micromlgen import port\n\nif __name__ == &#039;__main__&#039;:\n    iris = load_iris()\n    X = iris.data\n    y = iris.target\n    X = X[y &lt; 2]\n    y = y[y &lt; 2]\n    clf = SEFR()\n    clf.fit(X_train, y_train)\n    print(port(clf))</code></pre>\n<p>The produced code is so compact I will report it here.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<pre><code class=\"language-cpp\">#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SEFR {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        return dot(x,   0.084993602632  , -0.106163278477  , 0.488989863684  , 0.687022900763 ) &lt;= 2.075 ? 0 : 1;\n                    }\n\n                protected:\n                    /**\n                    * Compute dot product between features vector and classifier weights\n                    */\n                    float dot(float *x, ...) {\n                        va_list w;\n                        va_start(w, 4);\n                        float kernel = 0.0;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            kernel += x[i] * va_arg(w, double);\n                        }\n\n                        return kernel;\n                    }\n                };\n            }\n        }\n    }</code></pre>\n<p>In your sketch:</p>\n<pre><code class=\"language-cpp\">#include &quot;IrisSEFR.h&quot;\n#include &quot;IrisTest.h&quot;\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\nvoid loop() {\n    Eloquent::ML::Port::SEFR clf;\n    Eloquent::ML::Test::IrisTestSet testSet;\n\n    testSet.test(clf);\n    Serial.println(testSet.dump());\n    delay(5000);\n}</code></pre>\n<p>You have to clone the <a href=\"https://github.com/eloquentarduino/EloquentMicroML/tree/master/examples/OffboardSEFRExample\">Github example</a> to compile the code.</p>\n<hr />\n<p>That's all for today, I hope you will try this classifier and find a project it fits in: I'm very impressed by the easiness of implementation yet the accuracy it can achieve on benchmark datasets.</p>\n<p>In the next weeks I'm thinking in implementing a multi-class version of this and see how it performs, so stay tuned!</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/\">SEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "A brand new binary classifier that's tiny and accurate, perfect for embedded scenarios: easily achieve 90+ % accuracy with a minimal memory footprint!\n\n\nA few weeks ago I was wandering over arxiv.org looking for insipiration relative to Machine learning on microcontrollers when I found exactly what I was looking for.\nSEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices is a paper from Hamidreza Keshavarz, Mohammad Saniee Abadeh, Reza Rawassizadeh where the authors develop a binary classifier that is:\n\nfast during training\nfast during prediction\nrequires minimal memory\n\nIt has been specifically designed for embedded machine learning, so no optimization is required to run in on microcontrollers: it is tiny by design. In short, it uses a combination of the averages of the features as weights plus a bias to distinguish between positive and negative class. If you read the paper you will sure understand it: it's very straightforward.\nHow to use\nThe authors both provided a C and Python implementation on Github you can read.  I ported the C version &quot;manually&quot; to my Eloquent ML library and created a Python package called sefr copy-pasting from the original repo.\nHere's a Python example.\nfrom sefr import SEFR\nfrom sklearn.datasets import load_iris\nfrom sklearn.preprocessing import normalize\nfrom sklearn.model_selection import train_test_split\n\nif __name__ == &#039;__main__&#039;:\n    iris = load_iris()\n    X = normalize(iris.data)\n    y = iris.target\n    X = X[y &lt; 2]\n    y = y[y &lt; 2]\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n    clf = SEFR()\n    clf.fit(X_train, y_train)\n    print(&#039;accuracy&#039;, (clf.predict(X_test) == y_test).sum() / len(y_test))\nHow good is it?\n\n\n\nDataset\nNo. of features\nAccuracy\n\n\n\n\nIris\n4\n100%\n\n\nBreast cancer\n30\n89%\n\n\nWine\n13\n84%\n\n\nDigits\n64\n99%\n\n\n\nConsidering that the model only needs 1 weight per feature, I think this results are impressive!\nMicromlgen integration\nThe Python porting was done so I could integrate it easily in my micromlgen package.\nHow to use it?\nfrom sefr import SEFR\nfrom sklearn.datasets import load_iris\nfrom micromlgen import port\n\nif __name__ == &#039;__main__&#039;:\n    iris = load_iris()\n    X = iris.data\n    y = iris.target\n    X = X[y &lt; 2]\n    y = y[y &lt; 2]\n    clf = SEFR()\n    clf.fit(X_train, y_train)\n    print(port(clf))\nThe produced code is so compact I will report it here.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SEFR {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        return dot(x,   0.084993602632  , -0.106163278477  , 0.488989863684  , 0.687022900763 ) &lt;= 2.075 ? 0 : 1;\n                    }\n\n                protected:\n                    /**\n                    * Compute dot product between features vector and classifier weights\n                    */\n                    float dot(float *x, ...) {\n                        va_list w;\n                        va_start(w, 4);\n                        float kernel = 0.0;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            kernel += x[i] * va_arg(w, double);\n                        }\n\n                        return kernel;\n                    }\n                };\n            }\n        }\n    }\nIn your sketch:\n#include &quot;IrisSEFR.h&quot;\n#include &quot;IrisTest.h&quot;\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\nvoid loop() {\n    Eloquent::ML::Port::SEFR clf;\n    Eloquent::ML::Test::IrisTestSet testSet;\n\n    testSet.test(clf);\n    Serial.println(testSet.dump());\n    delay(5000);\n}\nYou have to clone the Github example to compile the code.\n\nThat's all for today, I hope you will try this classifier and find a project it fits in: I'm very impressed by the easiness of implementation yet the accuracy it can achieve on benchmark datasets.\nIn the next weeks I'm thinking in implementing a multi-class version of this and see how it performs, so stay tuned!\nL'articolo SEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices proviene da Eloquent Arduino Blog.",
            "date_published": "2020-07-10T17:09:58+02:00",
            "date_modified": "2020-07-12T17:04:14+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1174",
            "url": "https://eloquentarduino.github.io/2020/06/arduino-dimensionality-reduction-pca-for-machine-learning-projects/",
            "title": "Arduino dimensionality reduction (PCA) for Machine Learning projects",
            "content_html": "<p>When working with <strong>Machine Learning projects</strong> on microcontrollers and embedded devices the dimension of features can become a limiting factor due to the lack of RAM: <strong>dimensionality reduction</strong> (eg. PCA) will help you shrink your models and even achieve higher prediction accuracy.</p>\n<p><a href=\"https://setosa.io/ev/principal-component-analysis\"><img src=\"https://setosa.io/ev/principal-component-analysis/fb-thumb.png\" alt=\"PCA application example\" /></a></p>\n<p><span id=\"more-1174\"></span></p>\n<h2>Why dimensionality reduction on Arduino microcontrollers?</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Dimensionality_reduction\">Dimensionality reduction</a> is a tecnique you see often in Machine Learning projects. By stripping away &quot;unimportant&quot; or redundant information, it generally helps speeding up the training process and achieving higher classification performances.</p>\n<p>Since we now know we can run Machine Learning on Arduino boards and embedded microcontrollers, it can become a key tool at our disposal to squeeze out the most out of our boards.</p>\n<p>In the specific case of resource-constrained devices as old Arduino boards (the UNO for example, with only 2 kb of RAM), it can become a decisive turn in unlocking even more application scenarios where the high dimensionality of the input features would not allow any model to fit.</p>\n<p>Let's take the <a href=\"/2019/12/how-to-do-gesture-identification-on-arduino/\">Gesture classification project</a> as an example: among the different classifiers we trained, only one fitted on the Arduino UNO, since most of them required too much flash memory due to the high dimension of features (90) and support vectors (25 to 61).</p>\n<p>In this post I will resume that example and see if dimensionality reduction can help reduce this gap.</p>\n<p>If you are working on a project with many features, let me know in the comments so I can create a detailed list of real world examples.</p>\n<h2>How to export PCA (Principal Component Analysis) to plain C</h2>\n<p>Among the many algorithms available for dimensionality reduction, I decided to start with <a href=\"https://en.wikipedia.org/wiki/Principal_component_analysis\">PCA (Principal Component Analysis)</a> because it's one of the most widespread. In the next weeks I will probably work on porting other alternatives.</p>\n<p>If you never used my Python package <a href=\"https://github.com/eloquentarduino/micromlgen\">micromlgen</a> I first invite you to read <a href=\"/2019/11/you-can-run-machine-learning-on-arduino/\">the introduction post</a> to get familiar with it.</p>\n<p>Always remember to install the latest version, since I publish frequent updates.</p>\n<pre><code class=\"language-bash\">pip install --upgrade micromlgen</code></pre>\n<p>Now it is pretty straight-forward to convert a sklearn PCA transformer to plain C: you use the magic method <code>port</code>. In addition to converting SVM/RVM classifiers, it is now able to export PCA too.</p>\n<pre><code class=\"language-python\">from sklearn.decomposition import PCA\nfrom sklearn.datasets import load_iris\nfrom micromlgen import port\n\nif __name__ == &#039;__main__&#039;:\n    X = load_iris().data\n    pca = PCA(n_components=2, whiten=False).fit(X)\n\n    print(port(pca))</code></pre>\n<h2>How to deploy PCA to Arduino</h2>\n<p>To use the exported code, we first have to include it in our sketch. Save the contents to a file (I named it <code>pca.h</code>) in the same folder of your <code>.ino</code> project and include it.</p>\n<pre><code class=\"language-cpp\">#include &quot;pca.h&quot;\n\n// this was trained on the IRIS dataset, with 2 principal components\nEloquent::ML::Port::PCA pca;</code></pre>\n<p>The <code>pca</code> object is now able to take an array of size N as input and return an array of size K as output, with K &lt; N usually.</p>\n<pre><code class=\"language-cpp\">void setup() {\n    float x_input[4] = {5.1, 3.5, 1.4, 0.2};\n    float x_output[2];\n\n    pca.transform(x_input, x_output);\n}</code></pre>\n<p>That's it: now you can run your classifier on <code>x_output</code>.</p>\n<pre><code class=\"language-cpp\">#include &quot;pca.h&quot;\n#include &quot;svm.h&quot;\n\nEloquent::ML::Port::PCA pca;\nEloquent::ML::Port::SVM clf;\n\nvoid setup() {\n    float x_input[4] = {5.1, 3.5, 1.4, 0.2};\n    float x_output[2];\n    int y_pred;\n\n    pca.transform(x_input, x_output);\n\n    y_pred = clf.predict(x_output);\n}</code></pre>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2>A real world example</h2>\n<p>As I anticipated, let's take a look at how PCA dimensionality reduction can help in fitting classifiers that would otherwise be too large to fit on our microcontrollers.</p>\n<p>This is the exact table from the <a href=\"/2019/12/how-to-do-gesture-identification-on-arduino/\">Gesture classification project</a>.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">Kernel</th>\n<th style=\"text-align: center;\">C</th>\n<th style=\"text-align: center;\">Gamma</th>\n<th style=\"text-align: center;\">Degree</th>\n<th style=\"text-align: center;\">Vectors</th>\n<th style=\"text-align: center;\">Flash size</th>\n<th style=\"text-align: center;\">RAM (b)</th>\n<th style=\"text-align: center;\">Avg accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">RBF</td>\n<td style=\"text-align: center;\">10</td>\n<td style=\"text-align: center;\">0.001</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">37</td>\n<td style=\"text-align: center;\">53 Kb</td>\n<td style=\"text-align: center;\">1228</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Poly</strong></td>\n<td style=\"text-align: center;\"><strong>100</strong></td>\n<td style=\"text-align: center;\"><strong>0.001</strong></td>\n<td style=\"text-align: center;\"><strong>2</strong></td>\n<td style=\"text-align: center;\"><strong>12</strong></td>\n<td style=\"text-align: center;\"><strong>25 Kb</strong></td>\n<td style=\"text-align: center;\"><strong>1228</strong></td>\n<td style=\"text-align: center;\"><strong>99%</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Poly</td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: center;\">0.001</td>\n<td style=\"text-align: center;\">3</td>\n<td style=\"text-align: center;\">25</td>\n<td style=\"text-align: center;\">40 Kb</td>\n<td style=\"text-align: center;\">1228</td>\n<td style=\"text-align: center;\">97%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Linear</td>\n<td style=\"text-align: center;\">50</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: center;\">55 Kb</td>\n<td style=\"text-align: center;\">1228</td>\n<td style=\"text-align: center;\">95%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">RBF</td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: center;\">0.01</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">61</td>\n<td style=\"text-align: center;\">80 Kb</td>\n<td style=\"text-align: center;\">1228</td>\n<td style=\"text-align: center;\">95%</td>\n</tr>\n</tbody>\n</table>\n<p>The dataset has 90 features (30 samples x 3 axes) and achieves 99% accuracy. </p>\n<p>Let's pick the <code>poly</code> kernel with degree <code>2</code> and see how much we can decrease the number of components while still achieving a good accuracy.</p>\n<table>\n<thead>\n<tr>\n<th>PCA components</th>\n<th style=\"text-align: center;\">Accuracy</th>\n<th style=\"text-align: center;\">Support vectors</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>90</td>\n<td style=\"text-align: center;\">99%</td>\n<td style=\"text-align: center;\">31</td>\n</tr>\n<tr>\n<td>50</td>\n<td style=\"text-align: center;\">99%</td>\n<td style=\"text-align: center;\">31</td>\n</tr>\n<tr>\n<td>40</td>\n<td style=\"text-align: center;\">99%</td>\n<td style=\"text-align: center;\">31</td>\n</tr>\n<tr>\n<td>30</td>\n<td style=\"text-align: center;\">90%</td>\n<td style=\"text-align: center;\">30</td>\n</tr>\n<tr>\n<td>20</td>\n<td style=\"text-align: center;\">90%</td>\n<td style=\"text-align: center;\">28</td>\n</tr>\n<tr>\n<td>15</td>\n<td style=\"text-align: center;\">90%</td>\n<td style=\"text-align: center;\">24</td>\n</tr>\n<tr>\n<td><strong>10</strong></td>\n<td style=\"text-align: center;\"><strong>99%</strong></td>\n<td style=\"text-align: center;\"><strong>18</strong></td>\n</tr>\n<tr>\n<td>5</td>\n<td style=\"text-align: center;\">76%</td>\n<td style=\"text-align: center;\">28</td>\n</tr>\n</tbody>\n</table>\n<p>We clearly see a couple of things:</p>\n<ol>\n<li>we still achieve 99% accuracy even with only 40 out of 90 principal components</li>\n<li>we get a satisfactory 90% accuracy even <strong>with only 15 components</strong></li>\n<li>(this is a bit unexpected) it looks like there's a sweet spot at 10 components where the accuracy skyrockets to 99% again. <em>This could be just a contingency of this particular dataset, don't expect to replicate this results on your own dataset</em></li>\n</ol>\n<p>What do these numbers mean to you? It means your board has to do many less computations to give you a prediction and will probably be able to host a more complex model.</p>\n<p>Let's check out the figures with <code>n_components = 10</code> compared with the ones without PCA.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">Kernel</th>\n<th style=\"text-align: center;\">PCA support vectors</th>\n<th style=\"text-align: center;\">PCA flash size</th>\n<th style=\"text-align: center;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">RBF C=10</td>\n<td style=\"text-align: center;\">46 (+24%)</td>\n<td style=\"text-align: center;\">32 Kb (-40%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">RBF C=100</td>\n<td style=\"text-align: center;\">28 (-54%)</td>\n<td style=\"text-align: center;\">32 Kb (-60%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Poly 2</strong></td>\n<td style=\"text-align: center;\">13 (-48%)</td>\n<td style=\"text-align: center;\">28 Kb (+12%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Poly 3</strong></td>\n<td style=\"text-align: center;\">24 (-4%)</td>\n<td style=\"text-align: center;\">32 Kb (-20%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Linear</strong></td>\n<td style=\"text-align: center;\">18 (-64%)</td>\n<td style=\"text-align: center;\">29 Kb (-47%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n</tbody>\n</table>\n<p>A couple notes:</p>\n<ol>\n<li>accuracy increased (on stayed the same) for all kernels</li>\n<li>with one exception, flash size decreased in the range 20 - 50%</li>\n<li>now we can fit 3 classifiers on our Arduino UNO instead of only one</li>\n</ol>\n<p>I will probably spend some more time investingating the usefulness of PCA for Arduino Machine Learning projects, but for now that's it: it's a good starting point in my opinion.</p>\n<hr />\n<p>There's a little example sketch on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PCAExample/PCAExample.ino\">Github</a> that applies PCA to the IRIS dataset.</p>\n<p>Tell me what you think may be a clever application of dimensionality reduction in the world of microcontrollers and see if we can build something great together.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/06/arduino-dimensionality-reduction-pca-for-machine-learning-projects/\">Arduino dimensionality reduction (PCA) for Machine Learning projects</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "When working with Machine Learning projects on microcontrollers and embedded devices the dimension of features can become a limiting factor due to the lack of RAM: dimensionality reduction (eg. PCA) will help you shrink your models and even achieve higher prediction accuracy.\n\n\nWhy dimensionality reduction on Arduino microcontrollers?\nDimensionality reduction is a tecnique you see often in Machine Learning projects. By stripping away &quot;unimportant&quot; or redundant information, it generally helps speeding up the training process and achieving higher classification performances.\nSince we now know we can run Machine Learning on Arduino boards and embedded microcontrollers, it can become a key tool at our disposal to squeeze out the most out of our boards.\nIn the specific case of resource-constrained devices as old Arduino boards (the UNO for example, with only 2 kb of RAM), it can become a decisive turn in unlocking even more application scenarios where the high dimensionality of the input features would not allow any model to fit.\nLet's take the Gesture classification project as an example: among the different classifiers we trained, only one fitted on the Arduino UNO, since most of them required too much flash memory due to the high dimension of features (90) and support vectors (25 to 61).\nIn this post I will resume that example and see if dimensionality reduction can help reduce this gap.\nIf you are working on a project with many features, let me know in the comments so I can create a detailed list of real world examples.\nHow to export PCA (Principal Component Analysis) to plain C\nAmong the many algorithms available for dimensionality reduction, I decided to start with PCA (Principal Component Analysis) because it's one of the most widespread. In the next weeks I will probably work on porting other alternatives.\nIf you never used my Python package micromlgen I first invite you to read the introduction post to get familiar with it.\nAlways remember to install the latest version, since I publish frequent updates.\npip install --upgrade micromlgen\nNow it is pretty straight-forward to convert a sklearn PCA transformer to plain C: you use the magic method port. In addition to converting SVM/RVM classifiers, it is now able to export PCA too.\nfrom sklearn.decomposition import PCA\nfrom sklearn.datasets import load_iris\nfrom micromlgen import port\n\nif __name__ == &#039;__main__&#039;:\n    X = load_iris().data\n    pca = PCA(n_components=2, whiten=False).fit(X)\n\n    print(port(pca))\nHow to deploy PCA to Arduino\nTo use the exported code, we first have to include it in our sketch. Save the contents to a file (I named it pca.h) in the same folder of your .ino project and include it.\n#include &quot;pca.h&quot;\n\n// this was trained on the IRIS dataset, with 2 principal components\nEloquent::ML::Port::PCA pca;\nThe pca object is now able to take an array of size N as input and return an array of size K as output, with K &lt; N usually.\nvoid setup() {\n    float x_input[4] = {5.1, 3.5, 1.4, 0.2};\n    float x_output[2];\n\n    pca.transform(x_input, x_output);\n}\nThat's it: now you can run your classifier on x_output.\n#include &quot;pca.h&quot;\n#include &quot;svm.h&quot;\n\nEloquent::ML::Port::PCA pca;\nEloquent::ML::Port::SVM clf;\n\nvoid setup() {\n    float x_input[4] = {5.1, 3.5, 1.4, 0.2};\n    float x_output[2];\n    int y_pred;\n\n    pca.transform(x_input, x_output);\n\n    y_pred = clf.predict(x_output);\n}\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nA real world example\nAs I anticipated, let's take a look at how PCA dimensionality reduction can help in fitting classifiers that would otherwise be too large to fit on our microcontrollers.\nThis is the exact table from the Gesture classification project.\n\n\n\nKernel\nC\nGamma\nDegree\nVectors\nFlash size\nRAM (b)\nAvg accuracy\n\n\n\n\nRBF\n10\n0.001\n-\n37\n53 Kb\n1228\n99%\n\n\nPoly\n100\n0.001\n2\n12\n25 Kb\n1228\n99%\n\n\nPoly\n100\n0.001\n3\n25\n40 Kb\n1228\n97%\n\n\nLinear\n50\n-\n1\n40\n55 Kb\n1228\n95%\n\n\nRBF\n100\n0.01\n-\n61\n80 Kb\n1228\n95%\n\n\n\nThe dataset has 90 features (30 samples x 3 axes) and achieves 99% accuracy. \nLet's pick the poly kernel with degree 2 and see how much we can decrease the number of components while still achieving a good accuracy.\n\n\n\nPCA components\nAccuracy\nSupport vectors\n\n\n\n\n90\n99%\n31\n\n\n50\n99%\n31\n\n\n40\n99%\n31\n\n\n30\n90%\n30\n\n\n20\n90%\n28\n\n\n15\n90%\n24\n\n\n10\n99%\n18\n\n\n5\n76%\n28\n\n\n\nWe clearly see a couple of things:\n\nwe still achieve 99% accuracy even with only 40 out of 90 principal components\nwe get a satisfactory 90% accuracy even with only 15 components\n(this is a bit unexpected) it looks like there's a sweet spot at 10 components where the accuracy skyrockets to 99% again. This could be just a contingency of this particular dataset, don't expect to replicate this results on your own dataset\n\nWhat do these numbers mean to you? It means your board has to do many less computations to give you a prediction and will probably be able to host a more complex model.\nLet's check out the figures with n_components = 10 compared with the ones without PCA.\n\n\n\nKernel\nPCA support vectors\nPCA flash size\nAccuracy\n\n\n\n\nRBF C=10\n46 (+24%)\n32 Kb (-40%)\n99%\n\n\nRBF C=100\n28 (-54%)\n32 Kb (-60%)\n99%\n\n\nPoly 2\n13 (-48%)\n28 Kb (+12%)\n99%\n\n\nPoly 3\n24 (-4%)\n32 Kb (-20%)\n99%\n\n\nLinear\n18 (-64%)\n29 Kb (-47%)\n99%\n\n\n\nA couple notes:\n\naccuracy increased (on stayed the same) for all kernels\nwith one exception, flash size decreased in the range 20 - 50%\nnow we can fit 3 classifiers on our Arduino UNO instead of only one\n\nI will probably spend some more time investingating the usefulness of PCA for Arduino Machine Learning projects, but for now that's it: it's a good starting point in my opinion.\n\nThere's a little example sketch on Github that applies PCA to the IRIS dataset.\nTell me what you think may be a clever application of dimensionality reduction in the world of microcontrollers and see if we can build something great together.\nL'articolo Arduino dimensionality reduction (PCA) for Machine Learning projects proviene da Eloquent Arduino Blog.",
            "date_published": "2020-06-07T09:24:20+02:00",
            "date_modified": "2020-06-07T11:26:25+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "pca",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1079",
            "url": "https://eloquentarduino.github.io/2020/04/incremental-multiclass-classification-on-microcontrollers-one-vs-one/",
            "title": "Incremental multiclass classification on microcontrollers: One vs One",
            "content_html": "<p>In earlier posts I showed you can run incremental binary classification on your microcontroller with Stochastic Gradient Descent or Passive-Aggressive classifier. Now it is time to upgrade your toolbelt with a new item: One-vs-One multiclass classifier.</p>\n<p><span id=\"more-1079\"></span></p>\n<h2>One vs One</h2>\n<p>Many classifiers are, by nature, binary: they can only distinguish the positive class from the negative one. Many of real-world problems, however, are multiclass: you have 3 or more possible outcomes to distinguish from.</p>\n<p>There are a couple of ways to achieve this:</p>\n<ol>\n<li><strong>One vs All</strong>: if your classifier is able to output a confidence score of its prediction, for N classes you train N classifiers, each able to recognize a single class. During inference, you pick the &quot;most confident&quot; one.</li>\n<li><strong>One vs One</strong>: for N classes, you train N * (N-1) / 2 classifiers, one for each couple of classes. During inference, each classifier makes a prediction and you pick the class with the highest number of votes.</li>\n</ol>\n<p>Since SGD and Passive-Aggressive don't output a confidence score, I implemented the One vs One algorithm to tackle the multiclass classification problem on microcontrollers.</p>\n<p>Actually, One vs One is not a new type of classifier: it is really a &quot;coordinator&quot; class that sorts which samples go to which classifier. You can still choose your own classifier type to use.</p>\n<p>As SGD and Passive-Aggressive, OneVsOne implements the classifier interface, so you will use the well known <code>fitOne</code> and <code>predict</code> methods.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2>Example code</h2>\n<pre><code class=\"language-cpp\">// Esp32 has some problems with min/max\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n// you will actually need only one of SGD or PassiveAggressive\n#include &quot;EloquentSGD.h&quot;\n#include &quot;EloquentPassiveAggressive.h&quot;\n#include &quot;EloquentOneVsOne.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n// this file defines NUM_FEATURES, NUM_CLASSES, TRAIN_SAMPLES and TEST_SAMPLES\n#include &quot;dataset.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n}\n\nvoid loop() {\n  AccuracyScorer scorer;\n  // OneVsOne needs the actual classifier class, the number of features and the number of classes\n  OneVsOne&lt;SGD&lt;FEATURES_DIM&gt;, FEATURES_DIM, NUM_CLASSES&gt; clf;\n\n  // clf.set() propagates the configuration to the actual classifiers\n  // if a parameter does not exists on the classifier, it does nothing\n  // in this example, alpha and momentum refer to SGD, C to Passive-Aggressive\n  clf.set(&quot;alpha&quot;, 1);\n  clf.set(&quot;momentum&quot;, 0.7);\n  clf.set(&quot;C&quot;, 0.1);\n\n  // fit\n  // I noticed that repeating the training a few times over the same dataset increases performance  to a certain extent: if you re-train it too much, performance will decay\n  for (unsigned int i = 0; i &lt; TRAIN_SAMPLES * 5; i++) {\n      clf.fitOne(X_train[i % TRAIN_SAMPLES], y_train[i % TRAIN_SAMPLES]);\n  }\n\n  // predict\n  for (int i = 0; i &lt; TEST_SAMPLES; i++) {\n      int y_true = y_test[i];\n      int y_pred = clf.predict(X_test[i]);\n\n      Serial.print(&quot;Predicted &quot;);\n      Serial.print(y_pred);\n      Serial.print(&quot; vs &quot;);\n      Serial.println(y_true);\n      scorer.scoreOne(y_true, y_pred);\n  }\n\n  Serial.print(&quot;Accuracy = &quot;);\n  Serial.print(scorer.accuracy() * 100);\n  Serial.print(&quot; out of &quot;);\n  Serial.print(scorer.support());\n  Serial.println(&quot; samples&quot;);\n  delay(30000);\n}</code></pre>\n<p>If you refer to the previous posts on <a href=\"/2020/04/stochastic-gradient-descent-on-your-microcontroller/\">SGD</a> and <a href=\"/2020/04/passive-aggressive-classifier-for-embedded-devices/\">Passive-Aggressive</a>, you'll notice that you would be able to replace one with the other and your code will change by <strong>1 single line only</strong>. This let's you experiment to find the best configuration for your project without hassle.</p>\n<h2>Accuracy</h2>\n<p>Well, accuracy vary.</p>\n<p>In my tests, I couldn't get predictable accuracy on all datasets. I couldn't even get acceptable accuracy on the Iris dataset (60% max). But I got 90% accuracy on the Digits dataset from scikit-learn with 6 classes.</p>\n<p>You have to experiment. Try Passive-Aggressive with many <code>C</code> values. If it doesn't work, try SGD with varying <code>momentum</code> and <code>alpha</code>. Try to repeat the training over the dataset 5, 10 times.</p>\n<p>In a next post I'll report my benchmarks so you can see what works for you and what not.<br />\nThis is an emerging field for me, so I will need time to master it.</p>\n<hr />\n<p>As always, you can find the examle on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/OvOExample/OvOExample.ino\">Github</a> with a the dataset to experiment with.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/04/incremental-multiclass-classification-on-microcontrollers-one-vs-one/\">Incremental multiclass classification on microcontrollers: One vs One</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "In earlier posts I showed you can run incremental binary classification on your microcontroller with Stochastic Gradient Descent or Passive-Aggressive classifier. Now it is time to upgrade your toolbelt with a new item: One-vs-One multiclass classifier.\n\nOne vs One\nMany classifiers are, by nature, binary: they can only distinguish the positive class from the negative one. Many of real-world problems, however, are multiclass: you have 3 or more possible outcomes to distinguish from.\nThere are a couple of ways to achieve this:\n\nOne vs All: if your classifier is able to output a confidence score of its prediction, for N classes you train N classifiers, each able to recognize a single class. During inference, you pick the &quot;most confident&quot; one.\nOne vs One: for N classes, you train N * (N-1) / 2 classifiers, one for each couple of classes. During inference, each classifier makes a prediction and you pick the class with the highest number of votes.\n\nSince SGD and Passive-Aggressive don't output a confidence score, I implemented the One vs One algorithm to tackle the multiclass classification problem on microcontrollers.\nActually, One vs One is not a new type of classifier: it is really a &quot;coordinator&quot; class that sorts which samples go to which classifier. You can still choose your own classifier type to use.\nAs SGD and Passive-Aggressive, OneVsOne implements the classifier interface, so you will use the well known fitOne and predict methods.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nExample code\n// Esp32 has some problems with min/max\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n// you will actually need only one of SGD or PassiveAggressive\n#include &quot;EloquentSGD.h&quot;\n#include &quot;EloquentPassiveAggressive.h&quot;\n#include &quot;EloquentOneVsOne.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n// this file defines NUM_FEATURES, NUM_CLASSES, TRAIN_SAMPLES and TEST_SAMPLES\n#include &quot;dataset.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n}\n\nvoid loop() {\n  AccuracyScorer scorer;\n  // OneVsOne needs the actual classifier class, the number of features and the number of classes\n  OneVsOne&lt;SGD&lt;FEATURES_DIM&gt;, FEATURES_DIM, NUM_CLASSES&gt; clf;\n\n  // clf.set() propagates the configuration to the actual classifiers\n  // if a parameter does not exists on the classifier, it does nothing\n  // in this example, alpha and momentum refer to SGD, C to Passive-Aggressive\n  clf.set(&quot;alpha&quot;, 1);\n  clf.set(&quot;momentum&quot;, 0.7);\n  clf.set(&quot;C&quot;, 0.1);\n\n  // fit\n  // I noticed that repeating the training a few times over the same dataset increases performance  to a certain extent: if you re-train it too much, performance will decay\n  for (unsigned int i = 0; i &lt; TRAIN_SAMPLES * 5; i++) {\n      clf.fitOne(X_train[i % TRAIN_SAMPLES], y_train[i % TRAIN_SAMPLES]);\n  }\n\n  // predict\n  for (int i = 0; i &lt; TEST_SAMPLES; i++) {\n      int y_true = y_test[i];\n      int y_pred = clf.predict(X_test[i]);\n\n      Serial.print(&quot;Predicted &quot;);\n      Serial.print(y_pred);\n      Serial.print(&quot; vs &quot;);\n      Serial.println(y_true);\n      scorer.scoreOne(y_true, y_pred);\n  }\n\n  Serial.print(&quot;Accuracy = &quot;);\n  Serial.print(scorer.accuracy() * 100);\n  Serial.print(&quot; out of &quot;);\n  Serial.print(scorer.support());\n  Serial.println(&quot; samples&quot;);\n  delay(30000);\n}\nIf you refer to the previous posts on SGD and Passive-Aggressive, you'll notice that you would be able to replace one with the other and your code will change by 1 single line only. This let's you experiment to find the best configuration for your project without hassle.\nAccuracy\nWell, accuracy vary.\nIn my tests, I couldn't get predictable accuracy on all datasets. I couldn't even get acceptable accuracy on the Iris dataset (60% max). But I got 90% accuracy on the Digits dataset from scikit-learn with 6 classes.\nYou have to experiment. Try Passive-Aggressive with many C values. If it doesn't work, try SGD with varying momentum and alpha. Try to repeat the training over the dataset 5, 10 times.\nIn a next post I'll report my benchmarks so you can see what works for you and what not.\nThis is an emerging field for me, so I will need time to master it.\n\nAs always, you can find the examle on Github with a the dataset to experiment with.\nL'articolo Incremental multiclass classification on microcontrollers: One vs One proviene da Eloquent Arduino Blog.",
            "date_published": "2020-04-26T10:01:14+02:00",
            "date_modified": "2020-04-26T11:52:29+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "incremental-learning",
                "microml",
                "ml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1062",
            "url": "https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/",
            "title": "Stochastic Gradient Descent on your microcontroller",
            "content_html": "<p>Stochastic gradient descent is a well know algorithm to train classifiers in an incremental fashion: that is, as training samples become available. This saves you critical memory on tiny devices while still achieving <strong>top performance</strong>! Now you can use it on your microcontroller with ease.</p>\n<p><span id=\"more-1062\"></span></p>\n<h2>A brief recap on Stochastic Gradient Descent</h2>\n<p>If you ever worked with Machine learning, you surely know about <a href=\"https://en.wikipedia.org/wiki/Gradient_descent\">Gradient descent</a>: it is an iterative algorithm to optimize a loss function. </p>\n<p>It is much general-purpose, in the sense that it is not bound to a particular application, but it has been heavily used in Neural networks in the recent years.</p>\n<p>Yet, it can be used as a classifier on its own if you set its loss function as the classification error.</p>\n<p><img src=\"https://mccormickml.com/assets/GradientDescent/GradientDescentOfMSETable.png\" alt=\"Update rule of Gradient descent\" /></p>\n<p>This is the core update rule of Gradient descent: quite simple.</p>\n<p>As you see, there's a summation in the formula: this means we need to cycle through the entire training set to compute the update to the weights.</p>\n<p>In case of large datasets, this can be slow or not possible at all.</p>\n<p>And requires a lot of memory.</p>\n<p>And we don't have memory on microcontrollers.</p>\n<p>So we need <a href=\"https://en.wikipedia.org/wiki/Stochastic_gradient_descent\">Stochastic gradient descent</a>.</p>\n<p>Stochastic gradient descent has the same exact update rule, but it is applied on the single training sample.</p>\n<p>Imagine the summation goes from 1 to 1, instead of m.</p>\n<p>That's it.</p>\n<div class=\"heateor_sss_sharing_container heateor_sss_horizontal_sharing\" ss-offset=\"0\" heateor-sss-data-href='https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/'><ul class=\"heateor_sss_sharing_ul\"><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" alt=\"Facebook\" Title=\"Facebook\" class=\"heateorSssSharing heateorSssFacebookBackground\" onclick='heateorSssPopup(\"https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Feloquent.blog%2F2020%2F04%2Fstochastic-gradient-descent-on-your-microcontroller%2F\")'><ss style=\"display:block;border-radius:999px;\" class=\"heateorSssSharingSvg heateorSssFacebookSvg\"></ss></i></li><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" alt=\"Twitter\" Title=\"Twitter\" class=\"heateorSssSharing heateorSssTwitterBackground\" onclick='heateorSssPopup(\"http://twitter.com/intent/tweet?via=ArduinoEloquent&text=Stochastic%20Gradient%20Descent%20on%20your%20microcontroller&url=http%3A%2F%2Feloquent.blog%2F2020%2F04%2Fstochastic-gradient-descent-on-your-microcontroller%2F\")'><ss style=\"display:block;border-radius:999px;\" class=\"heateorSssSharingSvg heateorSssTwitterSvg\"></ss></i></li><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" alt=\"Linkedin\" Title=\"Linkedin\" class=\"heateorSssSharing heateorSssLinkedinBackground\" onclick='heateorSssPopup(\"http://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Feloquent.blog%2F2020%2F04%2Fstochastic-gradient-descent-on-your-microcontroller%2F&title=Stochastic%20Gradient%20Descent%20on%20your%20microcontroller\")'><ss style=\"display:block;border-radius:999px;\" class=\"heateorSssSharingSvg heateorSssLinkedinSvg\"></ss></i></li><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" title=\"More\" alt=\"More\" class=\"heateorSssSharing heateorSssMoreBackground\" onclick=\"heateorSssMoreSharingPopup(this, 'https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/', 'Stochastic%20Gradient%20Descent%20on%20your%20microcontroller', '' )\" ><ss style=\"display:block\" class=\"heateorSssSharingSvg heateorSssMoreSvg\"></ss></i></li></ul><div class=\"heateorSssClear\"></div></div>\n<h2>How to use</h2>\n<p>The pattern of use is similar to that of the <a href=\"/2020/04/passive-aggressive-classifier-for-embedded-devices/\">Passive Aggressive classifier</a>: you have the <code>fitOne</code> and <code>predict</code> methods.</p>\n<p>First of all, <a href=\"https://github.com/eloquentarduino/EloquentMicroML\">download the library from Github</a>.</p>\n<pre><code class=\"language-c\">#include &lt;EloquentSGD.h&gt;\n#include &lt;EloquentAccuracyScorer.h&gt;\n#include &quot;iris.h&quot;\n\n#define VERBOSE\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n    Serial.begin(115200);\n    delay(3000);\n}\n\nvoid loop() {\n    int trainSamples;\n    int retrainingCycles;\n    SGD&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    // ....\n\n    // train\n    for (uint16_t cycle = 0; cycle &lt; retrainingCycles; cycle++)\n        for (uint16_t i = 0; i &lt; trainSamples; i++)\n            clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i];\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}</code></pre>\n<p>In this case we're working with known datasets, so we cycle through them for the training, but if you're learning &quot;on-line&quot;, from samples generated over time, it will work exactly the same.</p>\n<h2>A bit of momentum</h2>\n<p>Stochastic gradient descent works quite well out of the box in most cases.</p>\n<p>Sometimes, however, its updates can start &quot;oscillating&quot;.</p>\n<p><img src=\"https://media.springernature.com/original/springer-static/image/chp%3A10.1007%2F978-1-4842-4470-8_33/MediaObjects/463852_1_En_33_Fig1_HTML.jpg\" alt=\"SGD with and without momentum\" /></p>\n<p>To solve this problem, it <a href=\"https://doi.org/10.1038%2F323533a0\">has been proposed</a> the <strong>momentum</strong> technique, which can both speed up learning and increase the accuracy.</p>\n<p>In my personal tests, I was able to achieve up to +5% in accuracy on the majority of datasets.</p>\n<p>To use it, you only need to set a <em>decay factor</em> between 0 and 1.</p>\n<pre><code class=\"language-c\">SGD clf;\n\nclf.momentum(0.5);</code></pre>\n<h2>Run on your own</h2>\n<p>On <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/SGDExample/SGDExample.ino\">Github</a> you can find the full example with some benchmark datasets to try on your own.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<p>The example is interactive an will ask you how many samples to use for the training and how many times to cycle through them.</p>\n<p>This is something you should consider: if you have a training set and can store it somehow (in memory or on Flash for example), re-presenting the same samples to the SGD classifier could (and probably will) increase its performance if done correctly.</p>\n<p>This happens because the algorithm needs some time to converge and if it doesn't receive enough samples it won't learn properly.</p>\n<p>Of course, if you re-use the same samples over and over again, you're likely to overfit.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/\">Stochastic Gradient Descent on your microcontroller</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Stochastic gradient descent is a well know algorithm to train classifiers in an incremental fashion: that is, as training samples become available. This saves you critical memory on tiny devices while still achieving top performance! Now you can use it on your microcontroller with ease.\n\nA brief recap on Stochastic Gradient Descent\nIf you ever worked with Machine learning, you surely know about Gradient descent: it is an iterative algorithm to optimize a loss function. \nIt is much general-purpose, in the sense that it is not bound to a particular application, but it has been heavily used in Neural networks in the recent years.\nYet, it can be used as a classifier on its own if you set its loss function as the classification error.\n\nThis is the core update rule of Gradient descent: quite simple.\nAs you see, there's a summation in the formula: this means we need to cycle through the entire training set to compute the update to the weights.\nIn case of large datasets, this can be slow or not possible at all.\nAnd requires a lot of memory.\nAnd we don't have memory on microcontrollers.\nSo we need Stochastic gradient descent.\nStochastic gradient descent has the same exact update rule, but it is applied on the single training sample.\nImagine the summation goes from 1 to 1, instead of m.\nThat's it.\n\nHow to use\nThe pattern of use is similar to that of the Passive Aggressive classifier: you have the fitOne and predict methods.\nFirst of all, download the library from Github.\n#include &lt;EloquentSGD.h&gt;\n#include &lt;EloquentAccuracyScorer.h&gt;\n#include &quot;iris.h&quot;\n\n#define VERBOSE\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n    Serial.begin(115200);\n    delay(3000);\n}\n\nvoid loop() {\n    int trainSamples;\n    int retrainingCycles;\n    SGD&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    // ....\n\n    // train\n    for (uint16_t cycle = 0; cycle &lt; retrainingCycles; cycle++)\n        for (uint16_t i = 0; i &lt; trainSamples; i++)\n            clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i];\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}\nIn this case we're working with known datasets, so we cycle through them for the training, but if you're learning &quot;on-line&quot;, from samples generated over time, it will work exactly the same.\nA bit of momentum\nStochastic gradient descent works quite well out of the box in most cases.\nSometimes, however, its updates can start &quot;oscillating&quot;.\n\nTo solve this problem, it has been proposed the momentum technique, which can both speed up learning and increase the accuracy.\nIn my personal tests, I was able to achieve up to +5% in accuracy on the majority of datasets.\nTo use it, you only need to set a decay factor between 0 and 1.\nSGD clf;\n\nclf.momentum(0.5);\nRun on your own\nOn Github you can find the full example with some benchmark datasets to try on your own.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nThe example is interactive an will ask you how many samples to use for the training and how many times to cycle through them.\nThis is something you should consider: if you have a training set and can store it somehow (in memory or on Flash for example), re-presenting the same samples to the SGD classifier could (and probably will) increase its performance if done correctly.\nThis happens because the algorithm needs some time to converge and if it doesn't receive enough samples it won't learn properly.\nOf course, if you re-use the same samples over and over again, you're likely to overfit.\nL'articolo Stochastic Gradient Descent on your microcontroller proviene da Eloquent Arduino Blog.",
            "date_published": "2020-04-10T19:43:45+02:00",
            "date_modified": "2020-04-12T19:31:52+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "online-learning",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1050",
            "url": "https://eloquentarduino.github.io/2020/04/passive-aggressive-classifier-for-embedded-devices/",
            "title": "Passive-aggressive classifier for embedded devices",
            "content_html": "<p>When working with memory constrained devices you may not able to keep all the training data in memory: passive-aggressive classifiers may help solve your memory problems.</p>\n<p><span id=\"more-1050\"></span></p>\n<h2>Batch learning</h2>\n<p>A couple weeks ago I started exploring the possibility to train a machine learning classifier directly on a microcontroller. Since I like SVM, <a href=\"/2020/03/so-you-want-to-train-an-ml-classifier-directly-on-an-arduino-board\">I ported the simplified SVM SMO (Sequential Minimal Optimization) algorithm</a> to plain C, ready to be deployed to embedded devices.</p>\n<p>Now, that kind of algorithm works in the so-called &quot;batch-mode&quot;: it needs all the training data to be available in memory to learn.</p>\n<p>This may be a limiting factor on resource-constrained devices, since it poses an upper bound to the number of samples you can train on. And when working with high-dimensional datasets, the number of samples could be not enough to achieve good accuracy.</p>\n<h2>Enter incremental learning</h2>\n<p>To solve this limitation, you need a totally different kind of learning algorithms: you need incremental (a.k.a online a.k.a out of core) learning.</p>\n<p>Incremental learning works by inspecting one training sample at a time, instead of all at once.</p>\n<p>The clear advantage is that you have a tiny memory footprint. And this is a <strong>huge</strong> advantage.</p>\n<p>The clear disadvantage is that you don't have the &quot;big picture&quot; of your data, so:</p>\n<ul>\n<li>the end result will probably be affected by the order of presentation of the samples</li>\n<li>you may not be able to achieve top accuracy</li>\n</ul>\n<h2>Passive-aggressive classifier</h2>\n<p>Passive-aggressive classification is one of the available incremental learning algorithms and it is very simple to implement, since it has a closed-form update rule.</p>\n<p>Please refer to this <a href=\"https://www.bonaccorso.eu/2017/10/06/ml-algorithms-addendum-passive-aggressive-algorithms/\">short explanation on Passive-aggressive classifiers</a> for a nice description with images.</p>\n<p>The core concept is that the classifier adjusts it weight vector for each mis-classified training sample it receives, trying to get it correct.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/04/passive-aggressive-classifier.png\" alt=\"Passive aggressive classifier\" /></p>\n<h2>Benchmarks</h2>\n<p>I run a couple benchmark on my Esp32 to assess both accuracy and training time.</p>\n<p>First of all: <strong>it is fast!</strong>. When I say it is fast I mean it takes ~1ms to train on 400 samples x 30 features each.</p>\n<p>Talking about accuracy instead... Uhm...</p>\n<p>Accuracy vary. <strong>Greatly</strong>. </p>\n<p>You can achieve 100% on some datasets. </p>\n<p>And 40% on others. But on those same datasets you can achieve &gt;85% if training on a different number of samples. Or in a different order.</p>\n<p>I guess this is the tradeoff for such a simple and space-efficient algorithm.</p>\n<p>I report my results in the following table. It is not meant to be an exhaustive benchmark of the classifier, since those number will vary based on the order of presentation, but still you can get an idea of what it is able to achieve.</p>\n<table>\n<thead>\n<tr>\n<th>Dataset size</th>\n<th style=\"text-align: center;\">Train samples</th>\n<th style=\"text-align: right;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BREAST CANCER</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>567 samples</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">62</td>\n</tr>\n<tr>\n<td>30 features</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">37</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">63</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: right;\">39</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">150</td>\n<td style=\"text-align: right;\">38</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">200</td>\n<td style=\"text-align: right;\">64</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">250</td>\n<td style=\"text-align: right;\">61</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">300</td>\n<td style=\"text-align: right;\">69</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">350</td>\n<td style=\"text-align: right;\">73</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">400</td>\n<td style=\"text-align: right;\">85</td>\n</tr>\n<tr>\n<td>IRIS</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>100 samples</td>\n<td style=\"text-align: center;\">10</td>\n<td style=\"text-align: right;\">50</td>\n</tr>\n<tr>\n<td>4 features</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">51</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">80</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td>DIGITS</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>358 samples</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">98</td>\n</tr>\n<tr>\n<td>64 features</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">98</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">99</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">150</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">200</td>\n<td style=\"text-align: right;\">99</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">250</td>\n<td style=\"text-align: right;\">98</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">300</td>\n<td style=\"text-align: right;\">95</td>\n</tr>\n<tr>\n<td>CLEVELAND HEART DISEASE</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>212 samples</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">76</td>\n</tr>\n<tr>\n<td>13 features</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">24</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">77</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: right;\">19</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">120</td>\n<td style=\"text-align: right;\">82</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">140</td>\n<td style=\"text-align: right;\">78</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">180</td>\n<td style=\"text-align: right;\">88</td>\n</tr>\n</tbody>\n</table>\n<h2>Time to code</h2>\n<p>Here I'll report an extract of the example code you can find on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PassiveAggressiveExample/PassiveAggressiveExample.ino\">Github</a> for this classifier.</p>\n<pre><code class=\"language-c\">#include &quot;EloquentPassiveAggressiveClassifier.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n#include &quot;iris.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid loop() {\n    int trainSamples;\n    PassiveAggressiveClassifier&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    trainSamples = readSerialNumber(&quot;How many samples will you use as training?&quot;, DATASET_SIZE - 2);\n\n    if (trainSamples == 0)\n        return;\n\n    clf.setC(1);\n\n    // train\n    for (uint16_t i = 0; i &lt; trainSamples; i++)\n        clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i] &gt; 0 ? 1 : -1;\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}</code></pre>\n<hr />\n<p>On the <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PassiveAggressiveExample/PassiveAggressiveExample.ino\">project page</a> you will find the code to reproduce these numbers.</p>\n<hr />\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/04/passive-aggressive-classifier-for-embedded-devices/\">Passive-aggressive classifier for embedded devices</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "When working with memory constrained devices you may not able to keep all the training data in memory: passive-aggressive classifiers may help solve your memory problems.\n\nBatch learning\nA couple weeks ago I started exploring the possibility to train a machine learning classifier directly on a microcontroller. Since I like SVM, I ported the simplified SVM SMO (Sequential Minimal Optimization) algorithm to plain C, ready to be deployed to embedded devices.\nNow, that kind of algorithm works in the so-called &quot;batch-mode&quot;: it needs all the training data to be available in memory to learn.\nThis may be a limiting factor on resource-constrained devices, since it poses an upper bound to the number of samples you can train on. And when working with high-dimensional datasets, the number of samples could be not enough to achieve good accuracy.\nEnter incremental learning\nTo solve this limitation, you need a totally different kind of learning algorithms: you need incremental (a.k.a online a.k.a out of core) learning.\nIncremental learning works by inspecting one training sample at a time, instead of all at once.\nThe clear advantage is that you have a tiny memory footprint. And this is a huge advantage.\nThe clear disadvantage is that you don't have the &quot;big picture&quot; of your data, so:\n\nthe end result will probably be affected by the order of presentation of the samples\nyou may not be able to achieve top accuracy\n\nPassive-aggressive classifier\nPassive-aggressive classification is one of the available incremental learning algorithms and it is very simple to implement, since it has a closed-form update rule.\nPlease refer to this short explanation on Passive-aggressive classifiers for a nice description with images.\nThe core concept is that the classifier adjusts it weight vector for each mis-classified training sample it receives, trying to get it correct.\n\nBenchmarks\nI run a couple benchmark on my Esp32 to assess both accuracy and training time.\nFirst of all: it is fast!. When I say it is fast I mean it takes ~1ms to train on 400 samples x 30 features each.\nTalking about accuracy instead... Uhm...\nAccuracy vary. Greatly. \nYou can achieve 100% on some datasets. \nAnd 40% on others. But on those same datasets you can achieve &gt;85% if training on a different number of samples. Or in a different order.\nI guess this is the tradeoff for such a simple and space-efficient algorithm.\nI report my results in the following table. It is not meant to be an exhaustive benchmark of the classifier, since those number will vary based on the order of presentation, but still you can get an idea of what it is able to achieve.\n\n\n\nDataset size\nTrain samples\nAccuracy\n\n\n\n\nBREAST CANCER\n\n\n\n\n567 samples\n20\n62\n\n\n30 features\n40\n37\n\n\n\n60\n63\n\n\n\n100\n39\n\n\n\n150\n38\n\n\n\n200\n64\n\n\n\n250\n61\n\n\n\n300\n69\n\n\n\n350\n73\n\n\n\n400\n85\n\n\nIRIS\n\n\n\n\n100 samples\n10\n50\n\n\n4 features\n20\n51\n\n\n\n40\n100\n\n\n\n60\n100\n\n\n\n80\n100\n\n\nDIGITS\n\n\n\n\n358 samples\n20\n98\n\n\n64 features\n40\n98\n\n\n\n60\n99\n\n\n\n100\n100\n\n\n\n150\n100\n\n\n\n200\n99\n\n\n\n250\n98\n\n\n\n300\n95\n\n\nCLEVELAND HEART DISEASE\n\n\n\n\n212 samples\n20\n76\n\n\n13 features\n40\n24\n\n\n\n60\n77\n\n\n\n100\n19\n\n\n\n120\n82\n\n\n\n140\n78\n\n\n\n180\n88\n\n\n\nTime to code\nHere I'll report an extract of the example code you can find on Github for this classifier.\n#include &quot;EloquentPassiveAggressiveClassifier.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n#include &quot;iris.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid loop() {\n    int trainSamples;\n    PassiveAggressiveClassifier&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    trainSamples = readSerialNumber(&quot;How many samples will you use as training?&quot;, DATASET_SIZE - 2);\n\n    if (trainSamples == 0)\n        return;\n\n    clf.setC(1);\n\n    // train\n    for (uint16_t i = 0; i &lt; trainSamples; i++)\n        clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i] &gt; 0 ? 1 : -1;\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}\n\nOn the project page you will find the code to reproduce these numbers.\n\nL'articolo Passive-aggressive classifier for embedded devices proviene da Eloquent Arduino Blog.",
            "date_published": "2020-04-05T19:04:10+02:00",
            "date_modified": "2020-05-01T10:34:15+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "online-learning",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=988",
            "url": "https://eloquentarduino.github.io/2020/03/how-to-train-a-color-classification-machine-learning-classifier-directly-on-your-arduino-board/",
            "title": "How to train a color classification Machine learning classifier directly on your Arduino board",
            "content_html": "<p>In the <a href=\"/2020/03/so-you-want-to-train-an-ml-classifier-directly-on-an-arduino-board\">previous post</a> we learnt it is possible to train a Machine learning classifier directly on a microcontroller. In this post we'll look into how to do it to classify colors.</p>\n<p><span id=\"more-988\"></span></p>\n<p>This will be an hands-on guide, so let's walk throughout each step you need to complete to run the example. </p>\n<p>I setup this very example as a basis for your future projects, so you can easily swap the color classification task for any other one you could think of.</p>\n<h2>Definitions</h2>\n<pre><code class=\"language-c\">#ifdef ESP32\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n#define abs(x) ((x) &gt; 0 ? (x) : -(x))\n#endif\n\n#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;RGB.h&quot;\n\n#define MAX_TRAINING_SAMPLES 20\n#define FEATURES_DIM 3\n\nusing namespace Eloquent::ML;\n\nint numSamples;\nRGB rgb(2, 3, 4);\nfloat X_train[MAX_TRAINING_SAMPLES][FEATURES_DIM];\nint y_train[MAX_TRAINING_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);</code></pre>\n<p>When training a classifier on your microcontroller there are some things that are mandatory:</p>\n<ol>\n<li><code>#include &lt;EloquentSVMSMO.h&gt;</code>: this is the library that implements the SVM learning algorithm</li>\n<li><code>X_train</code>: this is a matrix where each row represents a training sample. You will need to keep this data always with you, since it's required also during the inference</li>\n<li><code>y_train</code>: this array contains, for each training sample, the class it belongs to: 1 or -1</li>\n<li><code>linearKernel</code>: this is the kernel function for the SVM classifier (you can read more <a href=\"#\">here</a>). You can pass your own kernel other than linear (for example <code>poly</code> or <code>rbf</code>)</li>\n</ol>\n<p>In this specific example, we're using the <code>RGB</code> class to handle the TCS3200 sensor reading, but this will change based on the dataset you want to train on. Also, since our features are going to be the R, G and B components of a color, <code>FEATURES_DIM</code> is set to 3.</p>\n<h2>Setup</h2>\n<pre><code class=\"language-c\">void setup() {\n    Serial.begin(115200);\n    rgb.begin();\n\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}</code></pre>\n<p>The setup does not contain any logic really. You can use this part to configure the parameters of the classifier:</p>\n<ul>\n<li><code>C</code>: &quot;The C parameter tells the SVM optimization how much you want to avoid misclassifying each training example. For large values of C, the optimization will choose a smaller-margin hyperplane if that hyperplane does a better job of getting all the training points classified correctly. Conversely, a very small value of C will cause the optimizer to look for a larger-margin separating hyperplane, even if that hyperplane misclassifies more points&quot; (quoted from <a href=\"https://stats.stackexchange.com/questions/31066/what-is-the-influence-of-c-in-svms-with-linear-kernel\">stackexchange</a>)</li>\n<li><code>tol</code>: &quot;The tol parameter is a setting for the SVM's tolerance in optimization. Recall that <code>yi(xi.w+b)-1 &gt;= 0</code>. For an SVM to be valid, all values must be greater than or equal to 0, and at least one value on each side needs to be &quot;equal&quot; to 0, which will be your support vectors. Since it is highly unlikely that you will actually get values equal perfectly to 0, you set tolerance to allow a bit of wiggle room.&quot; (quoted from <a href=\"https://pythonprogramming.net/support-vector-machine-parameters-machine-learning-tutorial/\">pythonprogramming</a>)</li>\n<li><code>maxIter</code>: set an upper bound to the number of iterations the algorithm can take to converge</li>\n<li><code>passes</code>: max # of times to iterate over \u03b1\u2019s without changing</li>\n<li><code>alphaTol</code>: alfpha coefficients determine which samples from the training set are to be considered support vectors and so be included during the inference procedure. This value discards support vectors with an alpha too small to be noticeable.</li>\n</ul>\n<h2>Fit</h2>\n<pre><code class=\"language-c\">else if (command == &quot;fit&quot;) {\n        Serial.print(&quot;How many samples will you record? &quot;);\n        numSamples = readSerialNumber();\n\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(i + 1);\n            Serial.print(&quot;/&quot;);\n            Serial.print(numSamples);\n            Serial.println(&quot; Which class does the sample belongs to, 1 or -1?&quot;);\n            y_train[i] = readSerialNumber() &gt; 0 ? 1 : -1;\n            getFeatures(X_train[i]);\n        }\n\n        Serial.print(&quot;Start training... &quot;);\n        classifier.fit(X_train, y_train, numSamples);\n        Serial.println(&quot;Done&quot;);\n    }</code></pre>\n<p>This is the core of the project. Here we are loading the samples to train our classifier &quot;live&quot; on the board.</p>\n<p>Since this is an interactive demo, the program prompts us to define how many samples we'll load and, one by one, which class they belong to.</p>\n<p>Now there are a few important things to keep in mind:</p>\n<ul>\n<li><code>numSamples</code>: sadly, C has no easy way to know the size of an array, so we have to be explicit about it. To train the classifier, it is mandatory that you do know I many samples you're passing to it</li>\n<li><code>getFeatures()</code> is the function that reads the training sample. It is actually a &quot;proxy&quot; to your own custom logic: in this example it reads the TCS3200, in your project it could read an accelerometer or the like.</li>\n<li><code>fit()</code>: this is where the magic happens. With this single line of code you're training the SVM on the training data; when the functions ends, the classifier will have updated its internal state with the coefficients it needs to classify new samples</li>\n</ul>\n<h2>Predict</h2>\n<p>ColorClassificationTrainingExample.ino</p>\n<pre><code class=\"language-c\">else if (command == &quot;predict&quot;) {\n        int label;\n        float x[FEATURES_DIM];\n\n        getFeatures(x);\n        Serial.print(&quot;Predicted label is &quot;);\n        Serial.println(classifier.predict(X_train, x));\n    }</code></pre>\n<p>Now that our classifier has been trained, we can finally make use of it to classify new samples.</p>\n<p>As easy as it can be, you just call its <code>predict</code> method.</p>\n<div class=\"infobox\">As you can see, the <code>predict</code> method requires the <code>X_train</code> matrix other than the new sample vector</div>\n<p>And that's it: you can now complete your Machine learning task on your microcontroller from start to end, without the need of a PC.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<hr />\n<p>Check the full project code on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/ColorClassificationTrainingExample/ColorClassificationTrainingExample.ino\">Github</a></p>\n<hr />\n<h2>Full example</h2>\n<p>ColorClassificationTrainingExample.ino</p>\n<pre><code class=\"language-c\">#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;RGB.h&quot;\n\n#define MAX_TRAINING_SAMPLES 20\n#define FEATURES_DIM 3\n\nusing namespace Eloquent::ML;\n\nint numSamples;\nRGB rgb(2, 3, 4);\nfloat X_train[MAX_TRAINING_SAMPLES][FEATURES_DIM];\nint y_train[MAX_TRAINING_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);\n\nvoid setup() {\n    Serial.begin(115200);\n    rgb.begin();\n\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}\n\nvoid loop() {\n    if (!Serial.available()) {\n        delay(100);\n        return;\n    }\n\n    String command = Serial.readStringUntil(&#039;\\n&#039;);\n\n    if (command == &quot;help&quot;) {\n        Serial.println(&quot;Available commands:&quot;);\n        Serial.println(&quot;\\tfit: train the classifier on a new set of samples&quot;);\n        Serial.println(&quot;\\tpredict: classify a new sample&quot;);\n        Serial.println(&quot;\\tinspect: print X_train and y_train&quot;);\n    }\n    else if (command == &quot;fit&quot;) {\n        Serial.print(&quot;How many samples will you record? &quot;);\n        numSamples = readSerialNumber();\n\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(i + 1);\n            Serial.print(&quot;/&quot;);\n            Serial.print(numSamples);\n            Serial.println(&quot; Which class does the sample belongs to, 1 or -1?&quot;);\n            y_train[i] = readSerialNumber() &gt; 0 ? 1 : -1;\n            getFeatures(X_train[i]);\n        }\n\n        Serial.print(&quot;Start training... &quot;);\n        classifier.fit(X_train, y_train, numSamples);\n        Serial.println(&quot;Done&quot;);\n    }\n    else if (command == &quot;predict&quot;) {\n        int label;\n        float x[FEATURES_DIM];\n\n        getFeatures(x);\n        Serial.print(&quot;Predicted label is &quot;);\n        Serial.println(classifier.predict(X_train, x));\n    }\n    else if (command == &quot;inspect&quot;) {\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(&quot;[&quot;);\n            Serial.print(y_train[i]);\n            Serial.print(&quot;] &quot;);\n\n            for (int j = 0; j &lt; FEATURES_DIM; j++) {\n                Serial.print(X_train[i][j]);\n                Serial.print(&quot;, &quot;);\n            }\n\n            Serial.println();\n        }\n    }\n}\n\n/**\n *\n * @return\n */\nint readSerialNumber() {\n    while (!Serial.available()) delay(1);\n\n    return Serial.readStringUntil(&#039;\\n&#039;).toInt();\n}\n\n/**\n * Get features for new sample\n * @param x\n */\nvoid getFeatures(float x[FEATURES_DIM]) {\n    rgb.read(x);\n\n    for (int i = 0; i &lt; FEATURES_DIM; i++) {\n        Serial.print(x[i]);\n        Serial.print(&quot;, &quot;);\n    }\n\n    Serial.println();\n}</code></pre>\n<p>RGB.h</p>\n<pre><code class=\"language-c\">#pragma once\n\n/**\n * Wrapper for RGB color sensor\n */\nclass RGB {\n    public:\n        RGB(uint8_t s2, uint8_t s3, uint8_t out) :\n            _s2(s2),\n            _s3(s3),\n            _out(out) {\n\n        }\n\n        /**\n         *\n         */\n        void begin() {\n            pinMode(_s2, OUTPUT);\n            pinMode(_s3, OUTPUT);\n            pinMode(_out, INPUT);\n        }\n\n        /**\n         *\n         * @param x\n         */\n        void read(float x[3]) {\n            x[0] = readComponent(LOW, LOW);\n            x[1] = readComponent(HIGH, HIGH);\n            x[2] = readComponent(LOW, HIGH);\n        }\n\n    protected:\n        uint8_t _s2;\n        uint8_t _s3;\n        uint8_t _out;\n\n        /**\n         *\n         * @param s2\n         * @param s3\n         * @return\n         */\n        int readComponent(bool s2, bool s3) {\n            delay(10);\n            digitalWrite(_s2, s2);\n            digitalWrite(_s3, s3);\n\n            return pulseIn(_out, LOW);\n        }\n};</code></pre>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/03/how-to-train-a-color-classification-machine-learning-classifier-directly-on-your-arduino-board/\">How to train a color classification Machine learning classifier directly on your Arduino board</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "In the previous post we learnt it is possible to train a Machine learning classifier directly on a microcontroller. In this post we'll look into how to do it to classify colors.\n\nThis will be an hands-on guide, so let's walk throughout each step you need to complete to run the example. \nI setup this very example as a basis for your future projects, so you can easily swap the color classification task for any other one you could think of.\nDefinitions\n#ifdef ESP32\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n#define abs(x) ((x) &gt; 0 ? (x) : -(x))\n#endif\n\n#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;RGB.h&quot;\n\n#define MAX_TRAINING_SAMPLES 20\n#define FEATURES_DIM 3\n\nusing namespace Eloquent::ML;\n\nint numSamples;\nRGB rgb(2, 3, 4);\nfloat X_train[MAX_TRAINING_SAMPLES][FEATURES_DIM];\nint y_train[MAX_TRAINING_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);\nWhen training a classifier on your microcontroller there are some things that are mandatory:\n\n#include &lt;EloquentSVMSMO.h&gt;: this is the library that implements the SVM learning algorithm\nX_train: this is a matrix where each row represents a training sample. You will need to keep this data always with you, since it's required also during the inference\ny_train: this array contains, for each training sample, the class it belongs to: 1 or -1\nlinearKernel: this is the kernel function for the SVM classifier (you can read more here). You can pass your own kernel other than linear (for example poly or rbf)\n\nIn this specific example, we're using the RGB class to handle the TCS3200 sensor reading, but this will change based on the dataset you want to train on. Also, since our features are going to be the R, G and B components of a color, FEATURES_DIM is set to 3.\nSetup\nvoid setup() {\n    Serial.begin(115200);\n    rgb.begin();\n\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}\nThe setup does not contain any logic really. You can use this part to configure the parameters of the classifier:\n\nC: &quot;The C parameter tells the SVM optimization how much you want to avoid misclassifying each training example. For large values of C, the optimization will choose a smaller-margin hyperplane if that hyperplane does a better job of getting all the training points classified correctly. Conversely, a very small value of C will cause the optimizer to look for a larger-margin separating hyperplane, even if that hyperplane misclassifies more points&quot; (quoted from stackexchange)\ntol: &quot;The tol parameter is a setting for the SVM's tolerance in optimization. Recall that yi(xi.w+b)-1 &gt;= 0. For an SVM to be valid, all values must be greater than or equal to 0, and at least one value on each side needs to be &quot;equal&quot; to 0, which will be your support vectors. Since it is highly unlikely that you will actually get values equal perfectly to 0, you set tolerance to allow a bit of wiggle room.&quot; (quoted from pythonprogramming)\nmaxIter: set an upper bound to the number of iterations the algorithm can take to converge\npasses: max # of times to iterate over \u03b1\u2019s without changing\nalphaTol: alfpha coefficients determine which samples from the training set are to be considered support vectors and so be included during the inference procedure. This value discards support vectors with an alpha too small to be noticeable.\n\nFit\nelse if (command == &quot;fit&quot;) {\n        Serial.print(&quot;How many samples will you record? &quot;);\n        numSamples = readSerialNumber();\n\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(i + 1);\n            Serial.print(&quot;/&quot;);\n            Serial.print(numSamples);\n            Serial.println(&quot; Which class does the sample belongs to, 1 or -1?&quot;);\n            y_train[i] = readSerialNumber() &gt; 0 ? 1 : -1;\n            getFeatures(X_train[i]);\n        }\n\n        Serial.print(&quot;Start training... &quot;);\n        classifier.fit(X_train, y_train, numSamples);\n        Serial.println(&quot;Done&quot;);\n    }\nThis is the core of the project. Here we are loading the samples to train our classifier &quot;live&quot; on the board.\nSince this is an interactive demo, the program prompts us to define how many samples we'll load and, one by one, which class they belong to.\nNow there are a few important things to keep in mind:\n\nnumSamples: sadly, C has no easy way to know the size of an array, so we have to be explicit about it. To train the classifier, it is mandatory that you do know I many samples you're passing to it\ngetFeatures() is the function that reads the training sample. It is actually a &quot;proxy&quot; to your own custom logic: in this example it reads the TCS3200, in your project it could read an accelerometer or the like.\nfit(): this is where the magic happens. With this single line of code you're training the SVM on the training data; when the functions ends, the classifier will have updated its internal state with the coefficients it needs to classify new samples\n\nPredict\nColorClassificationTrainingExample.ino\nelse if (command == &quot;predict&quot;) {\n        int label;\n        float x[FEATURES_DIM];\n\n        getFeatures(x);\n        Serial.print(&quot;Predicted label is &quot;);\n        Serial.println(classifier.predict(X_train, x));\n    }\nNow that our classifier has been trained, we can finally make use of it to classify new samples.\nAs easy as it can be, you just call its predict method.\nAs you can see, the predict method requires the X_train matrix other than the new sample vector\nAnd that's it: you can now complete your Machine learning task on your microcontroller from start to end, without the need of a PC.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n\nCheck the full project code on Github\n\nFull example\nColorClassificationTrainingExample.ino\n#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;RGB.h&quot;\n\n#define MAX_TRAINING_SAMPLES 20\n#define FEATURES_DIM 3\n\nusing namespace Eloquent::ML;\n\nint numSamples;\nRGB rgb(2, 3, 4);\nfloat X_train[MAX_TRAINING_SAMPLES][FEATURES_DIM];\nint y_train[MAX_TRAINING_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);\n\nvoid setup() {\n    Serial.begin(115200);\n    rgb.begin();\n\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}\n\nvoid loop() {\n    if (!Serial.available()) {\n        delay(100);\n        return;\n    }\n\n    String command = Serial.readStringUntil(&#039;\\n&#039;);\n\n    if (command == &quot;help&quot;) {\n        Serial.println(&quot;Available commands:&quot;);\n        Serial.println(&quot;\\tfit: train the classifier on a new set of samples&quot;);\n        Serial.println(&quot;\\tpredict: classify a new sample&quot;);\n        Serial.println(&quot;\\tinspect: print X_train and y_train&quot;);\n    }\n    else if (command == &quot;fit&quot;) {\n        Serial.print(&quot;How many samples will you record? &quot;);\n        numSamples = readSerialNumber();\n\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(i + 1);\n            Serial.print(&quot;/&quot;);\n            Serial.print(numSamples);\n            Serial.println(&quot; Which class does the sample belongs to, 1 or -1?&quot;);\n            y_train[i] = readSerialNumber() &gt; 0 ? 1 : -1;\n            getFeatures(X_train[i]);\n        }\n\n        Serial.print(&quot;Start training... &quot;);\n        classifier.fit(X_train, y_train, numSamples);\n        Serial.println(&quot;Done&quot;);\n    }\n    else if (command == &quot;predict&quot;) {\n        int label;\n        float x[FEATURES_DIM];\n\n        getFeatures(x);\n        Serial.print(&quot;Predicted label is &quot;);\n        Serial.println(classifier.predict(X_train, x));\n    }\n    else if (command == &quot;inspect&quot;) {\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(&quot;[&quot;);\n            Serial.print(y_train[i]);\n            Serial.print(&quot;] &quot;);\n\n            for (int j = 0; j &lt; FEATURES_DIM; j++) {\n                Serial.print(X_train[i][j]);\n                Serial.print(&quot;, &quot;);\n            }\n\n            Serial.println();\n        }\n    }\n}\n\n/**\n *\n * @return\n */\nint readSerialNumber() {\n    while (!Serial.available()) delay(1);\n\n    return Serial.readStringUntil(&#039;\\n&#039;).toInt();\n}\n\n/**\n * Get features for new sample\n * @param x\n */\nvoid getFeatures(float x[FEATURES_DIM]) {\n    rgb.read(x);\n\n    for (int i = 0; i &lt; FEATURES_DIM; i++) {\n        Serial.print(x[i]);\n        Serial.print(&quot;, &quot;);\n    }\n\n    Serial.println();\n}\nRGB.h\n#pragma once\n\n/**\n * Wrapper for RGB color sensor\n */\nclass RGB {\n    public:\n        RGB(uint8_t s2, uint8_t s3, uint8_t out) :\n            _s2(s2),\n            _s3(s3),\n            _out(out) {\n\n        }\n\n        /**\n         *\n         */\n        void begin() {\n            pinMode(_s2, OUTPUT);\n            pinMode(_s3, OUTPUT);\n            pinMode(_out, INPUT);\n        }\n\n        /**\n         *\n         * @param x\n         */\n        void read(float x[3]) {\n            x[0] = readComponent(LOW, LOW);\n            x[1] = readComponent(HIGH, HIGH);\n            x[2] = readComponent(LOW, HIGH);\n        }\n\n    protected:\n        uint8_t _s2;\n        uint8_t _s3;\n        uint8_t _out;\n\n        /**\n         *\n         * @param s2\n         * @param s3\n         * @return\n         */\n        int readComponent(bool s2, bool s3) {\n            delay(10);\n            digitalWrite(_s2, s2);\n            digitalWrite(_s3, s3);\n\n            return pulseIn(_out, LOW);\n        }\n};\nL'articolo How to train a color classification Machine learning classifier directly on your Arduino board proviene da Eloquent Arduino Blog.",
            "date_published": "2020-03-28T20:02:53+01:00",
            "date_modified": "2020-04-05T19:01:49+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "Arduino Machine learning",
                "Programming"
            ]
        }
    ]
}