<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>esp32 &#8211; Eloquent Arduino Blog</title>
	<atom:link href="https://eloquentarduino.github.io/tag/esp32/feed/" rel="self" type="application/rss+xml" />
	<link>http://eloquentarduino.github.io/</link>
	<description>Machine learning on Arduino, programming &#38; electronics</description>
	<lastBuildDate>Wed, 13 May 2020 19:19:35 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.3</generator>
	<item>
		<title>Easier, faster pure video ESP32 cam motion detection</title>
		<link>https://eloquentarduino.github.io/2020/05/easier-faster-pure-video-esp32-cam-motion-detection/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Sun, 10 May 2020 19:26:08 +0000</pubDate>
				<category><![CDATA[Computer vision]]></category>
		<category><![CDATA[camera]]></category>
		<category><![CDATA[esp32]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=1110</guid>

					<description><![CDATA[<p>If you liked my post about ESP32 cam motion detection, you'll love this updated version: it's easier to use and blazing fast! The post about pure video ESP32 cam motion detection without an external PIR is my most successful post at the moment. Many of you are interested about this topic. One of my readers, [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/05/easier-faster-pure-video-esp32-cam-motion-detection/">Easier, faster pure video ESP32 cam motion detection</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>If you liked my post about <a href="/2020/01/motion-detection-with-esp32-cam-only-arduino-version/">ESP32 cam motion detection</a>, you'll love this updated version: it's easier to use and blazing fast!</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/Faster-motion-detection.gif" alt="Faster motion detection" /></p>
<p><span id="more-1110"></span></p>
<p>The post about <strong>pure video ESP32 cam motion detection</strong> without an external PIR is my most successful post at the moment. Many of you are interested about this topic.</p>
<p>One of my readers, though, pointed out my implementation was quite slow and he only achieved bare 5 fps in his project. So he asked for a better alternative.</p>
<p>Since the post was of great interest for many people, I took the time to revisit the code and make improvements.</p>
<p>I came up with a 100% re-writing that is both easier to use and faster. Actually, it is <strong>blazing fast!</strong>.</p>
<p>Let's see how it works.</p>
<p><div class="toc"><h6>Table of contents</h6><ol><li><a href="#tocdownsampling">Downsampling</a><ol><li><a href="#tocnearest-neighbor">Nearest neighbor</a><li><a href="#tocfull-block-average">Full block average</a><li><a href="#toccore-block-average">Core block average</a><li><a href="#toccross-block-average">Cross block average</a><li><a href="#tocdiagonal-block-average">Diagonal block average</a><li><a href="#tocimplement-your-own">Implement your own</a></li></ol><li><a href="#tocbenchmarks">Benchmarks</a><li><a href="#tocmotion-detection">Motion detection</a><li><a href="#tocfull-code">Full code</a></ol></div></p>
<h2 id="tocdownsampling">Downsampling</h2>
<p>In the original post I introduced the idea of downsampling the image from the camera for a faster and more robust motion detection. I wrote the code in the main sketch to keep it self-contained.</p>
<p>Looking back now it was a poor choice, since it cluttered the project and distracted from the main purpose, which is motion detection.</p>
<p>Moreover, I thought that scanning the image buffer in sequential order would be the fastest approach.</p>
<p>It turns out I was wrong.</p>
<p>This time I scan the image buffer following the blocks that will compose the resulting image and the results are... much faster.</p>
<p>Also, I decided to inject some more efficiency that will further speedup the computation: using different strategies for downsampling.</p>
<p>The idea of downsampling is that you have to &quot;collapse&quot; a block of NxN from the original image to just one pixel of the resulting image.</p>
<p>Now, there are a variety of ways you can accomplish this. The first two I present here are the most obvious, the other two are of my &quot;invention&quot;: nothing fancy nor new, but they're fast and serve the purpose well.</p>
<h3 id="tocnearest-neighbor">Nearest neighbor</h3>
<p>You can just pick the center of the NxN block and use its value for the output.<br />
Of course it is fast (possibly the fastest approach), but wouldn't be very accurate. One pixel out of NxN wouldn't be representative of the overall region and will heavily suffer from noise.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/Nearest-diagram.png" alt="Nearest diagram" /></p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/nn.jpg" alt="Nearest neighbor block averaging" /></p>
<h3 id="tocfull-block-average">Full block average</h3>
<p>This is the most intuitive alternative: use the average of all the pixels in the block as the ouput value. This is arguabily the &quot;proper&quot; way to do it, since you're using all the pixels in the source image to compute the new one.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/Full-diagram.png" alt="Full diagram" /><br />
<img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/full.jpg" alt="Full block averaging" /></p>
<h3 id="toccore-block-average">Core block average</h3>
<p>As a faster alternative, I thought that averaging only the &quot;core&quot; (the most internal part) of the block would have been a good-enough solution. It has no theoretical proof that this yields true, but our task here is to create a smaller <em>representation</em> of the original image, not producing an accurate smaller version.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/Core-diagram.png" alt="Core diagram" /><br />
<img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/core.jpg" alt="Core block averaging" /></p>
<p><em>I'll stress this point: the only reason we do downsampling is to compare two sequential frame and detect if they differ above a certain threshold. This downsampling doesn't have to mimic the actual image: it can transform the source in any fancy way, as long as it stays consistent and captures the variations over time.</em></p>
<h3 id="toccross-block-average">Cross block average</h3>
<p>This time we consider all the pixels along the vertical and horizontal central axes. The idea is that you will capture a good portion of the variation along both the axis, given quite accurate results.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/Cross-diagram.png" alt="Cross diagram" /><br />
<img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/cross.jpg" alt="Cross block averaging" /></p>
<h3 id="tocdiagonal-block-average">Diagonal block average</h3>
<p>This alternative too came to my mind from nowhere, really. I just think it is a good alternative to capture all the block's variation, probably even better than vertical and horizontal directions.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/Diagonal-diagram.png" alt="Diagonal diagram" /><br />
<img src="https://eloquentarduino.github.io/wp-content/uploads/2020/05/diagonal.jpg" alt="Diagonal block averaging" /></p>
<h3 id="tocimplement-your-own">Implement your own</h3>
<p>Not satisfied from the methods above? No problem, you can still implement your own.</p>
<p>The ones presented above are just some algorithms that came to my mind: I'm not telling you they're the best.</p>
<p>They worked for me, that's it.</p>
<p>If you think you found a better solution, I encourage you implement it and even share it with me and the other readers, so we can all make progress on this together.</p>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup">
<form action="https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
	<h2 style="margin: 0; text-align: center">Finding this content useful?</h2>
<div class="mc-field-group">
	<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="join the monthly newsletter">
</div>
	<div id="mce-responses" class="clear">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_f0eaedd94d554cf2ee781742a_37d3496031" tabindex="-1" value=""></div>
    <div class="clear" style="position: relative; top: 8px"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<h2 id="tocbenchmarks">Benchmarks</h2>
<p>So, at the very beginning I said this new implementation is blazingly fast. </p>
<p>How much fast?</p>
<p>As fast as it can be, arguably.</p>
<p>I mean, so fast it won't alter your fps.</p>
<p>Look at the results I got on my M5Stack camera.</p>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th style="text-align: center;">Time to execute (micros)</th>
<th style="text-align: right;">FPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td style="text-align: center;">0</td>
<td style="text-align: right;">25</td>
</tr>
<tr>
<td>Nearest neighbor</td>
<td style="text-align: center;">160</td>
<td style="text-align: right;">25</td>
</tr>
<tr>
<td>Cross block</td>
<td style="text-align: center;">700</td>
<td style="text-align: right;">25</td>
</tr>
<tr>
<td>Core block</td>
<td style="text-align: center;">800</td>
<td style="text-align: right;">25</td>
</tr>
<tr>
<td>Diagonal block</td>
<td style="text-align: center;">950</td>
<td style="text-align: right;">25</td>
</tr>
<tr>
<td>Full block</td>
<td style="text-align: center;">4900</td>
<td style="text-align: right;">12</td>
</tr>
</tbody>
</table>
<p>As you can see, only the full block creates a delay in the process (quite a bit of delay even): the other  methods  won't slow down your program in any noticeable way.</p>
<p>If you test Nearest neighbor and it works for you, then you'll be extremely light on computation resources with only <strong>160 microseconds</strong> of delay.</p>
<p>This is what I mean by <em>blazing fast</em>.</p>
<h2 id="tocmotion-detection">Motion detection</h2>
<p>The motion detection part hasn't changed, so I point you to <a href="/2020/01/motion-detection-with-esp32-cam-only-arduino-version#tocblocks-difference-threshold">the original post</a> to read more about the Block difference threshold and the Image difference threshold.</p>
<h2 id="tocfull-code">Full code</h2>
<pre><code class="language-cpp">#define CAMERA_MODEL_M5STACK_WIDE
#include &quot;EloquentVision.h&quot;

#define FRAME_SIZE FRAMESIZE_QVGA
#define SOURCE_WIDTH 320
#define SOURCE_HEIGHT 240
#define BLOCK_SIZE 10
#define DEST_WIDTH (SOURCE_WIDTH / BLOCK_SIZE)
#define DEST_HEIGHT (SOURCE_HEIGHT / BLOCK_SIZE)
#define BLOCK_DIFF_THRESHOLD 0.2
#define IMAGE_DIFF_THRESHOLD 0.1
#define DEBUG 0

using namespace Eloquent::Vision;

ESP32Camera camera;
uint8_t prevFrame[DEST_WIDTH * DEST_HEIGHT] = { 0 };
uint8_t currentFrame[DEST_WIDTH * DEST_HEIGHT] = { 0 };

// function prototypes
bool motionDetect();
void updateFrame();

/**
 *
 */
void setup() {
    Serial.begin(115200);
    camera.begin(FRAME_SIZE, PIXFORMAT_GRAYSCALE);
}

/**
 *
 */
void loop() {
    /**
     * Algorithm:
     *  1. grab frame
     *  2. compare with previous to detect motion
     *  3. update previous frame
     */

    time_t start = millis();
    camera_fb_t *frame = camera.capture();

    downscaleImage(frame-&gt;buf, currentFrame, nearest, SOURCE_WIDTH, SOURCE_HEIGHT, BLOCK_SIZE);

    if (motionDetect()) {
        Serial.print(&quot;Motion detected @ &quot;);
        Serial.print(floor(1000.0f / (millis() - start)));
        Serial.println(&quot; FPS&quot;);
    }

    updateFrame();
}

/**
 * Compute the number of different blocks
 * If there are enough, then motion happened
 */
bool motionDetect() {
    uint16_t changes = 0;
    const uint16_t blocks = DEST_WIDTH * DEST_HEIGHT;

    for (int y = 0; y &lt; DEST_HEIGHT; y++) {
        for (int x = 0; x &lt; DEST_WIDTH; x++) {
            float current = currentFrame[y * DEST_WIDTH + x];
            float prev = prevFrame[y * DEST_WIDTH + x];
            float delta = abs(current - prev) / prev;

            if (delta &gt;= BLOCK_DIFF_THRESHOLD)
                changes += 1;
        }
    }

    return (1.0 * changes / blocks) &gt; IMAGE_DIFF_THRESHOLD;
}

/**
 * Copy current frame to previous
 */
void updateFrame() {
    memcpy(prevFrame, currentFrame, DEST_WIDTH * DEST_HEIGHT);
}</code></pre>
<hr />
<p>Check the full project code on <a href="https://github.com/eloquentarduino/EloquentVision/blob/master/examples/FasterMotionDetection/FasterMotionDetection.ino">Github</a> and remember to star!</p>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup">
<form action="https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
	<h2 style="margin: 0; text-align: center">Finding this content useful?</h2>
<div class="mc-field-group">
	<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="join the monthly newsletter">
</div>
	<div id="mce-responses" class="clear">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_f0eaedd94d554cf2ee781742a_37d3496031" tabindex="-1" value=""></div>
    <div class="clear" style="position: relative; top: 8px"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/05/easier-faster-pure-video-esp32-cam-motion-detection/">Easier, faster pure video ESP32 cam motion detection</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Handwritten digit classification with Arduino and MicroML</title>
		<link>https://eloquentarduino.github.io/2020/02/handwritten-digit-classification-with-arduino-and-microml/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Sun, 23 Feb 2020 10:53:03 +0000</pubDate>
				<category><![CDATA[Arduino Machine learning]]></category>
		<category><![CDATA[Computer vision]]></category>
		<category><![CDATA[camera]]></category>
		<category><![CDATA[esp32]]></category>
		<category><![CDATA[microml]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=931</guid>

					<description><![CDATA[<p>We continue exploring the endless possibilities on the MicroML (Machine Learning for Microcontrollers) framework on Arduino and ESP32 boards: in this post we're back to image classification. In particular, we'll distinguish handwritten digits using an ESP32 camera. If this is the first time you're reading my blog, you may have missed that I'm on a [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/02/handwritten-digit-classification-with-arduino-and-microml/">Handwritten digit classification with Arduino and MicroML</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We continue exploring the endless possibilities on the MicroML (Machine Learning for Microcontrollers) framework on Arduino and ESP32 boards: in this post we're back to image classification. In particular, we'll distinguish handwritten digits using an ESP32 camera.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/02/MNIST.gif" alt="Arduino handwritten digit classification" /></p>
<p><span id="more-931"></span></p>
<p>If this is the first time you're reading my blog, you may have missed that I'm on a journey to push the limits of Machine learning on embedded devices like the Arduino boards and ESP32.</p>
<p>I started with <a href="/2019/12/how-to-do-gesture-identification-on-arduino/">accelerometer data classification</a>, then did <a href="/2019/12/wifi-indoor-positioning-on-arduino/">Wifi indoor positioning</a> as a proof of concept.</p>
<p>In the last weeks, though, I undertook a more difficult path that is image classification.</p>
<p>Image classification is where Convolutional Neural Networks really shine, but I'm here to <a href="/2020/01/image-recognition-with-esp32-and-arduino/">question this settlement</a> and demostrate that it is possible to come up with much lighter alternatives.</p>
<p>In this post we continue with the examples, replicating a &quot;benchmark&quot; dataset in Machine learning: the handwritten digits classification.</p>
<div class="infobox">
If you are curious about a specific image classification task you would like to see implemented, <b>let me know in the comments</b>: I'm always open to new ideas
</div>
<h2>The task</h2>
<p>The objective of this example is to be able to tell what an handwritten digit is, taking as input a photo from the ESP32 camera.</p>
<p>In particular, we have 3 handwritten numbers and the task of our model will be to distinguish which image is what number.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/02/mnist-examples.jpg" alt="Handwritten digits example" /></p>
<p>I only have a single image per digit, but you're free to draw as many samples as you like: it should help improve the performance of you're classifier.</p>
<h2>1. Feature extraction</h2>
<p>When dealing with images, if you use a CNN this step is often overlooked: CNNs are made on purpose to handle raw pixel values, so you just throw the image in and it is handled properly.</p>
<p>When using other types of classifiers, it could help add a bit of feature engineering to help the classifier doing its job and achieve high accuracy.</p>
<p>But not this time.</p>
<p>I wanted to be as &quot;light&quot; as possible in this demo, so I only took a couple steps during the feature acquisition:</p>
<ol>
<li>use a grayscale image</li>
<li>downsample to a manageable size</li>
<li>convert it to black/white with a threshold</li>
</ol>
<p>I would hardly call this feature engineering.</p>
<p>This is an example of the result of this pipeline.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/02/mnist-feature-extraction.jpg" alt="Handwritten digit feature extraction" /></p>
<p>The code for this pipeline is really simple and is almost the same from the example on <a href="/2020/01/motion-detection-with-esp32-cam-only-arduino-version/">motion detection</a>.</p>
<pre><code class="language-c">#include &quot;esp_camera.h&quot;

#define PWDN_GPIO_NUM     -1
#define RESET_GPIO_NUM    15
#define XCLK_GPIO_NUM     27
#define SIOD_GPIO_NUM     22
#define SIOC_GPIO_NUM     23
#define Y9_GPIO_NUM       19
#define Y8_GPIO_NUM       36
#define Y7_GPIO_NUM       18
#define Y6_GPIO_NUM       39
#define Y5_GPIO_NUM        5
#define Y4_GPIO_NUM       34
#define Y3_GPIO_NUM       35
#define Y2_GPIO_NUM       32
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     26
#define PCLK_GPIO_NUM     21

#define FRAME_SIZE FRAMESIZE_QQVGA
#define WIDTH 160
#define HEIGHT 120
#define BLOCK_SIZE 5
#define W (WIDTH / BLOCK_SIZE)
#define H (HEIGHT / BLOCK_SIZE)
#define THRESHOLD 127

double features[H*W] = { 0 };

void setup() {
    Serial.begin(115200);
    Serial.println(setup_camera(FRAME_SIZE) ? &quot;OK&quot; : &quot;ERR INIT&quot;);
    delay(3000);
}

void loop() {
    if (!capture_still()) {
        Serial.println(&quot;Failed capture&quot;);
        delay(2000);
        return;
    }

    print_features();
    delay(3000);
}

bool setup_camera(framesize_t frameSize) {
    camera_config_t config;

    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM;
    config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM;
    config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM;
    config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM;
    config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    config.pin_sscb_sda = SIOD_GPIO_NUM;
    config.pin_sscb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = PWDN_GPIO_NUM;
    config.pin_reset = RESET_GPIO_NUM;
    config.xclk_freq_hz = 20000000;
    config.pixel_format = PIXFORMAT_GRAYSCALE;
    config.frame_size = frameSize;
    config.jpeg_quality = 12;
    config.fb_count = 1;

    bool ok = esp_camera_init(&amp;config) == ESP_OK;

    sensor_t *sensor = esp_camera_sensor_get();
    sensor-&gt;set_framesize(sensor, frameSize);

    return ok;
}

bool capture_still() {
    camera_fb_t *frame = esp_camera_fb_get();

    if (!frame)
        return false;

    // reset all the features
    for (size_t i = 0; i &lt; H * W; i++)
      features[i] = 0;

    // for each pixel, compute the position in the downsampled image
    for (size_t i = 0; i &lt; frame-&gt;len; i++) {
      const uint16_t x = i % WIDTH;
      const uint16_t y = floor(i / WIDTH);
      const uint8_t block_x = floor(x / BLOCK_SIZE);
      const uint8_t block_y = floor(y / BLOCK_SIZE);
      const uint16_t j = block_y * W + block_x;

      features[j] += frame-&gt;buf[i];
    }

    // apply threshold
    for (size_t i = 0; i &lt; H * W; i++) {
      features[i] = (features[i] / (BLOCK_SIZE * BLOCK_SIZE) &gt; THRESHOLD) ? 1 : 0;
    }

    return true;
}

void print_features() {
    for (size_t i = 0; i &lt; H * W; i++) {
        Serial.print(features[i]);

        if (i != H * W - 1)
          Serial.print(&#039;,&#039;);
    }

    Serial.println();
}</code></pre>
<h2>2. Samples recording</h2>
<p>To create your own dataset, you need a collection of handwritten digits.</p>
<p>You can do this part as you like, by using pieces of paper or a monitor. I used a tablet because it was well illuminated and I could open a bunch of tabs to keep a record of my samples.</p>
<p>As in the <a href="/2020/01/image-recognition-with-esp32-and-arduino/">apple vs orange</a>, keep in mind that you should be consistent during both the training phase and the inference phase.</p>
<p>This is why I used tape to fix my ESP32 camera to the desk and kept the tablet in the exact same position.</p>
<p>If you desire, you could experiment varying slightly the capturing setup during the training and see if your classifier still achieves good accuracy: this is a test I didn't make.</p>
<h2>3. Train and export the SVM classifier</h2>

<p>For a detailed guide refer to the <a href="/2019/11/how-to-train-a-classifier-in-scikit-learn/" target="_blank" rel="noopener noreferrer">tutorial</a></p>

<p>
<pre><code class="language-python">from sklearn.svm import SVC
from micromlgen import port

# put your samples in the dataset folder
# one class per file
# one feature vector per line, in CSV format
features, classmap = load_features('dataset/')
X, y = features[:, :-1], features[:, -1]
classifier = SVC(kernel='linear').fit(X, y)
c_code = port(classifier, classmap=classmap)
print(c_code)</code></pre>

<p>At this point you have to copy the printed code and import it in your Arduino project, in a file called <code>model.h</code>.</p>
<h2>4. The result</h2>
<p>Okay, at this point you should have all the working pieces to do handwritten digit image classification on your ESP32 camera. Include your model in the sketch and run the classification.</p>
<pre><code class="language-c">#include &quot;model.h&quot;

void loop() {
    if (!capture_still()) {
        Serial.println(&quot;Failed capture&quot;);
        delay(2000);

        return;
    }

    Serial.print(&quot;Number: &quot;);
    Serial.println(classIdxToName(predict(features)));
    delay(3000);
}</code></pre>
<p>Done.</p>
<p>You can see a demo of my results in the video below.</p>
<div style="width: 788px;" class="wp-video"><!--[if lt IE 9]><script>document.createElement('video');</script><![endif]-->
<video class="wp-video-shortcode" id="video-931-1" width="788" height="443" preload="metadata" controls="controls"><source type="video/mp4" src="https://eloquentarduino.github.io/wp-content/uploads/2020/02/MNIST-mute.mp4?_=1" /><a href="https://eloquentarduino.github.io/wp-content/uploads/2020/02/MNIST-mute.mp4">https://eloquentarduino.github.io/wp-content/uploads/2020/02/MNIST-mute.mp4</a></video></div>
<h3>Project figures</h3>
<p>My dataset is composed of 25 training samples in total and the SVM with linear kernel produced 17 support vectors.</p>
<p>On my M5Stick camera board, the overhead for the model is 6.8 Kb of flash and the inference takes 7ms: not that bad!</p>
<hr>
<p>Check the full project code on <a href="https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/HandwrittenDigitClassificationExample/HandwrittenDigitClassificationExample.ino" target="_blank" rel="noopener noreferrer">Github</a></p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/02/handwritten-digit-classification-with-arduino-and-microml/">Handwritten digit classification with Arduino and MicroML</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		<enclosure url="https://eloquentarduino.github.io/wp-content/uploads/2020/02/MNIST-mute.mp4" length="6424809" type="video/mp4" />

			</item>
		<item>
		<title>Apple or Orange? Image recognition with ESP32 and Arduino</title>
		<link>https://eloquentarduino.github.io/2020/01/image-recognition-with-esp32-and-arduino/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Sun, 12 Jan 2020 10:32:08 +0000</pubDate>
				<category><![CDATA[Arduino Machine learning]]></category>
		<category><![CDATA[Computer vision]]></category>
		<category><![CDATA[camera]]></category>
		<category><![CDATA[esp32]]></category>
		<category><![CDATA[microml]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=820</guid>

					<description><![CDATA[<p>Do you have an ESP32 camera? Want to do image recognition directly on your ESP32, without a PC? In this post we'll look into a very basic image recognition task: distinguish apples from oranges with machine learning. Image recognition is a very hot topic these days in the AI/ML landscape. Convolutional Neural Networks really shines [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/01/image-recognition-with-esp32-and-arduino/">Apple or Orange? Image recognition with ESP32 and Arduino</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Do you have an ESP32 camera? </p>
<p>Want to do image recognition directly on your ESP32, without a PC?</p>
<p>In this post we'll look into a very basic image recognition task: <strong>distinguish apples from oranges with machine learning</strong>.</p>
<p><img src="/wp-content/uploads/2020/01/Apple-vs-Orange.gif" alt="Apple vs Orange" /></p>
<p><span id="more-820"></span></p>
<p>Image recognition is a very hot topic these days in the AI/ML landscape. <a href="https://en.wikipedia.org/wiki/Convolutional_neural_network">Convolutional Neural Networks</a> really shines in this task and can achieve almost perfect accuracy on many scenarios.</p>
<p>Sadly, you can't run CNN on your ESP32, they're just too large for a microcontroller.</p>
<p>Since in this series about <a href="/category/programming/arduino-machine-learning/">Machine Learning on Microcontrollers</a> we're exploring the potential of Support Vector Machines (SVMs) at solving different classification tasks, we'll take a look into image classification too.</p>
<p><div class="toc"><h6>Table of contents</h6><ol><li><a href="#tocwhat-were-going-to-do">What we're going to do</a><li><a href="#tocfeatures-definition">Features definition</a><li><a href="#tocextracting-rgb-components">Extracting RGB components</a><li><a href="#tocrecord-samples-image">Record samples image</a><li><a href="#toctraining-the-classifier">Training the classifier</a><li><a href="#tocreal-world-example">Real world example</a><ol><li><a href="#tocdisclaimer">Disclaimer</a></ol></div></p>
<h2 id="tocwhat-were-going-to-do">What we're going to do</h2>
<p>In a previous post about <a href="/2019/12/color-identification-on-arduino/">color identification with Machine learning</a>, we used an Arduino to detect the object we were pointing at with a color sensor (TCS3200) by its color: if we detected yellow, for example, we knew we had a banana in front of us.</p>
<p>Of course such a process is not object recognition at all: yellow may be a banane, or a lemon, or an apple.</p>
<p>Object inference, in that case, works only if you have exactly one object for a given color.</p>
<p>The objective of this post, instead, is to investigate if we can use the MicroML framework to do simple image recognition on the images from an ESP32 camera.</p>
<p>This is much more similar to the tasks you do on your PC with CNN or any other form of NN you are comfortable with. Sure, we will still apply some restrictions to fit the problem on a microcontroller, but this is a huge step forward compared to the simple color identification.</p>
<div class="watchout">
In this context, image recognition means deciding which class (from the trained ones) the current image belongs to. <b>This algorithm can't locate interesting objects in the image, neither detect if an object is present in the frame</b>. It will classify the current image based on the samples recorded during training.
</div>
<p>As any beginning machine learning project about image classification worth of respect, our task will be to distinguish an orange from an apple.</p>
<h2 id="tocfeatures-definition">Features definition</h2>
<p>I have to admit that I rarely use NN, so I may be wrong here, but from the examples I read online it looks to me that features engineering is not a fundamental task with NN.</p>
<p>Those few times I used CNN, I always used the whole image as input, <em>as-is</em>. I didn't extracted any feature from them (e.g. color histogram): the CNN worked perfectly fine with raw images.</p>
<p>I don't think this will work best with SVM, but in this first post we're starting as simple as possible, so we'll be using the RGB components of the image as our features. In a future post, we'll introduce additional features to try to improve our results.</p>
<p>I said we're using the RGB components of the image. But not all of them.</p>
<p>Even at the lowest resolution of 160x120 pixels, a raw RGB image from the camera would generate 160x120x3 = 57600 features: way too much.</p>
<p>We need to reduce this number  to the bare minimum.</p>
<p>How much pixels do you think are necessary to get reasonable results in this task of classifying apples from oranges?</p>
<p>You would be surprised to know that I got 90% accuracy with an RGB image of <strong>8x6</strong>!</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/01/Orange-and-Apple-pixelated.jpg" alt="You actually need very few pixels to do image classification" /></p>
<p>Yes, that's all we really need to do a <em>good enough</em> classification.</p>
<hr /><p><em>You can distinguish apples from oranges on ESP32 with 8x6 pixels only!</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2020%2F01%2Fimage-recognition-with-esp32-and-arduino%2F&#038;text=You%20can%20distinguish%20apples%20from%20oranges%20on%20ESP32%20with%208x6%20pixels%20only%21&#038;via=EloquentArduino&#038;related=EloquentArduino' target='_blank' rel="noopener noreferrer" >Click To Tweet</a><br /><hr />
<p>Of course this is a tradeoff: you can't expect to achieve 99% accuracy while mantaining the model size small enough to fit on a microcontroller. 90% is an acceptable accuracy for me in this context.</p>
<p>You have to keep in mind, moreover, that the features vector size grows quadratically with the image size (if you keep the aspect ratio). A raw RGB image of 8x6 generates 144 features: an image of 16x12 generates 576 features. This was already causing random crashes on my ESP32.</p>
<p>So we'll stick to 8x6 images.</p>
<p>Now, how do you compact a 160x120 image to 8x6? With <em>downsampling</em>.</p>
<p>This is the same tecnique we've used in the post about <a href="/2020/01/motion-detection-with-esp32-cam-only-arduino-version/">motion detection on ESP32</a>: we define a block size and average all the pixels inside the block to get a single value (you can refer to that post for more details).</p>
<p><img src="/wp-content/uploads/2020/01/Image-downsampling-example.jpg" alt="Image downsampling example" /></p>
<p>This time, though, we're working with RGB images instead of grayscale, so we'll repeat the exact same process 3 times, one for each channel.</p>
<p>This is the code excerpt that does the downsampling.</p>
<pre><code class="language-cpp">uint16_t rgb_frame[HEIGHT / BLOCK_SIZE][WIDTH / BLOCK_SIZE][3] = { 0 };

void grab_image() {
    for (size_t i = 0; i &lt; len; i += 2) {
        // get r, g, b from the buffer
        // see later

        const size_t j = i / 2;
        // transform x, y in the original image to x, y in the downsampled image
        // by dividing by BLOCK_SIZE
        const uint16_t x = j % WIDTH;
        const uint16_t y = floor(j / WIDTH);
        const uint8_t block_x = floor(x / BLOCK_SIZE);
        const uint8_t block_y = floor(y / BLOCK_SIZE);

        // average pixels in block (accumulate)
        rgb_frame[block_y][block_x][0] += r;
        rgb_frame[block_y][block_x][1] += g;
        rgb_frame[block_y][block_x][2] += b;
    }
}</code></pre>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup">
<form action="https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
	<h2 style="margin: 0; text-align: center">Finding this content useful?</h2>
<div class="mc-field-group">
	<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="join the monthly newsletter">
</div>
	<div id="mce-responses" class="clear">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_f0eaedd94d554cf2ee781742a_37d3496031" tabindex="-1" value=""></div>
    <div class="clear" style="position: relative; top: 8px"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<h2 id="tocextracting-rgb-components">Extracting RGB components</h2>
<p>The ESP32 camera can store the image in different formats (of our interest — there are a couple more available):</p>
<ol>
<li><strong>grayscale</strong>: no color information, just the intensity is stored. The buffer has size HEIGHT*WIDTH</li>
<li><strong>RGB565</strong>: stores each RGB pixel in two bytes, with 5 bit for red, 6 for green and 5 for blue. The buffer has size HEIGHT * WIDTH * 2</li>
<li><strong>JPEG</strong>: encodes (in hardware?) the image to jpeg. The buffer has a variable length, based on the encoding results</li>
</ol>
<p>For our purpose, we'll use the RGB565 format and extract the 3 components from the 2 bytes with the following code.</p>
<p><img src="https://s2.www.theimagingsource.com/application-1.1.29/documentation/ic_imaging_control_class/en_US/images/rgb565.gif" alt="taken from https://www.theimagingsource.com/support/documentation/ic-imaging-control-cpp/PixelformatRGB565.htm" /></p>
<pre><code class="language-cpp">config.pixel_format = PIXFORMAT_RGB565;

for (size_t i = 0; i &lt; len; i += 2) {
    const uint8_t high = buf[i];
    const uint8_t low  = buf[i+1];
    const uint16_t pixel = (high &lt;&lt; 8) | low;

    const uint8_t r = (pixel &amp; 0b1111100000000000) &gt;&gt; 11;
    const uint8_t g = (pixel &amp; 0b0000011111100000) &gt;&gt; 6;
    const uint8_t b = (pixel &amp; 0b0000000000011111);
}</code></pre>
<h2 id="tocrecord-samples-image">Record samples image</h2>
<p>Now that we can grab the images from the camera, we'll need to take a few samples of each object we want to racognize.</p>
<p>Before doing so, we'll linearize the image matrix to a 1-dimensional vector, because that's what our prediction function expects.</p>
<pre><code class="language-cpp">#define H (HEIGHT / BLOCK_SIZE)
#define W (WIDTH / BLOCK_SIZE)

void linearize_features() {
  size_t i = 0;
  double features[H*W*3] = {0};

  for (int y = 0; y &lt; H; y++) {
    for (int x = 0; x &lt; W; x++) {
      features[i++] = rgb_frame[y][x][0];
      features[i++] = rgb_frame[y][x][1];
      features[i++] = rgb_frame[y][x][2];
    }
  }

  // print to serial
  for (size_t i = 0; i &lt; H*W*3; i++) {
    Serial.print(features[i]);
    Serial.print(&#039;\t&#039;);
  }

  Serial.println();
}</code></pre>
<p>Now you can setup your acquisition environment and take the samples: 15-20 of each object will do the job.</p>
<div class="watchout">
Image acquisition is a very noisy process: even keeping the camera still, you will get fluctuating values. <br />You need to be very accurate during this phase if you want to achieve good results.<br /> I suggest you immobilize your camera with tape to a flat surface or use some kind of photographic easel.
</div>
<h2 id="toctraining-the-classifier">Training the classifier</h2>
<p>To train the classifier, save the features for each object in a file, one features vector per line. Then follow the steps on <a href="/2019/11/how-to-train-a-classifier-in-scikit-learn">how to train a ML classifier for Arduino</a> to get the exported model.</p>
<p>You can experiment with different classifier configurations. </p>
<p>My features were well distinguishable, so I had great results (100% accuracy) with any kernel (even linear).</p>
<p>One odd thing happened with the RBF kernel: I had to use an extremely low gamma value (0.0000001). Does anyone can explain me why? I usually go with a default value of 0.001.</p>
<p>The model produced 13 support vectors.</p>
<p>I did no features scaling: you could try it if classifying more than 2 classes and having poor results.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/01/Apple-vs-Orange-decision-boundaries.png" alt="Apple vs Orange decision boundaries" /></p>
<h2 id="tocreal-world-example">Real world example</h2>
<p>If you followed all the steps above, you should now have a model capable of detecting if your camera is shotting an apple or an orange, as you can see in the following video.</p>
<div style="width: 788px;" class="wp-video"><video class="wp-video-shortcode" id="video-820-2" width="788" height="443" preload="metadata" controls="controls"><source type="video/mp4" src="https://eloquentarduino.github.io/wp-content/uploads/2020/01/Apple-vs-Orange.mp4?_=2" /><a href="https://eloquentarduino.github.io/wp-content/uploads/2020/01/Apple-vs-Orange.mp4">https://eloquentarduino.github.io/wp-content/uploads/2020/01/Apple-vs-Orange.mp4</a></video></div>
<p></p>
<p>The little white object you see at the bottom of the image is the camera, taped to the desk.</p>
<p>Did you think it was possible to do simple image classification on your ESP32?</p>
<h3 id="tocdisclaimer">Disclaimer</h3>
<p>This is not full-fledged object recognition: it can't label objects while you walk as Tensorflow can do, for example.</p>
<p>You have to carefully craft your setup and be as consistent as possible between training and inferencing.</p>
<p>Still, I think this is a fun proof-of-concept that can have useful applications in simple scenarios where you can live with a fixed camera and don't want to use a full Raspberry Pi.</p>
<p>In the next weeks I settled to finally try TensorFlow Lite for Microcontrollers on my ESP32, so I'll try to do a comparison between them and this example and report my results.</p>
<p>Now that you can do image classification on your ESP32, can you think of a use case you will be able to apply this code to? </p>
<p>Let me know in the comments, we could even try realize it together if you need some help.</p>
<hr>
<p>Check the full project code on <a href="https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/Apple_vs_Orange/Apple_vs_Orange.ino" target="_blank" rel="noopener noreferrer">Github</a></p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/01/image-recognition-with-esp32-and-arduino/">Apple or Orange? Image recognition with ESP32 and Arduino</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		<enclosure url="https://eloquentarduino.github.io/wp-content/uploads/2020/01/Apple-vs-Orange.mp4" length="1642079" type="video/mp4" />

			</item>
		<item>
		<title>Motion detection with ESP32 cam only (Arduino version)</title>
		<link>https://eloquentarduino.github.io/2020/01/motion-detection-with-esp32-cam-only-arduino-version/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Sun, 05 Jan 2020 11:08:08 +0000</pubDate>
				<category><![CDATA[Computer vision]]></category>
		<category><![CDATA[camera]]></category>
		<category><![CDATA[esp32]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=779</guid>

					<description><![CDATA[<p>Do you have an ESP32 camera? Do you want to do motion detection WITHOUT ANY external hardware? Here's a tutorial made just for you: 30 lines of code and you will know when something changes in your video stream 🎥 ** See the updated version of this project: it's easier to use and waaay faster: [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/01/motion-detection-with-esp32-cam-only-arduino-version/">Motion detection with ESP32 cam only (Arduino version)</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Do you have an <strong>ESP32 camera</strong>? Do you want to do motion detection <em>WITHOUT ANY</em> external hardware?</p>
<p>Here's a tutorial made just for you: <strong>30 lines of code</strong> and you will know when something changes in your video stream  <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f3a5.png" alt="🎥" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.gif" alt="ESP32 camera motion detection example" /></p>
<p><span id="more-779"></span></p>
<p><strong> ** See the updated version of this project: it's easier to use and waaay faster: </strong> <a href="/2020/05/easier-faster-pure-video-esp32-cam-motion-detection/">Easier, faster, pure video ESP32 cam motion detection</a> **</p>
<p><div class="toc"><h6>Table of contents</h6><ol><li><a href="#tocwhat-is-naive-motion-detection">What is (naive) motion detection?</a><li><a href="#toccant-i-use-an-external-pir">Can't I use an external PIR?</a><ol><li><a href="#tocexternal-hardware">External hardware</a><li><a href="#tocfield-of-view">Field of View</a><li><a href="#toccold-objects">Cold objects</a></li></ol><li><a href="#tocwhat-do-you-need">What do you need?</a><li><a href="#tochow-does-it-work">How does it work?</a><ol><li><a href="#tocdownsampling">Downsampling</a><li><a href="#tocblocks-difference-threshold">Blocks difference threshold</a><li><a href="#tocimage-difference-threshold">Image difference threshold</a><li><a href="#toccombining-all-together">Combining all together</a></li></ol><li><a href="#tocreal-world-example">Real world example</a></ol></div></p>
<h2 id="tocwhat-is-naive-motion-detection">What is (naive) motion detection?</h2>
<p>Quoting from Wikipedia</p>
<blockquote>
<p>Motion detection is the process of detecting a change in the position of an object relative to its surroundings or a change in the surroundings relative to an object</p>
</blockquote>
<p>In this project, we're implementing what I call <em>naive</em> motion detection: that is, we're not focusing on a particular object and following its motion.</p>
<p>We'll only detect if any considerable portion of the image changed from one frame to the next.</p>
<p>We won't identify the location of motion (that's the subject for a next project), neither what caused it. We will analyze video stream in (almost) real-time and compare frame by frame: if lots of pixels changed, we'll call it motion.</p>
<h2 id="toccant-i-use-an-external-pir">Can't I use an external PIR?</h2>
<p>Several projects on the internet about motion detection with an ESP32 cam use an external <a href="https://en.wikipedia.org/wiki/Passive_infrared_sensor">PIR sensor</a> to trigger the video recording.</p>
<p>What's the problem with that approach? </p>
<h3 id="tocexternal-hardware">1. External hardware</h3>
<p>First of all, you need external hardware. If you're using a breadboard, no problem, you just need a couple more wires and you're good to go. But I have a nice <a href="https://www.banggood.com/M5CameraF-ESP32-Fish-eye-Camera-Development-Board-Module-OV2640-Mini-Fisheye-Camera-Unit-Demoboard-p-1496820.html?rmmds=search&amp;cur_warehouse=CN">M5stick camera</a> (no affiliate link), that's already well packaged, so it won't be that easy to add a PIR sensor.</p>
<h3 id="tocfield-of-view">2. Field of View</h3>
<p>PIR sensors have a limited FOV (field of view), so you will need more than one to cover the whole range of the camera. </p>
<p>My camera, for example, has fish-eye lens which give me 160° of view. Most cheap PIR sensors have a 120° field of view, so one will not suffice. This adds even more space to my project.</p>
<h3 id="toccold-objects">3. Cold objects</h3>
<p>PIR sensors gets triggered by infrared light. Infrared light gets emitted by hot bodies (like people and animals).</p>
<p>But motion in a video stream can happen for a variety of reasons, not necessarily due to hot bodies, for example if you want to monitor a street for cars passing by.</p>
<p>A PIR sensor can't do this: video motion detection can.</p>
<hr /><p><em>ESP32 cam pure video motion detection can detect motion due to cold objects</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2020%2F01%2Fmotion-detection-with-esp32-cam-only-arduino-version%2F&#038;text=ESP32%20cam%20pure%20video%20motion%20detection%20can%20detect%20motion%20due%20to%20cold%20objects&#038;via=EloquentArduino&#038;related=EloquentArduino' target='_blank' rel="noopener noreferrer" >Click To Tweet</a><br /><hr />
<div class="infobox"> Do you like the motion effect at the beginning of the post? <a href="https://gist.github.com/eloquentarduino/6bb0b26a3900d7fac68b2f3cc7b2c688">Check it out on Github</a></div>
<h2 id="tocwhat-do-you-need">What do you need?</h2>
<p>All you need for this project is a board with a camera sensor. As I said, I have a M5Stick Camera with fish-eye lens, but any ESP32 based camera should work out of the box:</p>
<ul>
<li>ESP32 cam</li>
<li>ESP32 eye</li>
<li>TTGO camera</li>
<li>... any other flavor of ESP32 camera</li>
</ul>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-models.jpg" alt="ESP32 camera models" /></p>
<h2 id="tochow-does-it-work">How does it work?</h2>
<p>Ok, let's go to the &quot;technical&quot; stuff.</p>
<p>Simply put, the algorithm counts the number of different pixels from one frame to the next: if many pixels changed, it will detect motion.</p>
<p>Well, it's <em>almost</em> like this.</p>
<p>Of course such an algorithm will be very sensitive to noise (which is quite high on these low-cost cameras). We need to mitigate false-positive triggers.</p>
<h3 id="tocdownsampling">Downsampling</h3>
<p>One super-simple and super-effective way of doing this is to <strong>work with blocks</strong>, instead of pixels. A block is simply an N x N square, whose value is the average of the pixels it contains.</p>
<p>This greatly reduces sensitivity to noise, providing a more robust detection. Here's an example of what the the &quot;block-ing&quot; operation does to an image.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/01/Image-downsampling-example.jpg" alt="Image downsampling example" /></p>
<p>It's really a &quot;pixelating&quot; effect: you take the orginal image (let's say 320x240 pixels) and resize it to 10x smaller, 32x24.  </p>
<p>This has the added benefit that it's much more lightweight to work with 32x24 matrix instead of 320x240 matrix: if you want to do real-time detection, this is a MUST.</p>
<p>How should you choose the scale factor?</p>
<p>Well, it depends.</p>
<p>It depends on the sensitivity you want to achieve. The higher the downsampling, the less sensitive your detection will be. </p>
<p>If you want to detect a person passing 50cm away from the camera, you can increase this number without any problem. If you want to detect a dog 10m away, you should keep it in the 5-10 range.</p>
<p>Experiment with your own use case a tweak with trial-and-error.</p>
<h3 id="tocblocks-difference-threshold">Blocks difference threshold</h3>
<p>Once we've defined the block size, we need to detect if a block changed from one frame to the next.</p>
<p>Of course, just testing for difference (<code>current != prev</code>) would be again too sensitive to noise. A block can change for a variety of reasons, the first of which is the bad camera quality.</p>
<p>So we instead define a percent threshold above which we can say for sure the block actually changed. A good starting point could be 10-20%, but again you need to tweak this to your needs.</p>
<p>The higher the threshold, the less sensitive the algorithm will be.</p>
<p>In code it is calculated as</p>
<pre><code class="language-cpp">float delta = abs(currentBlockValue - prevBlockValue) / prevBlockValue;</code></pre>
<p>which indicates the relative increment/decrement from the previous value.</p>
<h3 id="tocimage-difference-threshold">Image difference threshold</h3>
<p>Now that we can detect if a block changed from one frame to the next, we can actually detect if the image changed.</p>
<p>You could decide to trigger motion even if a single block changed, but I suggest you to set an higher value here.</p>
<p>Let's return to the 320x240 image example. With a 10x10 block, you'll be working with <code>32x24 = 768</code> blocks: will you call it &quot;motion&quot; if 1 out of 768 blocks changed value?</p>
<p>I don't think so. You want something more robust. You want 50 blocks to change. Or at least 20 blocks. If you do the math, 20 blocks out of 768 is only the 2.5% of change, which is hardly noticeable.</p>
<p>If you want to be robust, don't set this threshold to a too low value. Again, tweak with real world experimenting.</p>
<p>In code it is calculated as:</p>
<pre><code class="language-cpp">float changedBlocksPercent = changedBlocks / totalBlocks</code></pre>
<h3 id="toccombining-all-together">Combining all together</h3>
<p>Recapping: when running the motion detection algorithm you have 3 parameters to set:</p>
<ol>
<li>the block size</li>
<li>the block difference threshold</li>
<li>the image differerence threshold</li>
</ol>
<p>Let's pick 3 sensible defaults: <code>block size = 10</code>, <code>block threshold = 15%</code>, <code>image threshold = 20%</code>.</p>
<p>What does these parameters translate to in the practice?</p>
<p>They mean that motion will be detected if <code>20% of the image, averaged in blocks of 10x10, changed its value by at least 15% from one frame to the next</code>.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-example.jpg" alt="ESP32 camera motion example" /></p>
<p>As you can see, you don't need high-definition images to (naively) detect if something happened to the image. Large area of motion will be easily detectable, even at very low resolution.</p>
<h2 id="tocreal-world-example">Real world example</h2>
<p>Now the fun part. I'll show you how it performs on a real-world scenario.</p>
<p>To keep it simple, I wrote a sketch that does only motion detection, not video streaming over HTTP. </p>
<p>This means you won't be able to see the original image recorded from the camera. Nevertheless, I have kept the block size to a minimum to allow for the best quality possible.</p>
<div style="width: 652px;" class="wp-video"><video class="wp-video-shortcode" id="video-779-3" width="652" height="604" preload="metadata" controls="controls"><source type="video/mp4" src="https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.mp4?_=3" /><a href="https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.mp4">https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.mp4</a></video></div>
<p>This is me passing my arm in front of the camera a few times.</p>
<p>The grid you see represents the actual pixels used for the computation. Each cell corresponds to one pixel of the downscaled image.</p>
<p>The orange cells highlight the pixels that the algorithm sees as &quot;different&quot; from one frame to the next. As you can see, some pixels are detected even if no motion is happening. That's the noise I talked about multiple times during the post.</p>
<p>When I move my arm in the frame, you see lots of pixels become activated, so the &quot;Motion&quot; text appears. </p>
<p>While moving the arm, you may notice what I call the &quot;ghost&quot; effect. You actually see 2 regions of motion: one is where my arm is now, which of course changed. The other is the region where my arm was in the previous frame, which returned to its original content.</p>
<p>This is why I suggest you keep the <code>image difference threshold</code> to a high value: if some real motion happens, you will notice it for sure because the activated region of the image will be actually bigger than the actual object moving.</p>
<p>Do you like the grid effect of the sample video? Let me know in the comment if you want me to share it.</p>
<p>Or even better: subscribe to the newsletter I you will get it directly in your inbox with my next mail.</p>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup">
<form action="https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
	<h2 style="margin: 0; text-align: center">Finding this content useful?</h2>
<div class="mc-field-group">
	<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="join the monthly newsletter">
</div>
	<div id="mce-responses" class="clear">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_f0eaedd94d554cf2ee781742a_37d3496031" tabindex="-1" value=""></div>
    <div class="clear" style="position: relative; top: 8px"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<hr>
<p>Check the full project code on <a href="https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/ESP32CameraNaiveMotionDetection/ESP32CameraNaiveMotionDetection.ino" target="_blank" rel="noopener noreferrer">Github</a></p>
<p>Check out also the <a href="https://gist.github.com/eloquentarduino/6bb0b26a3900d7fac68b2f3cc7b2c688">gist for the visualization tool</a></p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/01/motion-detection-with-esp32-cam-only-arduino-version/">Motion detection with ESP32 cam only (Arduino version)</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		<enclosure url="https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.mp4" length="1673368" type="video/mp4" />

			</item>
	</channel>
</rss>
