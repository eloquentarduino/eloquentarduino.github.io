{
    "version": "https://jsonfeed.org/version/1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/tag/eloquent/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/tag/eloquent/",
    "feed_url": "https://eloquentarduino.github.io/tag/eloquent/feed/json/",
    "title": "Eloquent Arduino Blog",
    "description": "A blog about Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/2019/12/arduino-pin-class/",
            "url": "https://eloquentarduino.github.io/2019/12/arduino-pin-class/",
            "title": "Eloquent pin management: the Pin class",
            "content_html": "<p><code>Pin</code> is a class for pin manipulation: you can read, write, turnOn, turnOff, toggle and a lot more. Please, stop writing horrible code like <code>digitalWrite(led, HIGH)</code> and start writing <code>led.turnOn()</code> instead. </p>\n<p><span id=\"more-167\"></span></p>\n<p><code>Pin</code> is actually an abstract class, so you won't use it directly, but through its specialized implementations:</p>\n<ol>\n<li>DigitalIn</li>\n<li>DigitalOut</li>\n<li>AnalogIn</li>\n<li>AnalogOut</li>\n</ol>\n<h2>Import the library</h2>\n<div class=\"watchout\">To follow this tutorial along you need to first <a href=\"/2019/12/how-to-install-the-eloquent-library/\" target=\"_blank\">install the Eloquent library</a></div>\n<pre><code class=\"language-cpp\">#import &lt;eIO.h&gt;\n\nusing namespace Eloquent::Pin;</code></pre>\n<p>If the namespace stuff is new to you, here I'll briefly say that it is used to avoid name collisions among different libraries. This seems to be an alien topic in the Arduino world and I can't really explain why.</p>\n<p>99% of the libraries out there deal with this problem in one of two modes:</p>\n<ol>\n<li>ignoring it altogether, so you have an <code>MPU6050.h</code> library, which elects itself as the only one implementation possible to access the MPU6050 accelerometer in the world</li>\n<li>prefixing each library file, so you get the <code>Adafruit_Si7021</code> class</li>\n</ol>\n<hr /><p><em>The case for Adafruit_Si7021 should not exist in my opinion: use the damn namespaces!</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Farduino-pin-class%2F&#038;text=The%20case%20for%20Adafruit_Si7021%20should%20not%20exist%20in%20my%20opinion%3A%20use%20the%20damn%20namespaces%21&#038;via=ArduinoEloquent&#038;related=ArduinoEloquent' target='_blank' rel=\"noopener noreferrer\" >Click To Tweet</a><br /><hr />\n<p>With namespaces, it would become:</p>\n<pre><code class=\"language-cpp\">using namespace Adafruit;\n\nSi7021 si;</code></pre>\n<h2>How to use</h2>\n<p>First of all, all the 4 implementations accept a single constructor argument: the pin number.</p>\n<pre><code class=\"language-cpp\"> DigitalOut led(BUILTIN_LED);\n DigitalIn pushButton(10);\n AnalogIn potentiometer(A0);\n AnalogOut pwmLed(8);</code></pre>\n<p>Then it is good practice to init your pins in the setup.</p>\n<pre><code class=\"language-cpp\"> void setup() {\n    led.begin();\n    pushButton.begin();\n    potentiometer.begin();\n    pwmLed.begin();\n }</code></pre>\n<p>All the 4 classes let you ask for the pin current value via the <code>value()</code> method:</p>\n<pre><code class=\"language-cpp\"> void test() {\n    // DigitalIn returns the last read value, as 0/1\n    digitalIn.value();\n\n    // AnalogIn returns the last read value, in the range [0, 1024]\n    analogIn.value();\n\n    // DigitalOut returns the last written value, as 0/1\n    digitalOut.value();\n\n    // AnaloglOut returns the last written value, in the range [0, 255]\n    analogOut.value();\n }</code></pre>\n<p>At this point each class will provide its specialized methods.</p>\n<h4>DigitalIn</h4>\n<pre><code class=\"language-cpp\">void test() {\n    // configure pin as INPUT_PULLUP\n    pin.pullup();\n\n    // configure pin as Active Low \n    // that is, pin is ON when digitalRead() is LOW\n    pin.activeLow();\n\n    // read and update pin value\n    pin.read();\n\n    // test if pin is on (doesn&#039;t read the pin)\n    pin.isOn();\n\n    // test if pin is off (doesn&#039;t read the pin)\n    pin.isOff();\n\n    // test if pin value changed from last reading\n    pin.changed();\n}</code></pre>\n<h4>DigitalOut</h4>\n<pre><code class=\"language-cpp\">void test() {\n    // set pin as Active Low\n    // that is, turnOn writes LOW\n    pin.activeLow();\n\n    // turn pin on\n    pin.turnOn();\n\n    // turn pin off\n    pin.turnOff();\n\n    // toggle\n    pin.toggle();\n\n    // blink N times at intervals of X milliseconds\n    pin.blink(N, X);\n}</code></pre>\n<h4>AnalogIn</h4>\n<pre><code class=\"language-cpp\">void test() {\n    // read current pin value\n    pin.read();\n\n    // get pin previous value\n    pin.prev();\n\n    // get difference between current value and previous\n    pin.delta();\n\n    // get absolute value of delta()\n    pin.absDelta();\n}</code></pre>\n<h4>AnalogOut</h4>\n<pre><code class=\"language-cpp\">void test() {\n    // write value X to pin\n    pin.write(X);\n}</code></pre>\n<hr />\n<p>If you don't believe a whole class is worthwhile to work with pins, I'll show a few use cases to illustrate my point.</p>\n<h4>Use case #1: active low LED</h4>\n<p>The ESP8266 has a builtin LED you can control, but it is an <em>active low</em> one: it will turn on when you write <code>LOW</code>. In this case, <code>digitalWrite(BUILTIN_LED, LOW)</code> can be misleading regarding your actual intentions. </p>\n<p>It doesn't look intuitive,  it doesn't look <em>eloquent</em>! <code>builtinLed.turnOn()</code> does, however. All you need to get it working correctly is calling <code>builtinLed.activeLow()</code> once in your setup.</p>\n<pre><code class=\"language-cpp\">// BEFORE\nvoid loop() {\n    // to turn the builtin LED on\n    digitalWrite(led, LOW);\n}</code></pre>\n<pre><code class=\"language-cpp\">// AFTER\nDigitalOut buildtinLed;\n\nvoid setup() {\n    builtinLed.activeLow();\n}\n\nvoid loop() {\n    // to turn the builtin LED on\n    builtinLed.turnOn();\n}</code></pre>\n<h4>Use case #2: toggle</h4>\n<p>If you need to toggle the current state of a digital output, you need an helper variable to keep track of the state and remember to <strong>always</strong> update that variable when you write to the output.<br />\nWith a class, the state is tightly bound to the instance, so you have a <a href=\"https://en.wikipedia.org/wiki/Single_source_of_truth\">single source of truth</a>: <code>turnOn()</code>, <code>turnOff()</code> and <code>toggle()</code> will take care of updating the inner state accordingly.</p>\n<pre><code class=\"language-cpp\">// BEFORE\n#define LED 1\n\nbool ledState = true;\n\nloop() {\n    digitalWrite(LED, ledState);\n    ledState = !ledState\n}</code></pre>\n<pre><code class=\"language-cpp\">// AFTER\nDigitalOut led(1);\n\nvoid loop() {\n    led.toggle();\n}</code></pre>\n<h4>Use case #3: analog delta</h4>\n<p>What if you have an analog input and want to know if its valued changed by at least X from your latest reading? You would need an helper variable again. </p>\n<p>Now imagine if you have 5 analog inputs you want to track: you'll end up with 10 variables and of course you have again to <strong>always</strong> keep both in sync.<br />\n<code>AnalogIn</code> conveniently provides <code>delta()</code> and <code>absDelta()</code> methods that give you the change from the previous reading and will always be in sync. Awesome!</p>\n<pre><code class=\"language-cpp\">// BEFORE\n#define INPUT1 A1\n#define INPUT2 A2\n\nuint16_t current1, prev1;\nuint16_t current2, prev2;\n\nvoid loop() {\n    prev1 = current1;\n    current1 = analogRead(INPUT1);\n    prev2 = current2;\n    current2 = analogRead(INPUT2);\n\n    if (abs(current1 - prev1) &gt; THRESHOLD)\n        ...</code></pre>\n<pre><code class=\"language-cpp\">// AFTER\nAnalogIn input1(A1), input2(A2);\n\nvoid loop() {\n    input1.read();\n    input2.read();\n\n    if (input1.absDelta() &gt; THRESHOLD)\n        ...\n}</code></pre>\n<br><p>Did you find this tutorial useful? Was is it easy to follow or did I miss something? Let me know in the comments so I can keep improving the blog.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2019/12/arduino-pin-class/\">Eloquent pin management: the Pin class</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Pin is a class for pin manipulation: you can read, write, turnOn, turnOff, toggle and a lot more. Please, stop writing horrible code like digitalWrite(led, HIGH) and start writing led.turnOn() instead. \n\nPin is actually an abstract class, so you won't use it directly, but through its specialized implementations:\n\nDigitalIn\nDigitalOut\nAnalogIn\nAnalogOut\n\nImport the library\nTo follow this tutorial along you need to first install the Eloquent library\n#import &lt;eIO.h&gt;\n\nusing namespace Eloquent::Pin;\nIf the namespace stuff is new to you, here I'll briefly say that it is used to avoid name collisions among different libraries. This seems to be an alien topic in the Arduino world and I can't really explain why.\n99% of the libraries out there deal with this problem in one of two modes:\n\nignoring it altogether, so you have an MPU6050.h library, which elects itself as the only one implementation possible to access the MPU6050 accelerometer in the world\nprefixing each library file, so you get the Adafruit_Si7021 class\n\nThe case for Adafruit_Si7021 should not exist in my opinion: use the damn namespaces!Click To Tweet\nWith namespaces, it would become:\nusing namespace Adafruit;\n\nSi7021 si;\nHow to use\nFirst of all, all the 4 implementations accept a single constructor argument: the pin number.\n DigitalOut led(BUILTIN_LED);\n DigitalIn pushButton(10);\n AnalogIn potentiometer(A0);\n AnalogOut pwmLed(8);\nThen it is good practice to init your pins in the setup.\n void setup() {\n    led.begin();\n    pushButton.begin();\n    potentiometer.begin();\n    pwmLed.begin();\n }\nAll the 4 classes let you ask for the pin current value via the value() method:\n void test() {\n    // DigitalIn returns the last read value, as 0/1\n    digitalIn.value();\n\n    // AnalogIn returns the last read value, in the range [0, 1024]\n    analogIn.value();\n\n    // DigitalOut returns the last written value, as 0/1\n    digitalOut.value();\n\n    // AnaloglOut returns the last written value, in the range [0, 255]\n    analogOut.value();\n }\nAt this point each class will provide its specialized methods.\nDigitalIn\nvoid test() {\n    // configure pin as INPUT_PULLUP\n    pin.pullup();\n\n    // configure pin as Active Low \n    // that is, pin is ON when digitalRead() is LOW\n    pin.activeLow();\n\n    // read and update pin value\n    pin.read();\n\n    // test if pin is on (doesn&#039;t read the pin)\n    pin.isOn();\n\n    // test if pin is off (doesn&#039;t read the pin)\n    pin.isOff();\n\n    // test if pin value changed from last reading\n    pin.changed();\n}\nDigitalOut\nvoid test() {\n    // set pin as Active Low\n    // that is, turnOn writes LOW\n    pin.activeLow();\n\n    // turn pin on\n    pin.turnOn();\n\n    // turn pin off\n    pin.turnOff();\n\n    // toggle\n    pin.toggle();\n\n    // blink N times at intervals of X milliseconds\n    pin.blink(N, X);\n}\nAnalogIn\nvoid test() {\n    // read current pin value\n    pin.read();\n\n    // get pin previous value\n    pin.prev();\n\n    // get difference between current value and previous\n    pin.delta();\n\n    // get absolute value of delta()\n    pin.absDelta();\n}\nAnalogOut\nvoid test() {\n    // write value X to pin\n    pin.write(X);\n}\n\nIf you don't believe a whole class is worthwhile to work with pins, I'll show a few use cases to illustrate my point.\nUse case #1: active low LED\nThe ESP8266 has a builtin LED you can control, but it is an active low one: it will turn on when you write LOW. In this case, digitalWrite(BUILTIN_LED, LOW) can be misleading regarding your actual intentions. \nIt doesn't look intuitive,  it doesn't look eloquent! builtinLed.turnOn() does, however. All you need to get it working correctly is calling builtinLed.activeLow() once in your setup.\n// BEFORE\nvoid loop() {\n    // to turn the builtin LED on\n    digitalWrite(led, LOW);\n}\n// AFTER\nDigitalOut buildtinLed;\n\nvoid setup() {\n    builtinLed.activeLow();\n}\n\nvoid loop() {\n    // to turn the builtin LED on\n    builtinLed.turnOn();\n}\nUse case #2: toggle\nIf you need to toggle the current state of a digital output, you need an helper variable to keep track of the state and remember to always update that variable when you write to the output.\nWith a class, the state is tightly bound to the instance, so you have a single source of truth: turnOn(), turnOff() and toggle() will take care of updating the inner state accordingly.\n// BEFORE\n#define LED 1\n\nbool ledState = true;\n\nloop() {\n    digitalWrite(LED, ledState);\n    ledState = !ledState\n}\n// AFTER\nDigitalOut led(1);\n\nvoid loop() {\n    led.toggle();\n}\nUse case #3: analog delta\nWhat if you have an analog input and want to know if its valued changed by at least X from your latest reading? You would need an helper variable again. \nNow imagine if you have 5 analog inputs you want to track: you'll end up with 10 variables and of course you have again to always keep both in sync.\nAnalogIn conveniently provides delta() and absDelta() methods that give you the change from the previous reading and will always be in sync. Awesome!\n// BEFORE\n#define INPUT1 A1\n#define INPUT2 A2\n\nuint16_t current1, prev1;\nuint16_t current2, prev2;\n\nvoid loop() {\n    prev1 = current1;\n    current1 = analogRead(INPUT1);\n    prev2 = current2;\n    current2 = analogRead(INPUT2);\n\n    if (abs(current1 - prev1) &gt; THRESHOLD)\n        ...\n// AFTER\nAnalogIn input1(A1), input2(A2);\n\nvoid loop() {\n    input1.read();\n    input2.read();\n\n    if (input1.absDelta() &gt; THRESHOLD)\n        ...\n}\nDid you find this tutorial useful? Was is it easy to follow or did I miss something? Let me know in the comments so I can keep improving the blog.\nL'articolo Eloquent pin management: the Pin class proviene da Eloquent Arduino Blog.",
            "date_published": "2019-12-06T17:15:13+01:00",
            "date_modified": "2019-12-17T17:43:22+01:00",
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "eloquent",
                "Eloquent library"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/2019/12/arduino-bounded-waiting/",
            "url": "https://eloquentarduino.github.io/2019/12/arduino-bounded-waiting/",
            "title": "Eloquent bounded waiting: the await construct",
            "content_html": "<p>Sometimes you may need to wait for a certain condition to become true, but you don't want to wait forever: it may be awaiting for Serial, for the Wifi to connect to a network, or the response from a SoftwareSerial peripheral. The <code>await</code> construct lets you put an upper bound to the time you're willing to wait.</p>\n<p><span id=\"more-211\"></span></p>\n<p>Most often, you see example code of this kind:</p>\n<pre><code class=\"language-cpp\">Serial.print(&quot;Attempting to connect to WiFi&quot;);\n\nwhile (WiFi.status() != WL_CONNECTED) {\n    Serial.print(&quot;.&quot;);\n    delay(500);\n}</code></pre>\n<p>If the connection doesn't succeed (maybe the AP is out of range or is down), you're stuck in an endless wait. A proper way for handling such situations is with a timeout that gets you out of the loop with an error status so you can handle the failure.<br />\n<code>await</code> is exactly this: a construct to await for a condition to become true until a timeout expires, returning true or false as a response.</p>\n<h3>Definition</h3>\n<pre><code class=\"language-cpp\">#define await(condition, timeout) await_with_interval(condition, timeout, 10)\n#define await_with_interval(condition, timeout, interval) \\\n  ([]() { \\\n    uint32_t start = millis(); \\\n    while (millis() - start &lt;= timeout) { \\\n      if (condition) return true; \\\n      delay(interval); \\\n    } \\\n  return false; })()</code></pre>\n<h3>How to use</h3>\n<p><code>await</code> needs at least two arguments:</p>\n<ol>\n<li>the condition to await for</li>\n<li>the timeout, in milliseconds</li>\n</ol>\n<pre><code>// these are for greater code readability\r\n#define Millis \r\n#define Second  *1000\r\n#define Seconds *1000\r\n</code></pre>\n<pre><code class=\"language-cpp\">bool wifiConnected = await(WiFi.status() == WL_CONNECTED, 10 Seconds)</code></pre>\n<p>The code above will wait 10 seconds for the wifi to connect: on failure, <code>wifiConnected</code> will be false and you can gently fail. </p>\n<p>You can use it for any kind of check, like waiting for <code>Serial</code>.</p>\n<pre><code class=\"language-cpp\">bool serialReady = await(Serial, 5 Seconds)\nbool serialHasCharacters = await(Serial.available(), 5 Seconds)</code></pre>\n<p>The default interval between checks is 10 milliseconds: if you need a custom delay interval you can use the more verbose <code>await_with_interval</code>:</p>\n<pre><code class=\"language-cpp\">// await WiFi for 10 seconds, check if connected every 500 millis\nbool wifiConnected = await_with_interval(WiFi.status() == WL_CONNECTED, 10 Seconds, 500 Millis)</code></pre>\n<h3>How it works</h3>\n<p>The <code>await</code> macro creates an <a href=\"http://www.cplusplus.com/articles/2LywvCM9/\">inline function</a> that loops until the timeout expires. At every loop it checks if the condition is true: if that's the case, it returns true. The inline function construct is needed to get a return value, so you can assign it to a variable or embed directly inside an <code>if</code> test. The following code sample gives you an idea of what's happening.</p>\n<pre><code class=\"language-cpp\">bool wifiConnected = await(WiFi.status() == WL_CONNECTED, 10 Seconds)\n\n// conceptually translates to\n\nbool inline_function() {\n    uint32_t start = millis();\n\n    while (millis() - start &lt;= 10000) {\n      if (WiFi.status() == WL_CONNECTED)\n        return true;\n\n      delay(10);\n    }\n\n   return false;\n}\n\nbool wifiConnected = inline_function();</code></pre>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2019/12/arduino-bounded-waiting/\">Eloquent bounded waiting: the await construct</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Sometimes you may need to wait for a certain condition to become true, but you don't want to wait forever: it may be awaiting for Serial, for the Wifi to connect to a network, or the response from a SoftwareSerial peripheral. The await construct lets you put an upper bound to the time you're willing to wait.\n\nMost often, you see example code of this kind:\nSerial.print(&quot;Attempting to connect to WiFi&quot;);\n\nwhile (WiFi.status() != WL_CONNECTED) {\n    Serial.print(&quot;.&quot;);\n    delay(500);\n}\nIf the connection doesn't succeed (maybe the AP is out of range or is down), you're stuck in an endless wait. A proper way for handling such situations is with a timeout that gets you out of the loop with an error status so you can handle the failure.\nawait is exactly this: a construct to await for a condition to become true until a timeout expires, returning true or false as a response.\nDefinition\n#define await(condition, timeout) await_with_interval(condition, timeout, 10)\n#define await_with_interval(condition, timeout, interval) \\\n  ([]() { \\\n    uint32_t start = millis(); \\\n    while (millis() - start &lt;= timeout) { \\\n      if (condition) return true; \\\n      delay(interval); \\\n    } \\\n  return false; })()\nHow to use\nawait needs at least two arguments:\n\nthe condition to await for\nthe timeout, in milliseconds\n\n// these are for greater code readability\r\n#define Millis \r\n#define Second  *1000\r\n#define Seconds *1000\r\n\nbool wifiConnected = await(WiFi.status() == WL_CONNECTED, 10 Seconds)\nThe code above will wait 10 seconds for the wifi to connect: on failure, wifiConnected will be false and you can gently fail. \nYou can use it for any kind of check, like waiting for Serial.\nbool serialReady = await(Serial, 5 Seconds)\nbool serialHasCharacters = await(Serial.available(), 5 Seconds)\nThe default interval between checks is 10 milliseconds: if you need a custom delay interval you can use the more verbose await_with_interval:\n// await WiFi for 10 seconds, check if connected every 500 millis\nbool wifiConnected = await_with_interval(WiFi.status() == WL_CONNECTED, 10 Seconds, 500 Millis)\nHow it works\nThe await macro creates an inline function that loops until the timeout expires. At every loop it checks if the condition is true: if that's the case, it returns true. The inline function construct is needed to get a return value, so you can assign it to a variable or embed directly inside an if test. The following code sample gives you an idea of what's happening.\nbool wifiConnected = await(WiFi.status() == WL_CONNECTED, 10 Seconds)\n\n// conceptually translates to\n\nbool inline_function() {\n    uint32_t start = millis();\n\n    while (millis() - start &lt;= 10000) {\n      if (WiFi.status() == WL_CONNECTED)\n        return true;\n\n      delay(10);\n    }\n\n   return false;\n}\n\nbool wifiConnected = inline_function();\nL'articolo Eloquent bounded waiting: the await construct proviene da Eloquent Arduino Blog.",
            "date_published": "2019-12-05T19:50:59+01:00",
            "date_modified": "2019-12-16T23:03:25+01:00",
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "eloquent",
                "Eloquent library"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/2019/12/non-blocking-arduino-code/",
            "url": "https://eloquentarduino.github.io/2019/12/non-blocking-arduino-code/",
            "title": "Eloquent non-blocking code: the Every construct",
            "content_html": "<p>The <code>every</code> construct lets you run a piace of code at regular intervals in a fluent way. If you don't need to start, stop, pause your timer, this construct is a valid alternative to more complex timer libraries already available: it only takes a time interval as argument and will execute the code block periodically.</p>\n<p><span id=\"more-209\"></span></p>\n<h3>Definition</h3>\n<pre><code class=\"language-cpp\">#define every(interval) \\\n    static uint32_t __every__##interval = millis(); \\\n    if (millis() - __every__##interval &gt;= interval &amp;&amp; (__every__##interval = millis()))</code></pre>\n<h3>How to use</h3>\n<pre><code>// these are for greater code readability\r\n#define Millis \r\n#define Second  *1000\r\n#define Seconds *1000\r\n</code></pre>\n<pre><code class=\"language-cpp\">int interval = 1 Second;\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\nvoid loop() {\n    every(1000 Millis) {\n        Serial.println(&quot;This line is printed every 1 second&quot;);\n    }\n\n    every(2000 Millis) {\n        Serial.println(&quot;This line is printed every 2 seconds&quot;);\n    }\n\n    every(interval) {\n        interval += 1 Second;\n        Serial.print(&quot;You can have variable intervals too! &quot;);\n        Serial.print(&quot;This line will be printed again in &quot;);\n        Serial.print(interval / 1000);\n        Serial.println(&quot; seconds&quot;);\n    }\n}</code></pre>\n<h3>Caveats</h3>\n<p><code>every</code> is just a macro definition and is not a proper timer, so it has some limitations:</p>\n<ol>\n<li>you can't stop, pause or resume it: once set, it will run forever</li>\n<li>its argument must be the suffix of a valid identifier</li>\n<li>you can't use several <code>every</code> with the exact same argument: you have to put all the code that needs to happen at the same interval in the same block</li>\n</ol>\n<h4>Caveat #2</h4>\n<p>The macro works by generating a variable named like <code>__every__##argument</code></p>\n<pre><code class=\"language-cpp\">every(1) ==&gt; uint32_t __every__1;\nevery(2) ==&gt; uint32_t __every__2;\nevery(a_given_interval) ==&gt; uint32_t __every__a_given_interval;\nevery(an invalid interval) ==&gt; uint32_t __every__an invalid interval; // Syntax error\nevery(1 Second) ==&gt; uint32_t __every__1 *1000; // Syntax error</code></pre>\n<p>So every integer literal and any variable are all valid arguments. Any expression is forbidden.</p>\n<h4>Caveat #3</h4>\n<p>If you use two <code>every</code> with the exact same argument, two variables with the exact same name will be created and it will rise a compile-time error.</p>\n<p>If you can live with this limitations, <code>every</code> only needs the space of an <code>uint32_t</code> to work.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2019/12/non-blocking-arduino-code/\">Eloquent non-blocking code: the Every construct</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "The every construct lets you run a piace of code at regular intervals in a fluent way. If you don't need to start, stop, pause your timer, this construct is a valid alternative to more complex timer libraries already available: it only takes a time interval as argument and will execute the code block periodically.\n\nDefinition\n#define every(interval) \\\n    static uint32_t __every__##interval = millis(); \\\n    if (millis() - __every__##interval &gt;= interval &amp;&amp; (__every__##interval = millis()))\nHow to use\n// these are for greater code readability\r\n#define Millis \r\n#define Second  *1000\r\n#define Seconds *1000\r\n\nint interval = 1 Second;\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\nvoid loop() {\n    every(1000 Millis) {\n        Serial.println(&quot;This line is printed every 1 second&quot;);\n    }\n\n    every(2000 Millis) {\n        Serial.println(&quot;This line is printed every 2 seconds&quot;);\n    }\n\n    every(interval) {\n        interval += 1 Second;\n        Serial.print(&quot;You can have variable intervals too! &quot;);\n        Serial.print(&quot;This line will be printed again in &quot;);\n        Serial.print(interval / 1000);\n        Serial.println(&quot; seconds&quot;);\n    }\n}\nCaveats\nevery is just a macro definition and is not a proper timer, so it has some limitations:\n\nyou can't stop, pause or resume it: once set, it will run forever\nits argument must be the suffix of a valid identifier\nyou can't use several every with the exact same argument: you have to put all the code that needs to happen at the same interval in the same block\n\nCaveat #2\nThe macro works by generating a variable named like __every__##argument\nevery(1) ==&gt; uint32_t __every__1;\nevery(2) ==&gt; uint32_t __every__2;\nevery(a_given_interval) ==&gt; uint32_t __every__a_given_interval;\nevery(an invalid interval) ==&gt; uint32_t __every__an invalid interval; // Syntax error\nevery(1 Second) ==&gt; uint32_t __every__1 *1000; // Syntax error\nSo every integer literal and any variable are all valid arguments. Any expression is forbidden.\nCaveat #3\nIf you use two every with the exact same argument, two variables with the exact same name will be created and it will rise a compile-time error.\nIf you can live with this limitations, every only needs the space of an uint32_t to work.\nL'articolo Eloquent non-blocking code: the Every construct proviene da Eloquent Arduino Blog.",
            "date_published": "2019-12-05T19:42:45+01:00",
            "date_modified": "2019-12-16T22:59:36+01:00",
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "eloquent",
                "Eloquent library"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/2019/11/how-to-write-clean-arduino-code/",
            "url": "https://eloquentarduino.github.io/2019/11/how-to-write-clean-arduino-code/",
            "title": "How to write clean Arduino code: introducing the Eloquent library",
            "content_html": "<p>Eloquent Arduino is an attempt to bring sanity and clarity in Arduino projects.\u00a0The purpose of this library is to create a wide range of constructs to clearly translate your ideas into meaningful code: <strong>stop writing spaghetti code</strong>  only you can undestand, please! I'll show you how.</p>\n<p><span id=\"more-164\"></span></p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2019/11/CleanCode.jpg\" alt=\"from https://www.wlion.com/blog/5-reasons-you-should-be-writing-clean-code/\" /></p>\n<h2>The problem</h2>\n<p>Arduino sells itself as a platform well suited for beginners, and it is for sure; lots of non-tech people are able to bring their ideas to life thanks to this awesome platform.<br />\nNevertheless, I often stumble upon bits of code over the internet that make me question about the quality of the projects people are producing. </p>\n<p>Even the Arduino official website is misleading in this sense, in my opinion, since it promotes a code style really straighforward, but suited for toy projects, with little logics and low complexity level.</p>\n<p>Here's an example of what I'm talking about, copy-pasted from the <a href=\"https://www.arduino.cc/en/tutorial/BlinkWithoutDelay\">Arduino official site</a> (with comments removed):</p>\n<pre><code class=\"language-cpp\">const int ledPin =  LED_BUILTIN;\nint ledState = LOW;\nunsigned long previousMillis = 0; \nconst long interval = 1000; \n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  unsigned long currentMillis = millis();\n\n  if (currentMillis - previousMillis &gt;= interval) {\n    previousMillis = currentMillis;\n\n    if (ledState == LOW) {\n      ledState = HIGH;\n    } else {\n      ledState = LOW;\n    }\n\n    digitalWrite(ledPin, ledState);\n  }\n}</code></pre>\n<p>Can you tell what this code does <strong>with a minimum mental effort</strong>?<br />\nI don't think so (you may have recognized the <em>async pattern</em> and it actually blinks a LED in a non-blocking fashion).</p>\n<p><strong>THIS</strong> is the problem: most Arduino code is not clear at first glance, is not <strong>eloquent</strong>. By eloquent I mean code that speaks by itself, without the need for comments.</p>\n<hr /><p><em>most Arduino code is not clear at first glance, is not eloquent</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F11%2Fhow-to-write-clean-arduino-code%2F&#038;text=most%20Arduino%20code%20is%20not%20clear%20at%20first%20glance%2C%20is%20not%20eloquent&#038;via=ArduinoEloquent&#038;related=ArduinoEloquent' target='_blank' rel=\"noopener noreferrer\" >Click To Tweet</a><br /><hr />\n<h2>The solution</h2>\n<p>What about the following?</p>\n<pre><code class=\"language-cpp\">DigitalOut led(LED_BUILTIN);\n\nvoid setup() {\n    led.begin();\n}\n\nvoid loop() {\n    every(1 Second) {\n        led.toggle();\n    }\n}</code></pre>\n<p>I swear this is valid code that compiles just fine. Hopefully, it does the exact same thing as above, yet it is far more readable and understandable. </p>\n<p>Can you see my point now? Wouldn't it be much easier and reliable to code with the help of a set of such eloquent constructs / interfaces? I strongly believe it is, and this is why I'm writing this library.<br />\nAsynchronous programming, pin state managements, animations are bits of code that pop up over and over again in most of the projects, yet every time we start from zero and write the same boilerplate code over and over again.</p>\n<hr /><p><em>Boilerplate code is not only tedious, but error-prone. And lengthy. Start writing eloquent code now!</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F11%2Fhow-to-write-clean-arduino-code%2F&#038;text=Boilerplate%20code%20is%20not%20only%20tedious%2C%20but%20error-prone.%20And%20lengthy.%20Start%20writing%20eloquent%20code%20now%21&#038;via=ArduinoEloquent&#038;related=ArduinoEloquent' target='_blank' rel=\"noopener noreferrer\" >Click To Tweet</a><br /><hr />\n<p>Boilerplate code heavily relies on a fixed structure that could be hard to adapt to your specific case. Longer code means more chances to break something and more code to debug, which can waste lots of your valuable time.</p>\n<hr />\n<p>I'm starting a series of posts where I'll document some of the classes and constructs the library provides to you. You can find the code on the <a href=\"https://github.com/eloquentarduino/EloquentArduino\">Github repo</a>.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2019/11/how-to-write-clean-arduino-code/\">How to write clean Arduino code: introducing the Eloquent library</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Eloquent Arduino is an attempt to bring sanity and clarity in Arduino projects.\u00a0The purpose of this library is to create a wide range of constructs to clearly translate your ideas into meaningful code: stop writing spaghetti code  only you can undestand, please! I'll show you how.\n\n\nThe problem\nArduino sells itself as a platform well suited for beginners, and it is for sure; lots of non-tech people are able to bring their ideas to life thanks to this awesome platform.\nNevertheless, I often stumble upon bits of code over the internet that make me question about the quality of the projects people are producing. \nEven the Arduino official website is misleading in this sense, in my opinion, since it promotes a code style really straighforward, but suited for toy projects, with little logics and low complexity level.\nHere's an example of what I'm talking about, copy-pasted from the Arduino official site (with comments removed):\nconst int ledPin =  LED_BUILTIN;\nint ledState = LOW;\nunsigned long previousMillis = 0; \nconst long interval = 1000; \n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  unsigned long currentMillis = millis();\n\n  if (currentMillis - previousMillis &gt;= interval) {\n    previousMillis = currentMillis;\n\n    if (ledState == LOW) {\n      ledState = HIGH;\n    } else {\n      ledState = LOW;\n    }\n\n    digitalWrite(ledPin, ledState);\n  }\n}\nCan you tell what this code does with a minimum mental effort?\nI don't think so (you may have recognized the async pattern and it actually blinks a LED in a non-blocking fashion).\nTHIS is the problem: most Arduino code is not clear at first glance, is not eloquent. By eloquent I mean code that speaks by itself, without the need for comments.\nmost Arduino code is not clear at first glance, is not eloquentClick To Tweet\nThe solution\nWhat about the following?\nDigitalOut led(LED_BUILTIN);\n\nvoid setup() {\n    led.begin();\n}\n\nvoid loop() {\n    every(1 Second) {\n        led.toggle();\n    }\n}\nI swear this is valid code that compiles just fine. Hopefully, it does the exact same thing as above, yet it is far more readable and understandable. \nCan you see my point now? Wouldn't it be much easier and reliable to code with the help of a set of such eloquent constructs / interfaces? I strongly believe it is, and this is why I'm writing this library.\nAsynchronous programming, pin state managements, animations are bits of code that pop up over and over again in most of the projects, yet every time we start from zero and write the same boilerplate code over and over again.\nBoilerplate code is not only tedious, but error-prone. And lengthy. Start writing eloquent code now!Click To Tweet\nBoilerplate code heavily relies on a fixed structure that could be hard to adapt to your specific case. Longer code means more chances to break something and more code to debug, which can waste lots of your valuable time.\n\nI'm starting a series of posts where I'll document some of the classes and constructs the library provides to you. You can find the code on the Github repo.\nL'articolo How to write clean Arduino code: introducing the Eloquent library proviene da Eloquent Arduino Blog.",
            "date_published": "2019-11-03T17:05:46+01:00",
            "date_modified": "2019-12-22T14:40:10+01:00",
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "eloquent",
                "Eloquent library"
            ]
        }
    ]
}