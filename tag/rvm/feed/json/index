{
    "version": "https://jsonfeed.org/version/1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/tag/rvm/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/tag/rvm/",
    "feed_url": "https://eloquentarduino.github.io/tag/rvm/feed/json/",
    "title": "Eloquent Arduino Blog",
    "description": "Machine learning on Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/2020/02/even-smaller-machine-learning-models-for-your-mcu/",
            "url": "https://eloquentarduino.github.io/2020/02/even-smaller-machine-learning-models-for-your-mcu/",
            "title": "Even smaller Machine learning models for your MCU: up to -82% code size",
            "content_html": "<p>So far we've used SVM (Support Vector Machine) as our main classifier to port a Machine learning model to a microcontroller: but recently I found an interesting alternative which could be waaaay smaller, mantaining a similar accuracy.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/02/rvm.jpg\" alt=\"RVM vs SVM support vectors\" /></p>\n<p><span id=\"more-893\"></span></p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tocthe-current-state\">The current state</a><li><a href=\"#toca-new-algorithm-relevance-vector-machines\">A new algorithm: Relevance Vector Machines</a><li><a href=\"#toctraining-a-classifier\">Training a classifier</a><li><a href=\"#tocporting-to-c\">Porting to C</a><li><a href=\"#tocperformace-comparison\">Performace comparison</a><li><a href=\"#tocsize-comparison\">Size comparison</a><li><a href=\"#tocdisclaimer\">Disclaimer</a></ol></div></p>\n<h2 id=\"tocthe-current-state\">The current state</h2>\n<p>I chose SVM as my main focus of intereset for the MicroML framework because I knew the support vector encoding could be very memory efficient once ported to plain C. And it really is.</p>\n<p>I was able to port many real-world models (gesture identification, wake word detection) to tiny microcontrollers like the old Arduino Nano (32 kb flash, 2 kb RAM).</p>\n<p>The tradeoff of my implementation was to sacrifice the flash space (which is usually quite big) to save as much RAM as possible, which is usually the most limiting factor.</p>\n<p>Due to this implementation, if your model grows in size (highly dimensional data or not well separable data), the generated code will still fit in the RAM, but &quot;overflow&quot; the available flash.</p>\n<p>In a couple of my previous post I warned that model selection might be a required step before being able to deploy a model to a MCU, since you should first check if it fits. If not, you must train another model hoping to get fewer support vectors, since each of them contributes to the code size increase.</p>\n<h2 id=\"toca-new-algorithm-relevance-vector-machines\">A new algorithm: Relevance Vector Machines</h2>\n<p>It was by chance that I came across a new algorithm that I never heard of, called <a href=\"https://en.wikipedia.org/wiki/Relevance_vector_machine\">Relevance Vector Machine</a>. It was patented by Microsoft until last year (so maybe this is the reason you don't see it in the wild), but now it is free of use as far as I can tell.</p>\n<p>Here is the <a href=\"https://papers.nips.cc/paper/1719-the-relevance-vector-machine.pdf\">link</a> to the paper if you want to read it, it gives some insights into the development process.</p>\n<p>I'm not a mathematician, so I can't describe it accurately, but in a few words it uses the same formulation of SVM (a weightened sum of kernels), applying a Bayesan model.</p>\n<p>This serves in the first place to be able to get the probabilities of the classification results, which is something totally missing in SVM.</p>\n<p>In the second place, the algorithm tries to learn a much more sparse representation of the support vectors, as you can see in the following picture.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/02/rvm.jpg\" alt=\"RVM vs SVM support vectors\" /></p>\n<p>When I first read the paper my first tought was just &quot;wow&quot;! This is exactly what I need for my MicroML framework: a ultra-lightweight model which can still achieve high accuracy.</p>\n<h2 id=\"toctraining-a-classifier\">Training a classifier</h2>\n<p>Now that I knew this algorithm, I searched for it in the <code>sklearn</code> documentation: it was not there.</p>\n<p>It seems that, since it was patented, they didn't have an implementation.</p>\n<p>Fortunately, there is <a href=\"https://github.com/AmazaspShumik/sklearn_bayes/\">an implementation</a> which follows the sklearn paradigm. You have to install it:</p>\n<pre><code class=\"language-bash\">pip install Cython\npip install https://github.com/AmazaspShumik/sklearn_bayes/archive/master.zip</code></pre>\n<p>Since the interface is the usual <code>fit</code> <code>predict</code>, it is super easy to train a classifier.</p>\n<pre><code class=\"language-python\">from sklearn.datasets import load_iris\nfrom skbayes.rvm_ard_models import RVC\nimport warnings\n\n# I get tons of boring warnings during training, so turn it off\nwarnings.filterwarnings(&quot;ignore&quot;)\n\niris = load_iris()\nX = iris.data\ny = iris.target\nclf = RVC(kernel=&#039;rbf&#039;, gamma=0.001)\nclf.fit(X, y)\ny_predict = clf.predict(X)</code></pre>\n<p>The parameters for the constructor are similar to those of the <code>SVC</code> classifier from sklearn:</p>\n<ul>\n<li><code>kernel</code>: one of linear, poly, rbf</li>\n<li><code>degree</code>: if <code>kernel=poly</code></li>\n<li><code>gamma</code>: if <code>kernel=poly</code> or <code>kernel=rbf</code></li>\n</ul>\n<p>You can read <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html\">the docs</a> from sklearn to learn more.</p>\n<h2 id=\"tocporting-to-c\">Porting to C</h2>\n<p>Now that we have a trained classifier, we have to port it to plain C that compiles on our microcontroller of choice.</p>\n<p>I patched my package <code>micromlgen</code> to do the job for you, so you should install the latest version to get it working.</p>\n<pre><code class=\"language-bash\"> pip install --upgrade micromlgen</code></pre>\n<p>Now the export part is almost the same as with an SVM classifier.</p>\n<pre><code class=\"language-python\"> from micromlgen import port_rvm\n\n clf = get_rvm_classifier()\n c_code = port_rvm(clf)\n print(c_code)</code></pre>\n<p>And you're done: you have plain C code you can embed in any microcontroller.</p>\n<h2 id=\"tocperformace-comparison\">Performace comparison</h2>\n<p>To test the effectiveness of this new algorithm, I applied it to the datasets I built in my previous posts, comparing side by side the size and accuracy of both SVM and RVM.</p>\n<p>The results are summarized in the next table.</p>\n<style>\n.dataset th+th, .dataset td + td { text-align: center; }\n.dataset small { display: block; font-size: 0.8em; }\n.dataset .__h td {background: blanchedalmond !important}\n</style>\n<table class=\"dataset\">\n<thead>\n<tr>\n<th>Dataset</th>\n<th colspan=\"2\">SVM</th>\n<th colspan=\"2\">RVM</th>\n<th colspan=\"2\">Delta</th>\n</tr>\n<tr>\n<th></th>\n<th>Flash<small>(byte)</small></th>\n<th>Acc. <small>(%)</small></th>\n<th>Flash<small>(byte)</small></th>\n<th>Acc. <small>(%)</small></th>\n<th>Flash</th>\n<th>Acc.</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RGB colors</td>\n<td>4584</td>\n<td>100</td>\n<td>3580</td>\n<td>100</td>\n<td>-22%</td>\n<td>-0%</td>\n</tr>\n<tr>\n<td>Accelerometer gestures<small>(linear kernel)</small></td>\n<td>36888</td>\n<td>92</td>\n<td>7056</td>\n<td>85</td>\n<td>-80%</td>\n<td>-7%</td>\n</tr>\n<tr class=\"__h\">\n<td>Accelerometer gestures<small>(gaussian kernel)</small></td>\n<td>45348</td>\n<td>95</td>\n<td>7766</td>\n<td>95</td>\n<td>-82%</td>\n<td>-0%</td>\n</tr>\n<tr>\n<td>Wifi positioning</td>\n<td>4641</td>\n<td>100</td>\n<td>3534</td>\n<td>100</td>\n<td>-24%</td>\n<td>-0%</td>\n</tr>\n<tr>\n<td>Wake word<small>(linear kernel)</small></td>\n<td>18098</td>\n<td>86</td>\n<td>3602</td>\n<td>53</td>\n<td>-80%</td>\n<td>-33%</td>\n</tr>\n<tr>\n<td>Wake word<small>(gaussian kernel)</small></td>\n<td>21788</td>\n<td>90</td>\n<td>4826</td>\n<td>62</td>\n<td>-78%</td>\n<td>-28%</td>\n</tr>\n</tbody>\n</table>\n<p><small style=\"font-style: italic; font-size: 0.8em;\">** the accuracy reported are with default parameters, without any tuning, averaged in 30 runs</small></p>\n<p>As you may see, the results are quite surpising:</p>\n<ul>\n<li>you can achieve <strong>up to 82% space reduction</strong> on highly dimensional dataset <strong>without any loss in accuracy</strong> (accelerometer gestures with gaussian kernel)</li>\n<li>sometimes you may not be able to achieve a decent accuracy (62% at most on the wake word dataset)</li>\n</ul>\n<p>As in any situation, you should test which one of the two algorithms works best for your use case, but there a couple of guidelines you may follow:</p>\n<ul>\n<li>if you need top accuracy, probably SVM can achieve slighter better performance if you have enough space</li>\n<li>if you need tiny space or top speed, test if RVM achieves a satisfiable accuracy</li>\n<li>if both SVM and RVM achieve comparable performace, go with RVM: it's much lighter than SVM in most cases and will run faster</li>\n</ul>\n<h2 id=\"tocsize-comparison\">Size comparison</h2>\n<p>As a reference, here is the codes generated for an SVM classifier and an RVM one to classify the IRIS dataset.</p>\n<pre><code class=\"language-c\">uint8_t predict_rvm(double *x) {\n    double decision[3] = { 0 };\n    decision[0] = -0.6190847299428206;\n    decision[1] = (compute_kernel(x,  6.3, 3.3, 6.0, 2.5) - 72.33233 ) * 0.228214 + -2.3609625;\n    decision[2] = (compute_kernel(x,  7.7, 2.8, 6.7, 2.0) - 81.0089166 ) * -0.29006 + -3.360963;\n    uint8_t idx = 0;\n    double val = decision[0];\n    for (uint8_t i = 1; i &lt; 3; i++) {\n        if (decision[i] &gt; val) {\n            idx = i;\n            val = decision[i];\n        }\n    }\n    return idx;\n}\n\nint predict_svm(double *x) {\n    double kernels[10] = { 0 };\n    double decisions[3] = { 0 };\n    int votes[3] = { 0 };\n        kernels[0] = compute_kernel(x,   6.7  , 3.0  , 5.0  , 1.7 );\n        kernels[1] = compute_kernel(x,   6.0  , 2.7  , 5.1  , 1.6 );\n        kernels[2] = compute_kernel(x,   5.1  , 2.5  , 3.0  , 1.1 );\n        kernels[3] = compute_kernel(x,   6.0  , 3.0  , 4.8  , 1.8 );\n        kernels[4] = compute_kernel(x,   7.2  , 3.0  , 5.8  , 1.6 );\n        kernels[5] = compute_kernel(x,   4.9  , 2.5  , 4.5  , 1.7 );\n        kernels[6] = compute_kernel(x,   6.2  , 2.8  , 4.8  , 1.8 );\n        kernels[7] = compute_kernel(x,   6.0  , 2.2  , 5.0  , 1.5 );\n        kernels[8] = compute_kernel(x,   4.8  , 3.4  , 1.9  , 0.2 );\n        kernels[9] = compute_kernel(x,   5.1  , 3.3  , 1.7  , 0.5 );\n        decisions[0] = 20.276395502\n                    + kernels[0] * 100.0\n                    + kernels[1] * 100.0\n                    + kernels[3] * -79.351629954\n                    + kernels[4] * -49.298850195\n                    + kernels[6] * -40.585178082\n                    + kernels[7] * -30.764341769\n        ;\n        decisions[1] = -0.903345464\n                    + kernels[2] * 0.743494115\n                    + kernels[9] * -0.743494115\n        ;\n        decisions[2] = -1.507856504\n                    + kernels[5] * 0.203695177\n                    + kernels[8] * -0.160020702\n                    + kernels[9] * -0.043674475\n        ;\n        votes[decisions[0] &gt; 0 ? 0 : 1] += 1;\n        votes[decisions[1] &gt; 0 ? 0 : 2] += 1;\n        votes[decisions[2] &gt; 0 ? 1 : 2] += 1;\n                int classVal = -1;\n        int classIdx = -1;\n        for (int i = 0; i &lt; 3; i++) {\n            if (votes[i] &gt; classVal) {\n                classVal = votes[i];\n                classIdx = i;\n            }\n        }\n        return classIdx;\n}</code></pre>\n<p>As you can see, RVM actually only computes 2 kernels and does 2 multiplications. SVM, on the other hand, computes 10 kernels and does 13 multiplications.</p>\n<p>This is a recurring pattern, so RVM is much much faster in the inference process.</p>\n<h2 id=\"tocdisclaimer\">Disclaimer</h2>\n<p><code>micromlgen</code> and in particular <code>port_rvm</code> are work in progress: you may experience some glitches or it may not work in your specific case. Please report any issue <a href=\"https://github.com/eloquentarduino/micromlgen\">on the Github repo</a>.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/02/even-smaller-machine-learning-models-for-your-mcu/\">Even smaller Machine learning models for your MCU: up to -82% code size</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "So far we've used SVM (Support Vector Machine) as our main classifier to port a Machine learning model to a microcontroller: but recently I found an interesting alternative which could be waaaay smaller, mantaining a similar accuracy.\n\n\nTable of contentsThe current stateA new algorithm: Relevance Vector MachinesTraining a classifierPorting to CPerformace comparisonSize comparisonDisclaimer\nThe current state\nI chose SVM as my main focus of intereset for the MicroML framework because I knew the support vector encoding could be very memory efficient once ported to plain C. And it really is.\nI was able to port many real-world models (gesture identification, wake word detection) to tiny microcontrollers like the old Arduino Nano (32 kb flash, 2 kb RAM).\nThe tradeoff of my implementation was to sacrifice the flash space (which is usually quite big) to save as much RAM as possible, which is usually the most limiting factor.\nDue to this implementation, if your model grows in size (highly dimensional data or not well separable data), the generated code will still fit in the RAM, but &quot;overflow&quot; the available flash.\nIn a couple of my previous post I warned that model selection might be a required step before being able to deploy a model to a MCU, since you should first check if it fits. If not, you must train another model hoping to get fewer support vectors, since each of them contributes to the code size increase.\nA new algorithm: Relevance Vector Machines\nIt was by chance that I came across a new algorithm that I never heard of, called Relevance Vector Machine. It was patented by Microsoft until last year (so maybe this is the reason you don't see it in the wild), but now it is free of use as far as I can tell.\nHere is the link to the paper if you want to read it, it gives some insights into the development process.\nI'm not a mathematician, so I can't describe it accurately, but in a few words it uses the same formulation of SVM (a weightened sum of kernels), applying a Bayesan model.\nThis serves in the first place to be able to get the probabilities of the classification results, which is something totally missing in SVM.\nIn the second place, the algorithm tries to learn a much more sparse representation of the support vectors, as you can see in the following picture.\n\nWhen I first read the paper my first tought was just &quot;wow&quot;! This is exactly what I need for my MicroML framework: a ultra-lightweight model which can still achieve high accuracy.\nTraining a classifier\nNow that I knew this algorithm, I searched for it in the sklearn documentation: it was not there.\nIt seems that, since it was patented, they didn't have an implementation.\nFortunately, there is an implementation which follows the sklearn paradigm. You have to install it:\npip install Cython\npip install https://github.com/AmazaspShumik/sklearn_bayes/archive/master.zip\nSince the interface is the usual fit predict, it is super easy to train a classifier.\nfrom sklearn.datasets import load_iris\nfrom skbayes.rvm_ard_models import RVC\nimport warnings\n\n# I get tons of boring warnings during training, so turn it off\nwarnings.filterwarnings(&quot;ignore&quot;)\n\niris = load_iris()\nX = iris.data\ny = iris.target\nclf = RVC(kernel=&#039;rbf&#039;, gamma=0.001)\nclf.fit(X, y)\ny_predict = clf.predict(X)\nThe parameters for the constructor are similar to those of the SVC classifier from sklearn:\n\nkernel: one of linear, poly, rbf\ndegree: if kernel=poly\ngamma: if kernel=poly or kernel=rbf\n\nYou can read the docs from sklearn to learn more.\nPorting to C\nNow that we have a trained classifier, we have to port it to plain C that compiles on our microcontroller of choice.\nI patched my package micromlgen to do the job for you, so you should install the latest version to get it working.\n pip install --upgrade micromlgen\nNow the export part is almost the same as with an SVM classifier.\n from micromlgen import port_rvm\n\n clf = get_rvm_classifier()\n c_code = port_rvm(clf)\n print(c_code)\nAnd you're done: you have plain C code you can embed in any microcontroller.\nPerformace comparison\nTo test the effectiveness of this new algorithm, I applied it to the datasets I built in my previous posts, comparing side by side the size and accuracy of both SVM and RVM.\nThe results are summarized in the next table.\n\n\n\n\nDataset\nSVM\nRVM\nDelta\n\n\n\nFlash(byte)\nAcc. (%)\nFlash(byte)\nAcc. (%)\nFlash\nAcc.\n\n\n\n\nRGB colors\n4584\n100\n3580\n100\n-22%\n-0%\n\n\nAccelerometer gestures(linear kernel)\n36888\n92\n7056\n85\n-80%\n-7%\n\n\nAccelerometer gestures(gaussian kernel)\n45348\n95\n7766\n95\n-82%\n-0%\n\n\nWifi positioning\n4641\n100\n3534\n100\n-24%\n-0%\n\n\nWake word(linear kernel)\n18098\n86\n3602\n53\n-80%\n-33%\n\n\nWake word(gaussian kernel)\n21788\n90\n4826\n62\n-78%\n-28%\n\n\n\n** the accuracy reported are with default parameters, without any tuning, averaged in 30 runs\nAs you may see, the results are quite surpising:\n\nyou can achieve up to 82% space reduction on highly dimensional dataset without any loss in accuracy (accelerometer gestures with gaussian kernel)\nsometimes you may not be able to achieve a decent accuracy (62% at most on the wake word dataset)\n\nAs in any situation, you should test which one of the two algorithms works best for your use case, but there a couple of guidelines you may follow:\n\nif you need top accuracy, probably SVM can achieve slighter better performance if you have enough space\nif you need tiny space or top speed, test if RVM achieves a satisfiable accuracy\nif both SVM and RVM achieve comparable performace, go with RVM: it's much lighter than SVM in most cases and will run faster\n\nSize comparison\nAs a reference, here is the codes generated for an SVM classifier and an RVM one to classify the IRIS dataset.\nuint8_t predict_rvm(double *x) {\n    double decision[3] = { 0 };\n    decision[0] = -0.6190847299428206;\n    decision[1] = (compute_kernel(x,  6.3, 3.3, 6.0, 2.5) - 72.33233 ) * 0.228214 + -2.3609625;\n    decision[2] = (compute_kernel(x,  7.7, 2.8, 6.7, 2.0) - 81.0089166 ) * -0.29006 + -3.360963;\n    uint8_t idx = 0;\n    double val = decision[0];\n    for (uint8_t i = 1; i &lt; 3; i++) {\n        if (decision[i] &gt; val) {\n            idx = i;\n            val = decision[i];\n        }\n    }\n    return idx;\n}\n\nint predict_svm(double *x) {\n    double kernels[10] = { 0 };\n    double decisions[3] = { 0 };\n    int votes[3] = { 0 };\n        kernels[0] = compute_kernel(x,   6.7  , 3.0  , 5.0  , 1.7 );\n        kernels[1] = compute_kernel(x,   6.0  , 2.7  , 5.1  , 1.6 );\n        kernels[2] = compute_kernel(x,   5.1  , 2.5  , 3.0  , 1.1 );\n        kernels[3] = compute_kernel(x,   6.0  , 3.0  , 4.8  , 1.8 );\n        kernels[4] = compute_kernel(x,   7.2  , 3.0  , 5.8  , 1.6 );\n        kernels[5] = compute_kernel(x,   4.9  , 2.5  , 4.5  , 1.7 );\n        kernels[6] = compute_kernel(x,   6.2  , 2.8  , 4.8  , 1.8 );\n        kernels[7] = compute_kernel(x,   6.0  , 2.2  , 5.0  , 1.5 );\n        kernels[8] = compute_kernel(x,   4.8  , 3.4  , 1.9  , 0.2 );\n        kernels[9] = compute_kernel(x,   5.1  , 3.3  , 1.7  , 0.5 );\n        decisions[0] = 20.276395502\n                    + kernels[0] * 100.0\n                    + kernels[1] * 100.0\n                    + kernels[3] * -79.351629954\n                    + kernels[4] * -49.298850195\n                    + kernels[6] * -40.585178082\n                    + kernels[7] * -30.764341769\n        ;\n        decisions[1] = -0.903345464\n                    + kernels[2] * 0.743494115\n                    + kernels[9] * -0.743494115\n        ;\n        decisions[2] = -1.507856504\n                    + kernels[5] * 0.203695177\n                    + kernels[8] * -0.160020702\n                    + kernels[9] * -0.043674475\n        ;\n        votes[decisions[0] &gt; 0 ? 0 : 1] += 1;\n        votes[decisions[1] &gt; 0 ? 0 : 2] += 1;\n        votes[decisions[2] &gt; 0 ? 1 : 2] += 1;\n                int classVal = -1;\n        int classIdx = -1;\n        for (int i = 0; i &lt; 3; i++) {\n            if (votes[i] &gt; classVal) {\n                classVal = votes[i];\n                classIdx = i;\n            }\n        }\n        return classIdx;\n}\nAs you can see, RVM actually only computes 2 kernels and does 2 multiplications. SVM, on the other hand, computes 10 kernels and does 13 multiplications.\nThis is a recurring pattern, so RVM is much much faster in the inference process.\nDisclaimer\nmicromlgen and in particular port_rvm are work in progress: you may experience some glitches or it may not work in your specific case. Please report any issue on the Github repo.\nL'articolo Even smaller Machine learning models for your MCU: up to -82% code size proviene da Eloquent Arduino Blog.",
            "date_published": "2020-02-15T17:37:32+01:00",
            "date_modified": "2020-02-17T18:29:21+01:00",
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "rvm",
                "Arduino Machine learning"
            ]
        }
    ]
}