{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/tag/ml/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/tag/ml/",
    "feed_url": "https://eloquentarduino.github.io/tag/ml/feed/json/",
    "language": "en-US",
    "title": "ml &#8211; Eloquent Arduino Blog",
    "description": "Machine learning on Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/?p=1264",
            "url": "https://eloquentarduino.github.io/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/",
            "title": "Decision Tree, Random Forest and XGBoost on Arduino",
            "content_html": "<p>You will be surprised by how much accuracy you can achieve in just a few kylobytes of resources: <strong>Decision Tree, Random Forest and XGBoost (Extreme Gradient Boosting)</strong> are now available on your microcontrollers: highly RAM-optmized implementations for super-fast classification on embedded devices.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/DecisionTree.png\" alt=\"DecisionTree\" /></p>\n<p><span id=\"more-1264\"></span></p>\n<h2>Decision Tree</h2>\n<p><strong>Decision Tree</strong> is without doubt one of the most well-known classification algorithms out there. It is so simple to understand that it was probably the first classifier you encountered in any Machine Learning course.</p>\n<p>I won't go into the details of how a Decision Tree classifier trains and selects the splits for the input features: here I will explain how a RAM-efficient porting of such a classifier is implemented.</p>\n<p>To an introduction visit <a href=\"https://en.wikipedia.org/wiki/Decision_tree_learning\">Wikipedia</a>; for a more in-depth guide visit <a href=\"https://www.kdnuggets.com/2020/01/decision-tree-algorithm-explained.html\">KDNuggets</a>.</p>\n<p>Since we're willing to sacrifice program space (a.k.a flash) in favor of memory (a.k.a RAM), because RAM is the most scarce resource in the vast majority of microcontrollers, the smart way to port a Decision Tree classifier from Python to C is &quot;hard-coding&quot; the splits in code, without keeping any reference to them into variables.</p>\n<p>Here's what it looks like for a Decision tree that classifies the Iris dataset.</p>\n<p>As you can see, we're using <strong>0 bytes of RAM</strong> to get the classification result, since no variable is being allocated. On the other side, the program space will grow almost linearly with the number of splits.</p>\n<p>Since program space is often much greater than RAM on microcontrollers, this implementation exploits its abundance to be able to deploy larger models. How much large? It will depend on the flash size available: many new generations board (Arduino Nano 33 BLE Sense, ESP32, ST Nucleus...) have 1 Mb of flash, which will hold tens of thousands of splits. </p>\n<h2>Random Forest</h2>\n<p><strong><a href=\"https://en.wikipedia.org/wiki/Random_forest\">Random Forest</a></strong> is just many Decision Trees joined together in a voting scheme. The core idea is that of <em>&quot;the wisdom of the corwd&quot;</em>, such that if many trees vote for a given class (having being trained on different subsets of the training set), that class is probably the true class.</p>\n<p><a href=\"https://towardsdatascience.com/understanding-random-forest-58381e0602d2\">Towards Data Science</a> has a more detailed guide on Random Forest and how it balances the trees with the<em>bagging</em> tecnique.</p>\n<p>As easy as Decision Trees, Random Forest gets the exact same implementation with <strong>0 bytes of RAM</strong> required (it actually needs as many bytes as the number of classes to store the votes, but that's really negligible): it just hard-codes all its composing trees.</p>\n<h2>XGBoost (Extreme Gradient Boosting)</h2>\n<p>Extreme Gradient Boosting is <em>&quot;Gradient Boosting on steroids&quot;</em> and has gained much attention from the Machine learning community due to its top results in many data competitions.</p>\n<ol>\n<li>&quot;gradient boosting&quot; refers to the process of chaining a number of trees so that each tree tries to learn from the errors of the previous</li>\n<li>&quot;extreme&quot; refers to many software and hardware optimizations that greatly reduce the time it takes to train the model</li>\n</ol>\n<p>You can read <a href=\"https://www.kdd.org/kdd2016/papers/files/rfp0697-chenAemb.pdf\">the original paper about XGBoost here</a>. For a discursive description head to <a href=\"https://www.kdnuggets.com/2019/05/xgboost-algorithm.html\">KDNuggets</a>, if you want some more math refer to <a href=\"https://medium.com/@gabrieltseng/gradient-boosting-and-xgboost-c306c1bcfaf5\">this blog post on Medium</a>.</p>\n<h2>Porting to plain C</h2>\n<p>If you followed my earlier posts on <a href=\"/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">Gaussian Naive Bayes</a>, <a href=\"https://eloquentarduino.github.io/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/\">SEFR</a>, <a href=\"/2020/02/even-smaller-machine-learning-models-for-your-mcu/\">Relevant Vector Machine</a> and <a href=\"/2019/11/you-can-run-machine-learning-on-arduino/\">Support Vector Machines</a>, you already know how to port these new classifiers.</p>\n<p>If you're new, you will need a couple things:</p>\n<ol>\n<li>install the <a href=\"https://pypi.org/project/micromlgen/\">micromlgen</a> package with </li>\n</ol>\n<pre><code class=\"language-bash\">pip install micromlgen</code></pre>\n<ol start=\"2\">\n<li>(optionally, if you want to use Extreme Gradient Boosting) install the <a href=\"https://pypi.org/project/xgboost/\">xgboost</a> package with </li>\n</ol>\n<pre><code class=\"language-bash\">pip install xgboost</code></pre>\n<ol start=\"3\">\n<li>use the <code>micromlgen.port</code> function to generate your plain C code</li>\n</ol>\n<pre><code class=\"language-python\">from micromlgen import port\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n\nclf = DecisionTreeClassifier\nX, y = load_iris(return_X_y=True)\nclf.fit(X, y)\nprint(port(clf))</code></pre>\n<p>You can then copy-past the C code and import it in your sketch.</p>\n<h2>Using in the Arduino sketch</h2>\n<p>Once you have the classifier code, create a new project named <code>TreeClassifierExample</code> and copy the classifier code into a file named <code>DecisionTree.h</code> (or <code>RandomForest.h</code> or <code>XGBoost.h</code> depending on the model you chose).</p>\n<p>The copy the following to the main ino file.</p>\n<pre><code class=\"language-cpp\">#include &quot;DecisionTree.h&quot;\n\nEloquent::ML::Port::DecisionTree clf;\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;Begin&quot;);\n}\n\nvoid loop() {\n    float irisSample[4] = {6.2, 2.8, 4.8, 1.8};\n\n    Serial.print(&quot;Predicted label (you should see &#039;2&#039;: &quot;);\n    Serial.println(clf.predict(irisSample));\n    delay(1000);\n}</code></pre>\n<h2>Bechmarks</h2>\n<p>How do the 3 classifiers compare against each other?</p>\n<p>We will evaluate a few keypoints:</p>\n<ul>\n<li>training time</li>\n<li>accuracy</li>\n<li>needed RAM</li>\n<li>needed Flash</li>\n</ul>\n<p>for each classifier on a variety of datasets. I will report the results for RAM and Flash on the Arduino Nano old generation, so you should consider more the relative figures than the absolute ones.</p>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th style=\"text-align: center;\">Classifier</th>\n<th style=\"text-align: center;\">Training <br />time (s)</th>\n<th style=\"text-align: center;\">Accuracy</th>\n<th style=\"text-align: center;\">RAM <br />(bytes)</th>\n<th style=\"text-align: center;\">Flash <br />(bytes)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Gas Sensor Array Drift Dataset </strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">1,6</td>\n<td style=\"text-align: center;\">0.781 \u00b1 0.12</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">5722</td>\n</tr>\n<tr>\n<td>13910 samples x 128 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">3</td>\n<td style=\"text-align: center;\">0.865 \u00b1 0.083</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">6438</td>\n</tr>\n<tr>\n<td>6 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">18,8</td>\n<td style=\"text-align: center;\"><strong>0.878 \u00b1 0.074</strong></td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">6506</td>\n</tr>\n<tr>\n<td><strong>Gesture Phase Segmentation Dataset</strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">0,1</td>\n<td style=\"text-align: center;\">0.943 \u00b1 0.005</td>\n<td style=\"text-align: center;\">290</td>\n<td style=\"text-align: center;\">5638</td>\n</tr>\n<tr>\n<td>10000 samples x 19 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">0,7</td>\n<td style=\"text-align: center;\"><strong>0.970 \u00b1 0.004</strong></td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6466</td>\n</tr>\n<tr>\n<td>5 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">18,9</td>\n<td style=\"text-align: center;\">0.969 \u00b1 0.003</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6536</td>\n</tr>\n<tr>\n<td><strong>Drive Diagnosis Dataset</strong></td>\n<td style=\"text-align: center;\">Decision Tree</td>\n<td style=\"text-align: center;\">0,6</td>\n<td style=\"text-align: center;\">0.946 \u00b1 0.005</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">5850</td>\n</tr>\n<tr>\n<td>10000 samples x 48 features</td>\n<td style=\"text-align: center;\">Random Forest</td>\n<td style=\"text-align: center;\">2,6</td>\n<td style=\"text-align: center;\"><strong>0.983 \u00b1 0.003</strong></td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6526</td>\n</tr>\n<tr>\n<td>11 classes</td>\n<td style=\"text-align: center;\">XGBoost</td>\n<td style=\"text-align: center;\">68,9</td>\n<td style=\"text-align: center;\">0.977 \u00b1 0.005</td>\n<td style=\"text-align: center;\">306</td>\n<td style=\"text-align: center;\">6698</td>\n</tr>\n</tbody>\n</table>\n<p>* <em>all datasets are taken from the <a href=\"https://archive.ics.uci.edu/ml//datasets.php\">UCI Machine Learning datasets archive</a></em></p>\n<p>I'm collecting more data for a complete benchmark, but in the meantime you can see that both Random Forest and XGBoost are on par: if not that XGBoost takes 5 to 25 times longer to train.</p>\n<p>I've never used XGBoost, so I may be missing some tuning parameters, but for now Random Forest remains my favourite classifier.</p>\n<h2>Code listings</h2>\n<pre><code class=\"language-cpp\">// example IRIS dataset classification with Decision Tree\nint predict(float *x) {\n  if (x[3] &lt;= 0.800000011920929) {\n      return 0;\n  }\n  else {\n      if (x[3] &lt;= 1.75) {\n          if (x[2] &lt;= 4.950000047683716) {\n              if (x[0] &lt;= 5.049999952316284) {\n                  return 1;\n              }\n              else {\n                  return 1;\n              }\n          }\n          else {\n              return 2;\n          }\n      }\n      else {\n          if (x[2] &lt;= 4.950000047683716) {\n              return 2;\n          }\n          else {\n              return 2;\n          }\n      }\n  }\n}</code></pre>\n<pre><code class=\"language-cpp\">// example IRIS dataset classification with Random Forest of 3 trees\n\nint predict(float *x) {\n  uint16_t votes[3] = { 0 };\n\n  // tree #1\n  if (x[0] &lt;= 5.450000047683716) {\n      if (x[1] &lt;= 2.950000047683716) {\n          votes[1] += 1;\n      }\n      else {\n          votes[0] += 1;\n      }\n  }\n  else {\n      if (x[0] &lt;= 6.049999952316284) {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[2] &lt;= 3.549999952316284) {\n                  votes[0] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n      else {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[3] &lt;= 1.449999988079071) {\n                  if (x[0] &lt;= 6.1499998569488525) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #2\n  if (x[0] &lt;= 5.549999952316284) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 3.950000047683716) {\n              votes[1] += 1;\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[3] &lt;= 1.699999988079071) {\n          if (x[1] &lt;= 2.649999976158142) {\n              if (x[3] &lt;= 1.25) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              if (x[2] &lt;= 4.1499998569488525) {\n                  votes[1] += 1;\n              }\n              else {\n                  if (x[0] &lt;= 6.75) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n          }\n      }\n      else {\n          if (x[0] &lt;= 6.0) {\n              votes[2] += 1;\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #3\n  if (x[3] &lt;= 1.75) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 4.8500001430511475) {\n              if (x[0] &lt;= 5.299999952316284) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[0] &lt;= 5.950000047683716) {\n          votes[2] += 1;\n      }\n      else {\n          votes[2] += 1;\n      }\n  }\n\n  // return argmax of votes\n  uint8_t classIdx = 0;\n  float maxVotes = votes[0];\n\n  for (uint8_t i = 1; i &lt; 3; i++) {\n      if (votes[i] &gt; maxVotes) {\n          classIdx = i;\n          maxVotes = votes[i];\n      }\n  }\n\n  return classIdx;\n}</code></pre>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/\">Decision Tree, Random Forest and XGBoost on Arduino</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "You will be surprised by how much accuracy you can achieve in just a few kylobytes of resources: Decision Tree, Random Forest and XGBoost (Extreme Gradient Boosting) are now available on your microcontrollers: highly RAM-optmized implementations for super-fast classification on embedded devices.\n\n\nDecision Tree\nDecision Tree is without doubt one of the most well-known classification algorithms out there. It is so simple to understand that it was probably the first classifier you encountered in any Machine Learning course.\nI won't go into the details of how a Decision Tree classifier trains and selects the splits for the input features: here I will explain how a RAM-efficient porting of such a classifier is implemented.\nTo an introduction visit Wikipedia; for a more in-depth guide visit KDNuggets.\nSince we're willing to sacrifice program space (a.k.a flash) in favor of memory (a.k.a RAM), because RAM is the most scarce resource in the vast majority of microcontrollers, the smart way to port a Decision Tree classifier from Python to C is &quot;hard-coding&quot; the splits in code, without keeping any reference to them into variables.\nHere's what it looks like for a Decision tree that classifies the Iris dataset.\nAs you can see, we're using 0 bytes of RAM to get the classification result, since no variable is being allocated. On the other side, the program space will grow almost linearly with the number of splits.\nSince program space is often much greater than RAM on microcontrollers, this implementation exploits its abundance to be able to deploy larger models. How much large? It will depend on the flash size available: many new generations board (Arduino Nano 33 BLE Sense, ESP32, ST Nucleus...) have 1 Mb of flash, which will hold tens of thousands of splits. \nRandom Forest\nRandom Forest is just many Decision Trees joined together in a voting scheme. The core idea is that of &quot;the wisdom of the corwd&quot;, such that if many trees vote for a given class (having being trained on different subsets of the training set), that class is probably the true class.\nTowards Data Science has a more detailed guide on Random Forest and how it balances the trees with thebagging tecnique.\nAs easy as Decision Trees, Random Forest gets the exact same implementation with 0 bytes of RAM required (it actually needs as many bytes as the number of classes to store the votes, but that's really negligible): it just hard-codes all its composing trees.\nXGBoost (Extreme Gradient Boosting)\nExtreme Gradient Boosting is &quot;Gradient Boosting on steroids&quot; and has gained much attention from the Machine learning community due to its top results in many data competitions.\n\n&quot;gradient boosting&quot; refers to the process of chaining a number of trees so that each tree tries to learn from the errors of the previous\n&quot;extreme&quot; refers to many software and hardware optimizations that greatly reduce the time it takes to train the model\n\nYou can read the original paper about XGBoost here. For a discursive description head to KDNuggets, if you want some more math refer to this blog post on Medium.\nPorting to plain C\nIf you followed my earlier posts on Gaussian Naive Bayes, SEFR, Relevant Vector Machine and Support Vector Machines, you already know how to port these new classifiers.\nIf you're new, you will need a couple things:\n\ninstall the micromlgen package with \n\npip install micromlgen\n\n(optionally, if you want to use Extreme Gradient Boosting) install the xgboost package with \n\npip install xgboost\n\nuse the micromlgen.port function to generate your plain C code\n\nfrom micromlgen import port\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.datasets import load_iris\n\nclf = DecisionTreeClassifier\nX, y = load_iris(return_X_y=True)\nclf.fit(X, y)\nprint(port(clf))\nYou can then copy-past the C code and import it in your sketch.\nUsing in the Arduino sketch\nOnce you have the classifier code, create a new project named TreeClassifierExample and copy the classifier code into a file named DecisionTree.h (or RandomForest.h or XGBoost.h depending on the model you chose).\nThe copy the following to the main ino file.\n#include &quot;DecisionTree.h&quot;\n\nEloquent::ML::Port::DecisionTree clf;\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(&quot;Begin&quot;);\n}\n\nvoid loop() {\n    float irisSample[4] = {6.2, 2.8, 4.8, 1.8};\n\n    Serial.print(&quot;Predicted label (you should see &#039;2&#039;: &quot;);\n    Serial.println(clf.predict(irisSample));\n    delay(1000);\n}\nBechmarks\nHow do the 3 classifiers compare against each other?\nWe will evaluate a few keypoints:\n\ntraining time\naccuracy\nneeded RAM\nneeded Flash\n\nfor each classifier on a variety of datasets. I will report the results for RAM and Flash on the Arduino Nano old generation, so you should consider more the relative figures than the absolute ones.\n\n\n\nDataset\nClassifier\nTraining time (s)\nAccuracy\nRAM (bytes)\nFlash (bytes)\n\n\n\n\nGas Sensor Array Drift Dataset \nDecision Tree\n1,6\n0.781 \u00b1 0.12\n290\n5722\n\n\n13910 samples x 128 features\nRandom Forest\n3\n0.865 \u00b1 0.083\n290\n6438\n\n\n6 classes\nXGBoost\n18,8\n0.878 \u00b1 0.074\n290\n6506\n\n\nGesture Phase Segmentation Dataset\nDecision Tree\n0,1\n0.943 \u00b1 0.005\n290\n5638\n\n\n10000 samples x 19 features\nRandom Forest\n0,7\n0.970 \u00b1 0.004\n306\n6466\n\n\n5 classes\nXGBoost\n18,9\n0.969 \u00b1 0.003\n306\n6536\n\n\nDrive Diagnosis Dataset\nDecision Tree\n0,6\n0.946 \u00b1 0.005\n306\n5850\n\n\n10000 samples x 48 features\nRandom Forest\n2,6\n0.983 \u00b1 0.003\n306\n6526\n\n\n11 classes\nXGBoost\n68,9\n0.977 \u00b1 0.005\n306\n6698\n\n\n\n* all datasets are taken from the UCI Machine Learning datasets archive\nI'm collecting more data for a complete benchmark, but in the meantime you can see that both Random Forest and XGBoost are on par: if not that XGBoost takes 5 to 25 times longer to train.\nI've never used XGBoost, so I may be missing some tuning parameters, but for now Random Forest remains my favourite classifier.\nCode listings\n// example IRIS dataset classification with Decision Tree\nint predict(float *x) {\n  if (x[3] &lt;= 0.800000011920929) {\n      return 0;\n  }\n  else {\n      if (x[3] &lt;= 1.75) {\n          if (x[2] &lt;= 4.950000047683716) {\n              if (x[0] &lt;= 5.049999952316284) {\n                  return 1;\n              }\n              else {\n                  return 1;\n              }\n          }\n          else {\n              return 2;\n          }\n      }\n      else {\n          if (x[2] &lt;= 4.950000047683716) {\n              return 2;\n          }\n          else {\n              return 2;\n          }\n      }\n  }\n}\n// example IRIS dataset classification with Random Forest of 3 trees\n\nint predict(float *x) {\n  uint16_t votes[3] = { 0 };\n\n  // tree #1\n  if (x[0] &lt;= 5.450000047683716) {\n      if (x[1] &lt;= 2.950000047683716) {\n          votes[1] += 1;\n      }\n      else {\n          votes[0] += 1;\n      }\n  }\n  else {\n      if (x[0] &lt;= 6.049999952316284) {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[2] &lt;= 3.549999952316284) {\n                  votes[0] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n      else {\n          if (x[3] &lt;= 1.699999988079071) {\n              if (x[3] &lt;= 1.449999988079071) {\n                  if (x[0] &lt;= 6.1499998569488525) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #2\n  if (x[0] &lt;= 5.549999952316284) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 3.950000047683716) {\n              votes[1] += 1;\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[3] &lt;= 1.699999988079071) {\n          if (x[1] &lt;= 2.649999976158142) {\n              if (x[3] &lt;= 1.25) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              if (x[2] &lt;= 4.1499998569488525) {\n                  votes[1] += 1;\n              }\n              else {\n                  if (x[0] &lt;= 6.75) {\n                      votes[1] += 1;\n                  }\n                  else {\n                      votes[1] += 1;\n                  }\n              }\n          }\n      }\n      else {\n          if (x[0] &lt;= 6.0) {\n              votes[2] += 1;\n          }\n          else {\n              votes[2] += 1;\n          }\n      }\n  }\n\n  // tree #3\n  if (x[3] &lt;= 1.75) {\n      if (x[2] &lt;= 2.449999988079071) {\n          votes[0] += 1;\n      }\n      else {\n          if (x[2] &lt;= 4.8500001430511475) {\n              if (x[0] &lt;= 5.299999952316284) {\n                  votes[1] += 1;\n              }\n              else {\n                  votes[1] += 1;\n              }\n          }\n          else {\n              votes[1] += 1;\n          }\n      }\n  }\n  else {\n      if (x[0] &lt;= 5.950000047683716) {\n          votes[2] += 1;\n      }\n      else {\n          votes[2] += 1;\n      }\n  }\n\n  // return argmax of votes\n  uint8_t classIdx = 0;\n  float maxVotes = votes[0];\n\n  for (uint8_t i = 1; i &lt; 3; i++) {\n      if (votes[i] &gt; maxVotes) {\n          classIdx = i;\n          maxVotes = votes[i];\n      }\n  }\n\n  return classIdx;\n}\nL'articolo Decision Tree, Random Forest and XGBoost on Arduino proviene da Eloquent Arduino Blog.",
            "date_published": "2020-10-19T19:31:02+02:00",
            "date_modified": "2020-10-21T13:59:20+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning",
                "Arduino Machine Learning tutorial"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1282",
            "url": "https://eloquentarduino.github.io/2020/08/better-word-classification-with-arduino-33-ble-sense-and-machine-learning/",
            "title": "Better word classification with Arduino Nano 33 BLE Sense and Machine Learning",
            "content_html": "<p>Let's revamp the post I wrote about <a href=\"/2019/12/word-classification-using-arduino/\">word classification using Machine Learning on Arduino</a>, this time using a proper microphone (the MP34DT05 mounted on the Arduino Nano 33 BLE Sense) instead of a chinese, analog one: will the results improve?</p>\n<div id=\"attachment_653\" style=\"width: 760px\" class=\"wp-caption alignnone\"><img aria-describedby=\"caption-attachment-653\" src=\"https://eloquentarduino.github.io/wp-content/uploads/2019/12/WakeWord.jpg\" width=\"750\" height=\"422\" class=\"size-full wp-image-653\" srcset=\"https://eloquentarduino.github.io/wp-content/uploads/2019/12/WakeWord.jpg 750w, https://eloquentarduino.github.io/wp-content/uploads/2019/12/WakeWord-300x169.jpg 300w\" sizes=\"(max-width: 750px) 100vw, 750px\" /><p id=\"caption-attachment-653\" class=\"wp-caption-text\">from https://www.udemy.com/course/learn-audio-processing-complete-engineers-course/</p></div>\n<p><span id=\"more-1282\"></span></p>\n<p><strong>Updated on 16 October 2020: step by step explanation of the process with ready-made sketch code</strong></p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tocwhat-youll-learn\">What you'll learn</a><li><a href=\"#tocwhat-youll-need\">What you'll need</a><li><a href=\"#tocstep-1-capture-audio-samples\">Step 1. Capture audio samples</a><ol><li><a href=\"#toctheory-pulse-density-modulation-a-k-a-pdm\">Theory: Pulse-density modulation (a.k.a. PDM)</a><li><a href=\"#tocpractice-the-code-to-capture-the-samples\">Practice: the code to capture the samples</a><li><a href=\"#tocaction-capture-the-words-examples\">Action: capture the words examples</a></li></ol><li><a href=\"#tocstep-2-train-the-machine-learning-model\">Step 2. Train the machine learning model</a><li><a href=\"#tocstep-3-deploy-to-your-microcontroller\">Step 3. Deploy to your microcontroller</a></ol></div></p>\n<h2 id=\"tocwhat-youll-learn\">What you'll learn</h2>\n<p>This tutorial will teach you how to capture audio from the Arduino Nano 33 BLE Sense microphone and classify it: at the end of this post, you will have a trained model able to detect in real-time the word you tell, among the ones that you trained it to recognize. The classification will occur directly on your Arduino board.</p>\n<p><em>This is not a general-purpose speech recognizer able to convert speech-to-text: it works only on the words <strong>you</strong> train it on</em>.</p>\n<h2 id=\"tocwhat-youll-need\">What you'll need</h2>\n<ul>\n<li>\n<p><strong>Hardware</strong></p>\n<ol>\n<li><a href=\"https://store.arduino.cc/arduino-nano-33-ble-sense\">Arduino Nano 33 BLE Sense</a></li>\n</ol>\n</li>\n<li>\n<p><strong>Software</strong></p>\n<ol>\n<li>Python</li>\n<li>Python's module <a href=\"https://scikit-learn.org/stable/\">scikit-learn</a></li>\n<li>Python's module <a href=\"https://pypi.org/project/micromlgen/\">micromlgen</a></li>\n</ol>\n</li>\n</ul>\n<p>To install the software, open your terminal and install the libraries.</p>\n<pre><code class=\"language-bash\">pip install -U scikit-learn\npip install -U micromlgen</code></pre>\n<h2 id=\"tocstep-1-capture-audio-samples\">Step 1. Capture audio samples</h2>\n<p>First of all, we need to capture a bunch of examples of the words we want to recognize.</p>\n<p>In the <a href=\"/2019/12/word-classification-using-arduino/\">original post</a>, we used an analog microphone to record the audio. It is for sure the easiest way to interact with audio on a microcontroller since you only need to <code>analogRead()</code> the selected pin to get a value from the sensor.</p>\n<p>This semplicity, however, comes at the cost of a nearly inexistent signal pre-processing from the sensor itself: most of the time, you will get junk - I don't want to be rude, but that's it.</p>\n<h3 id=\"toctheory-pulse-density-modulation-a-k-a-pdm\">Theory: Pulse-density modulation (a.k.a. PDM)</h3>\n<p>The microphone mounted on the Arduino Nano 33 BLE Sense (the <a href=\"https://content.arduino.cc/assets/Nano_BLE_Sense_mp34dt05-a.pdf\">MP34DT05</a>) is fortunately much better than this: it gives you access to a modulated signal much more suitable for our processing needs.</p>\n<p>The modulation used is pulse-density: I won't try to explain you how this works since I'm not an expert in DSP and neither it is the main scope of this article (refer to <a href=\"https://en.wikipedia.org/wiki/Pulse-density_modulation\">Wikipedia</a> for some more information).</p>\n<p>What matters to us is that we can grab an array of bytes from the microphone and extract its <a href=\"https://en.wikipedia.org/wiki/Root_mean_square\">Root Mean Square</a> (a.k.a. RMS) to be used as a feature for our Machine Learning model.</p>\n<p>I had some difficulty finding examples on how to access the microphone on the Arduino Nano 33 BLE Sense board: fortunately, there's a <a href=\"https://github.com/DaleGia/nano-33-sense-serial-example\">Github repo</a> from <em>DelaGia</em> that shows how to access all the sensors of the board.</p>\n<p>I extracted the microphone part and incapsulated it in an easy to use class, so you don't really need to dig into the implementation details if you're not interested.</p>\n<h3 id=\"tocpractice-the-code-to-capture-the-samples\">Practice: the code to capture the samples</h3>\n<p>When loaded on your Arduino Nano 33 BLE Sense, the following sketch will await for you to speak in front of the microphone: once it detects a sound, it will record  64 audio values and print them to the serial monitor.</p>\n<p>From my experience, 64 samples are sufficient to cover short words such as <em>yes</em>, <em>no</em>, <em>play</em>, <em>stop</em>: if you plan to classify longer words, you may need to increase this number.</p>\n<div class=\"watchout\">I suggest you keep the words short: longer words will probably decrease the accuracy of the model. If you want nonetheless a longer duration, at least keep the number of words as low as possible</div>\n<p>Download the <a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/arduino-33-ble-sense-capture-audio-samples.zip\" title=\"Arduino Nano 33 BLE Sense - Capture audio samples\">Arduino Nano 33 BLE Sense - Capture audio samples sketch</a>, open it the Arduino IDE and flash it to your board.</p>\n<p>Here's the main code.</p>\n<pre><code class=\"language-cpp\">#include &quot;Mic.h&quot;\n\n// tune as per your needs\n#define SAMPLES 64\n#define GAIN (1.0f/50)\n#define SOUND_THRESHOLD 2000\n\nfloat features[SAMPLES];\nMic mic;\n\nvoid setup() {\n    Serial.begin(115200);\n    PDM.onReceive(onAudio);\n    mic.begin();\n    delay(3000);\n}\n\nvoid loop() {\n    // await for a word to be pronounced\n    if (recordAudioSample()) {\n        // print features to serial monitor\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            Serial.print(features[i], 6);\n            Serial.print(i == SAMPLES - 1 ? &#039;\\n&#039; : &#039;,&#039;);\n        }\n\n        delay(1000);\n    }\n\n    delay(20);\n}\n\n/**\n * PDM callback to update mic object\n */\nvoid onAudio() {\n    mic.update();\n}\n\n/**\n * Read given number of samples from mic\n */\nbool recordAudioSample() {\n    if (mic.hasData() &amp;&amp; mic.data() &gt; SOUND_THRESHOLD) {\n\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            while (!mic.hasData())\n                delay(1);\n\n            features[i] = mic.pop() * GAIN;\n        }\n\n        return true;\n    }\n\n    return false;\n}</code></pre>\n<p>Now that we have the acquisition logic in place, it's time for you to record some samples of the words you want to classify. </p>\n<h3 id=\"tocaction-capture-the-words-examples\">Action: capture the words examples</h3>\n<p>Now you have to capture as many samples of the words you want to classify as possible.</p>\n<p>Open the serial monitor and pronounce a word near the microphone: a line of numbers will be printed on the monitor.</p>\n<p>This is the <em>description</em> of your word.</p>\n<p>You need many lines like this for an accurate prediction, so keep repeating the same word 15-30 times.</p>\n<div class=\"my-advice\">**My advice**: while recording the samples, vary both the distance of your mounth from the mic and the intensity of your voice: this will produce a more robust classification model later on.</div>\n<p>After you repeated the same words many times, copy the content of the serial monitor and save it in a CSV file named after the word, for example <code>yes.csv</code>.</p>\n<p>Then clear the serial monitor and repeat the process for each word.</p>\n<p>Keep all these files in a folder because we need them to train our classifier.</p>\n<h2 id=\"tocstep-2-train-the-machine-learning-model\">Step 2. Train the machine learning model</h2>\n<p>Now that we have the samples, it's time to train the classifier.</p>\n<p>Create a Python project in your favourite IDE or use your favourite text editor, if you don't have one.</p>\n<p>As described in <a href=\"/2019/11/how-to-train-a-classifier-in-scikit-learn/\">my post about how to train a classifier</a>, we create a Python script that reads all the files inside a folder and concatenates them in a single array you feed to the classifier model.</p>\n<p>Be sure your folder structure is like the following:</p>\n<pre><code>ArduinoWordClassification\n  |-- train_classifier.py\n  |-- data/\n  |---- yes.csv\n  |---- no.csv\n  |---- play.csv\n  |---- any other .csv file you recorded</code></pre>\n<pre><code class=\"language-python\"># file: train_classifier.py\n\nimport numpy as np\nfrom os.path import basename\nfrom glob import glob\nfrom sklearn.svm import SVC\nfrom micromlgen import port\nfrom sklearn.model_selection import train_test_split\n\ndef load_features(folder):\n    dataset = None\n    classmap = {}\n    for class_idx, filename in enumerate(glob(&#039;%s/*.csv&#039; % folder)):\n        class_name = basename(filename)[:-4]\n        classmap[class_idx] = class_name\n        samples = np.loadtxt(filename, dtype=float, delimiter=&#039;,&#039;)\n        labels = np.ones((len(samples), 1)) * class_idx\n        samples = np.hstack((samples, labels))\n        dataset = samples if dataset is None else np.vstack((dataset, samples))\n    return dataset, classmap\n\nnp.random.seed(0)\ndataset, classmap = load_features(&#039;data&#039;)\nX, y = dataset[:, :-1], dataset[:, -1]\n# this line is for testing your accuracy only: once you&#039;re satisfied with the results, set test_size to 1\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\nclf = SVC(kernel=&#039;poly&#039;, degree=2, gamma=0.1, C=100)\nclf.fit(X_train, y_train)\n\nprint(&#039;Accuracy&#039;, clf.score(X_test, y_test))\nprint(&#039;Exported classifier to plain C&#039;)\nprint(port(clf, classmap=classmap))</code></pre>\n<p>Among the classifiers I tried, SVM produced the best accuracy at 96% with 32 support vectors: it's not a super-tiny model, but it's quite small nevertheless.</p>\n<p>If you're not satisifed with SVM, you can use Decision Tree, Random Forest, Gaussian Naive Bayes, Relevant Vector Machines. See my other posts for a detailed description of each.</p>\n<p>In your console, after the accuracy score, you will have the plain C implementation of the classifier you trained. The following reports my SVM model.</p>\n<pre><code class=\"language-cpp\">// File: Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SVM {\n            public:\n                /**\n                * Predict class for features vector\n                */\n                int predict(float *x) {\n                    float kernels[35] = { 0 };\n                    float decisions[6] = { 0 };\n                    int votes[4] = { 0 };\n                    kernels[0] = compute_kernel(x,   33.0  , 41.0  , 47.0  , 54.0  , 59.0  , 61.0  , 56.0  , 51.0  , 50.0  , 51.0  , 44.0  , 32.0  , 23.0  , 15.0  , 12.0  , 8.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 5.0  , 3.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0 );\n                    kernels[1] = compute_kernel(x,   40.0  , 50.0  , 51.0  , 60.0  , 56.0  , 57.0  , 58.0  , 53.0  , 50.0  , 45.0  , 42.0  , 34.0  , 23.0  , 16.0  , 10.0  , 7.0  , 3.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 14.0  , 3.0  , 8.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 3.0 );\n                    kernels[2] = compute_kernel(x,   56.0  , 68.0  , 78.0  , 91.0  , 84.0  , 84.0  , 84.0  , 74.0  , 69.0  , 64.0  , 57.0  , 44.0  , 33.0  , 18.0  , 12.0  , 8.0  , 5.0  , 9.0  , 15.0  , 12.0  , 12.0  , 9.0  , 12.0  , 7.0  , 3.0  , 10.0  , 12.0  , 6.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 6.0  , 3.0  , 6.0  , 10.0  , 10.0  , 8.0  , 3.0  , 9.0  , 9.0  , 9.0  , 8.0  , 9.0  , 9.0  , 11.0  , 3.0  , 8.0  , 9.0  , 8.0  , 8.0  , 8.0  , 6.0  , 7.0  , 3.0  , 3.0  , 8.0  , 5.0  , 3.0  , 0.0  , 3.0  , 0.0  , 0.0 );\n\n                    // ...many other kernels computations...\n\n                    decisions[0] = 0.722587775297\n                                   + kernels[1] * 3.35855e-07\n                                   + kernels[2] * 1.64612e-07\n                                   + kernels[4] * 6.00056e-07\n                                   + kernels[5] * 3.5195e-08\n                                   + kernels[7] * -4.2079e-08\n                                   + kernels[8] * -4.2843e-08\n                                   + kernels[9] * -9.994e-09\n                                   + kernels[10] * -5.11065e-07\n                                   + kernels[11] * -5.979e-09\n                                   + kernels[12] * -4.4672e-08\n                                   + kernels[13] * -1.5606e-08\n                                   + kernels[14] * -1.2941e-08\n                                   + kernels[15] * -2.18903e-07\n                                   + kernels[17] * -2.31635e-07\n                            ;\n                    decisions[1] = -1.658344586719\n                                   + kernels[0] * 2.45018e-07\n                                   + kernels[1] * 4.30223e-07\n                                   + kernels[3] * 1.00277e-07\n                                   + kernels[4] * 2.16524e-07\n                                   + kernels[18] * -4.81187e-07\n                                   + kernels[20] * -5.10856e-07\n                            ;\n                    decisions[2] = -1.968607562265\n                                   + kernels[0] * 3.001833e-06\n                                   + kernels[3] * 4.5201e-08\n                                   + kernels[4] * 1.54493e-06\n                                   + kernels[5] * 2.81834e-07\n                                   + kernels[25] * -5.93581e-07\n                                   + kernels[26] * -2.89779e-07\n                                   + kernels[27] * -1.73958e-06\n                                   + kernels[28] * -1.09552e-07\n                                   + kernels[30] * -3.09126e-07\n                                   + kernels[31] * -1.294219e-06\n                                   + kernels[32] * -5.37961e-07\n                            ;\n                    decisions[3] = -0.720663029823\n                                   + kernels[6] * 1.4362e-08\n                                   + kernels[7] * 6.177e-09\n                                   + kernels[9] * 1.25e-08\n                                   + kernels[10] * 2.05478e-07\n                                   + kernels[12] * 2.501e-08\n                                   + kernels[15] * 4.363e-07\n                                   + kernels[16] * 9.147e-09\n                                   + kernels[18] * -1.82182e-07\n                                   + kernels[20] * -4.93707e-07\n                                   + kernels[21] * -3.3084e-08\n                            ;\n                    decisions[4] = -1.605747746589\n                                   + kernels[6] * 6.182e-09\n                                   + kernels[7] * 1.3853e-08\n                                   + kernels[8] * 2.12e-10\n                                   + kernels[9] * 1.1243e-08\n                                   + kernels[10] * 7.80681e-07\n                                   + kernels[15] * 8.347e-07\n                                   + kernels[17] * 1.64985e-07\n                                   + kernels[23] * -4.25014e-07\n                                   + kernels[25] * -1.134803e-06\n                                   + kernels[34] * -2.52038e-07\n                            ;\n                    decisions[5] = -0.934328303475\n                                   + kernels[19] * 3.3529e-07\n                                   + kernels[20] * 1.121946e-06\n                                   + kernels[21] * 3.44683e-07\n                                   + kernels[22] * -6.23056e-07\n                                   + kernels[24] * -1.4612e-07\n                                   + kernels[28] * -1.24025e-07\n                                   + kernels[29] * -4.31701e-07\n                                   + kernels[31] * -9.2146e-08\n                                   + kernels[33] * -3.8487e-07\n                            ;\n                    votes[decisions[0] &gt; 0 ? 0 : 1] += 1;\n                    votes[decisions[1] &gt; 0 ? 0 : 2] += 1;\n                    votes[decisions[2] &gt; 0 ? 0 : 3] += 1;\n                    votes[decisions[3] &gt; 0 ? 1 : 2] += 1;\n                    votes[decisions[4] &gt; 0 ? 1 : 3] += 1;\n                    votes[decisions[5] &gt; 0 ? 2 : 3] += 1;\n                    int val = votes[0];\n                    int idx = 0;\n\n                    for (int i = 1; i &lt; 4; i++) {\n                        if (votes[i] &gt; val) {\n                            val = votes[i];\n                            idx = i;\n                        }\n                    }\n\n                    return idx;\n                }\n\n                /**\n                * Convert class idx to readable name\n                */\n                const char* predictLabel(float *x) {\n                    switch (predict(x)) {\n                        case 0:\n                            return &quot;no&quot;;\n                        case 1:\n                            return &quot;stop&quot;;\n                        case 2:\n                            return &quot;play&quot;;\n                        case 3:\n                            return &quot;yes&quot;;\n                        default:\n                            return &quot;Houston we have a problem&quot;;\n                    }\n                }\n\n            protected:\n                /**\n                * Compute kernel between feature vector and support vector.\n                * Kernel type: poly\n                */\n                float compute_kernel(float *x, ...) {\n                    va_list w;\n                    va_start(w, 64);\n                    float kernel = 0.0;\n\n                    for (uint16_t i = 0; i &lt; 64; i++) {\n                        kernel += x[i] * va_arg(w, double);\n                    }\n\n                    return pow((0.1 * kernel) + 0.0, 2);\n                }\n            };\n        }\n    }\n}</code></pre>\n<h2 id=\"tocstep-3-deploy-to-your-microcontroller\">Step 3. Deploy to your microcontroller</h2>\n<p>Now we have all the pieces we need to perform word classification on our Arduino board.</p>\n<p>Download <a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/arduino-33-ble-sense-classify-audio.zip\">the Arduino Nano 33 BLE Sense - Audio classification sketch</a>, open it in the Arduino IDE and paste the plain C code you got in the console inside the <code>Classifier.h</code> file (delete all its contents before!).</p>\n<p>Fine: it's time to deploy!</p>\n<p>Hit the upload button: if everything went fine, open the serial monitor and pronounce one of the words you recorded during <code>Step 1</code>.</p>\n<p>Hopefully, you will read the word on the serial monitor.</p>\n<p>Here's a quick demo (please forgive me for the bad video quality).</p>\n<div style=\"width: 576px;\" class=\"wp-video\"><!--[if lt IE 9]><script>document.createElement('video');</script><![endif]-->\n<video class=\"wp-video-shortcode\" id=\"video-1282-1\" width=\"576\" height=\"482\" preload=\"metadata\" controls=\"controls\"><source type=\"video/mp4\" src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4?_=1\" /><a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4\">https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4</a></video></div>\n<hr />\n<p>If you liked this tutorial and it helped you successfully implement word classification on your Arduino Nano 33 BLE Sense, please share it on your social media so others can benefit too.</p>\n<p>If you have troubles or questions, don't hesitate to leave a comment: I will be happy to help you.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/08/better-word-classification-with-arduino-33-ble-sense-and-machine-learning/\">Better word classification with Arduino Nano 33 BLE Sense and Machine Learning</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Let's revamp the post I wrote about word classification using Machine Learning on Arduino, this time using a proper microphone (the MP34DT05 mounted on the Arduino Nano 33 BLE Sense) instead of a chinese, analog one: will the results improve?\nfrom https://www.udemy.com/course/learn-audio-processing-complete-engineers-course/\n\nUpdated on 16 October 2020: step by step explanation of the process with ready-made sketch code\nTable of contentsWhat you'll learnWhat you'll needStep 1. Capture audio samplesTheory: Pulse-density modulation (a.k.a. PDM)Practice: the code to capture the samplesAction: capture the words examplesStep 2. Train the machine learning modelStep 3. Deploy to your microcontroller\nWhat you'll learn\nThis tutorial will teach you how to capture audio from the Arduino Nano 33 BLE Sense microphone and classify it: at the end of this post, you will have a trained model able to detect in real-time the word you tell, among the ones that you trained it to recognize. The classification will occur directly on your Arduino board.\nThis is not a general-purpose speech recognizer able to convert speech-to-text: it works only on the words you train it on.\nWhat you'll need\n\n\nHardware\n\nArduino Nano 33 BLE Sense\n\n\n\nSoftware\n\nPython\nPython's module scikit-learn\nPython's module micromlgen\n\n\n\nTo install the software, open your terminal and install the libraries.\npip install -U scikit-learn\npip install -U micromlgen\nStep 1. Capture audio samples\nFirst of all, we need to capture a bunch of examples of the words we want to recognize.\nIn the original post, we used an analog microphone to record the audio. It is for sure the easiest way to interact with audio on a microcontroller since you only need to analogRead() the selected pin to get a value from the sensor.\nThis semplicity, however, comes at the cost of a nearly inexistent signal pre-processing from the sensor itself: most of the time, you will get junk - I don't want to be rude, but that's it.\nTheory: Pulse-density modulation (a.k.a. PDM)\nThe microphone mounted on the Arduino Nano 33 BLE Sense (the MP34DT05) is fortunately much better than this: it gives you access to a modulated signal much more suitable for our processing needs.\nThe modulation used is pulse-density: I won't try to explain you how this works since I'm not an expert in DSP and neither it is the main scope of this article (refer to Wikipedia for some more information).\nWhat matters to us is that we can grab an array of bytes from the microphone and extract its Root Mean Square (a.k.a. RMS) to be used as a feature for our Machine Learning model.\nI had some difficulty finding examples on how to access the microphone on the Arduino Nano 33 BLE Sense board: fortunately, there's a Github repo from DelaGia that shows how to access all the sensors of the board.\nI extracted the microphone part and incapsulated it in an easy to use class, so you don't really need to dig into the implementation details if you're not interested.\nPractice: the code to capture the samples\nWhen loaded on your Arduino Nano 33 BLE Sense, the following sketch will await for you to speak in front of the microphone: once it detects a sound, it will record  64 audio values and print them to the serial monitor.\nFrom my experience, 64 samples are sufficient to cover short words such as yes, no, play, stop: if you plan to classify longer words, you may need to increase this number.\nI suggest you keep the words short: longer words will probably decrease the accuracy of the model. If you want nonetheless a longer duration, at least keep the number of words as low as possible\nDownload the Arduino Nano 33 BLE Sense - Capture audio samples sketch, open it the Arduino IDE and flash it to your board.\nHere's the main code.\n#include &quot;Mic.h&quot;\n\n// tune as per your needs\n#define SAMPLES 64\n#define GAIN (1.0f/50)\n#define SOUND_THRESHOLD 2000\n\nfloat features[SAMPLES];\nMic mic;\n\nvoid setup() {\n    Serial.begin(115200);\n    PDM.onReceive(onAudio);\n    mic.begin();\n    delay(3000);\n}\n\nvoid loop() {\n    // await for a word to be pronounced\n    if (recordAudioSample()) {\n        // print features to serial monitor\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            Serial.print(features[i], 6);\n            Serial.print(i == SAMPLES - 1 ? &#039;\\n&#039; : &#039;,&#039;);\n        }\n\n        delay(1000);\n    }\n\n    delay(20);\n}\n\n/**\n * PDM callback to update mic object\n */\nvoid onAudio() {\n    mic.update();\n}\n\n/**\n * Read given number of samples from mic\n */\nbool recordAudioSample() {\n    if (mic.hasData() &amp;&amp; mic.data() &gt; SOUND_THRESHOLD) {\n\n        for (int i = 0; i &lt; SAMPLES; i++) {\n            while (!mic.hasData())\n                delay(1);\n\n            features[i] = mic.pop() * GAIN;\n        }\n\n        return true;\n    }\n\n    return false;\n}\nNow that we have the acquisition logic in place, it's time for you to record some samples of the words you want to classify. \nAction: capture the words examples\nNow you have to capture as many samples of the words you want to classify as possible.\nOpen the serial monitor and pronounce a word near the microphone: a line of numbers will be printed on the monitor.\nThis is the description of your word.\nYou need many lines like this for an accurate prediction, so keep repeating the same word 15-30 times.\n**My advice**: while recording the samples, vary both the distance of your mounth from the mic and the intensity of your voice: this will produce a more robust classification model later on.\nAfter you repeated the same words many times, copy the content of the serial monitor and save it in a CSV file named after the word, for example yes.csv.\nThen clear the serial monitor and repeat the process for each word.\nKeep all these files in a folder because we need them to train our classifier.\nStep 2. Train the machine learning model\nNow that we have the samples, it's time to train the classifier.\nCreate a Python project in your favourite IDE or use your favourite text editor, if you don't have one.\nAs described in my post about how to train a classifier, we create a Python script that reads all the files inside a folder and concatenates them in a single array you feed to the classifier model.\nBe sure your folder structure is like the following:\nArduinoWordClassification\n  |-- train_classifier.py\n  |-- data/\n  |---- yes.csv\n  |---- no.csv\n  |---- play.csv\n  |---- any other .csv file you recorded\n# file: train_classifier.py\n\nimport numpy as np\nfrom os.path import basename\nfrom glob import glob\nfrom sklearn.svm import SVC\nfrom micromlgen import port\nfrom sklearn.model_selection import train_test_split\n\ndef load_features(folder):\n    dataset = None\n    classmap = {}\n    for class_idx, filename in enumerate(glob(&#039;%s/*.csv&#039; % folder)):\n        class_name = basename(filename)[:-4]\n        classmap[class_idx] = class_name\n        samples = np.loadtxt(filename, dtype=float, delimiter=&#039;,&#039;)\n        labels = np.ones((len(samples), 1)) * class_idx\n        samples = np.hstack((samples, labels))\n        dataset = samples if dataset is None else np.vstack((dataset, samples))\n    return dataset, classmap\n\nnp.random.seed(0)\ndataset, classmap = load_features(&#039;data&#039;)\nX, y = dataset[:, :-1], dataset[:, -1]\n# this line is for testing your accuracy only: once you&#039;re satisfied with the results, set test_size to 1\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\nclf = SVC(kernel=&#039;poly&#039;, degree=2, gamma=0.1, C=100)\nclf.fit(X_train, y_train)\n\nprint(&#039;Accuracy&#039;, clf.score(X_test, y_test))\nprint(&#039;Exported classifier to plain C&#039;)\nprint(port(clf, classmap=classmap))\nAmong the classifiers I tried, SVM produced the best accuracy at 96% with 32 support vectors: it's not a super-tiny model, but it's quite small nevertheless.\nIf you're not satisifed with SVM, you can use Decision Tree, Random Forest, Gaussian Naive Bayes, Relevant Vector Machines. See my other posts for a detailed description of each.\nIn your console, after the accuracy score, you will have the plain C implementation of the classifier you trained. The following reports my SVM model.\n// File: Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SVM {\n            public:\n                /**\n                * Predict class for features vector\n                */\n                int predict(float *x) {\n                    float kernels[35] = { 0 };\n                    float decisions[6] = { 0 };\n                    int votes[4] = { 0 };\n                    kernels[0] = compute_kernel(x,   33.0  , 41.0  , 47.0  , 54.0  , 59.0  , 61.0  , 56.0  , 51.0  , 50.0  , 51.0  , 44.0  , 32.0  , 23.0  , 15.0  , 12.0  , 8.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 5.0  , 3.0  , 5.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0 );\n                    kernels[1] = compute_kernel(x,   40.0  , 50.0  , 51.0  , 60.0  , 56.0  , 57.0  , 58.0  , 53.0  , 50.0  , 45.0  , 42.0  , 34.0  , 23.0  , 16.0  , 10.0  , 7.0  , 3.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 14.0  , 3.0  , 8.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 5.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 0.0  , 3.0  , 0.0  , 0.0  , 0.0  , 3.0 );\n                    kernels[2] = compute_kernel(x,   56.0  , 68.0  , 78.0  , 91.0  , 84.0  , 84.0  , 84.0  , 74.0  , 69.0  , 64.0  , 57.0  , 44.0  , 33.0  , 18.0  , 12.0  , 8.0  , 5.0  , 9.0  , 15.0  , 12.0  , 12.0  , 9.0  , 12.0  , 7.0  , 3.0  , 10.0  , 12.0  , 6.0  , 3.0  , 0.0  , 0.0  , 0.0  , 0.0  , 6.0  , 3.0  , 6.0  , 10.0  , 10.0  , 8.0  , 3.0  , 9.0  , 9.0  , 9.0  , 8.0  , 9.0  , 9.0  , 11.0  , 3.0  , 8.0  , 9.0  , 8.0  , 8.0  , 8.0  , 6.0  , 7.0  , 3.0  , 3.0  , 8.0  , 5.0  , 3.0  , 0.0  , 3.0  , 0.0  , 0.0 );\n\n                    // ...many other kernels computations...\n\n                    decisions[0] = 0.722587775297\n                                   + kernels[1] * 3.35855e-07\n                                   + kernels[2] * 1.64612e-07\n                                   + kernels[4] * 6.00056e-07\n                                   + kernels[5] * 3.5195e-08\n                                   + kernels[7] * -4.2079e-08\n                                   + kernels[8] * -4.2843e-08\n                                   + kernels[9] * -9.994e-09\n                                   + kernels[10] * -5.11065e-07\n                                   + kernels[11] * -5.979e-09\n                                   + kernels[12] * -4.4672e-08\n                                   + kernels[13] * -1.5606e-08\n                                   + kernels[14] * -1.2941e-08\n                                   + kernels[15] * -2.18903e-07\n                                   + kernels[17] * -2.31635e-07\n                            ;\n                    decisions[1] = -1.658344586719\n                                   + kernels[0] * 2.45018e-07\n                                   + kernels[1] * 4.30223e-07\n                                   + kernels[3] * 1.00277e-07\n                                   + kernels[4] * 2.16524e-07\n                                   + kernels[18] * -4.81187e-07\n                                   + kernels[20] * -5.10856e-07\n                            ;\n                    decisions[2] = -1.968607562265\n                                   + kernels[0] * 3.001833e-06\n                                   + kernels[3] * 4.5201e-08\n                                   + kernels[4] * 1.54493e-06\n                                   + kernels[5] * 2.81834e-07\n                                   + kernels[25] * -5.93581e-07\n                                   + kernels[26] * -2.89779e-07\n                                   + kernels[27] * -1.73958e-06\n                                   + kernels[28] * -1.09552e-07\n                                   + kernels[30] * -3.09126e-07\n                                   + kernels[31] * -1.294219e-06\n                                   + kernels[32] * -5.37961e-07\n                            ;\n                    decisions[3] = -0.720663029823\n                                   + kernels[6] * 1.4362e-08\n                                   + kernels[7] * 6.177e-09\n                                   + kernels[9] * 1.25e-08\n                                   + kernels[10] * 2.05478e-07\n                                   + kernels[12] * 2.501e-08\n                                   + kernels[15] * 4.363e-07\n                                   + kernels[16] * 9.147e-09\n                                   + kernels[18] * -1.82182e-07\n                                   + kernels[20] * -4.93707e-07\n                                   + kernels[21] * -3.3084e-08\n                            ;\n                    decisions[4] = -1.605747746589\n                                   + kernels[6] * 6.182e-09\n                                   + kernels[7] * 1.3853e-08\n                                   + kernels[8] * 2.12e-10\n                                   + kernels[9] * 1.1243e-08\n                                   + kernels[10] * 7.80681e-07\n                                   + kernels[15] * 8.347e-07\n                                   + kernels[17] * 1.64985e-07\n                                   + kernels[23] * -4.25014e-07\n                                   + kernels[25] * -1.134803e-06\n                                   + kernels[34] * -2.52038e-07\n                            ;\n                    decisions[5] = -0.934328303475\n                                   + kernels[19] * 3.3529e-07\n                                   + kernels[20] * 1.121946e-06\n                                   + kernels[21] * 3.44683e-07\n                                   + kernels[22] * -6.23056e-07\n                                   + kernels[24] * -1.4612e-07\n                                   + kernels[28] * -1.24025e-07\n                                   + kernels[29] * -4.31701e-07\n                                   + kernels[31] * -9.2146e-08\n                                   + kernels[33] * -3.8487e-07\n                            ;\n                    votes[decisions[0] &gt; 0 ? 0 : 1] += 1;\n                    votes[decisions[1] &gt; 0 ? 0 : 2] += 1;\n                    votes[decisions[2] &gt; 0 ? 0 : 3] += 1;\n                    votes[decisions[3] &gt; 0 ? 1 : 2] += 1;\n                    votes[decisions[4] &gt; 0 ? 1 : 3] += 1;\n                    votes[decisions[5] &gt; 0 ? 2 : 3] += 1;\n                    int val = votes[0];\n                    int idx = 0;\n\n                    for (int i = 1; i &lt; 4; i++) {\n                        if (votes[i] &gt; val) {\n                            val = votes[i];\n                            idx = i;\n                        }\n                    }\n\n                    return idx;\n                }\n\n                /**\n                * Convert class idx to readable name\n                */\n                const char* predictLabel(float *x) {\n                    switch (predict(x)) {\n                        case 0:\n                            return &quot;no&quot;;\n                        case 1:\n                            return &quot;stop&quot;;\n                        case 2:\n                            return &quot;play&quot;;\n                        case 3:\n                            return &quot;yes&quot;;\n                        default:\n                            return &quot;Houston we have a problem&quot;;\n                    }\n                }\n\n            protected:\n                /**\n                * Compute kernel between feature vector and support vector.\n                * Kernel type: poly\n                */\n                float compute_kernel(float *x, ...) {\n                    va_list w;\n                    va_start(w, 64);\n                    float kernel = 0.0;\n\n                    for (uint16_t i = 0; i &lt; 64; i++) {\n                        kernel += x[i] * va_arg(w, double);\n                    }\n\n                    return pow((0.1 * kernel) + 0.0, 2);\n                }\n            };\n        }\n    }\n}\nStep 3. Deploy to your microcontroller\nNow we have all the pieces we need to perform word classification on our Arduino board.\nDownload the Arduino Nano 33 BLE Sense - Audio classification sketch, open it in the Arduino IDE and paste the plain C code you got in the console inside the Classifier.h file (delete all its contents before!).\nFine: it's time to deploy!\nHit the upload button: if everything went fine, open the serial monitor and pronounce one of the words you recorded during Step 1.\nHopefully, you will read the word on the serial monitor.\nHere's a quick demo (please forgive me for the bad video quality).\n\nhttps://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4\n\nIf you liked this tutorial and it helped you successfully implement word classification on your Arduino Nano 33 BLE Sense, please share it on your social media so others can benefit too.\nIf you have troubles or questions, don't hesitate to leave a comment: I will be happy to help you.\nL'articolo Better word classification with Arduino Nano 33 BLE Sense and Machine Learning proviene da Eloquent Arduino Blog.",
            "date_published": "2020-08-24T19:04:57+02:00",
            "date_modified": "2020-10-17T17:50:13+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning"
            ],
            "attachments": [
                {
                    "url": "https://eloquentarduino.github.io/wp-content/uploads/2020/08/Arduino-Nano-33-BLE-Sense-Word-classification.mp4",
                    "mime_type": "video/mp4",
                    "size_in_bytes": 5594095
                }
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1225",
            "url": "https://eloquentarduino.github.io/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/",
            "title": "EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino",
            "content_html": "<p>Are you looking for a top-performer classifiers with a minimal amount of parameters to tune? Look no further: Gaussian Naive Bayes is what you're looking for. And thanks to EloquentML you can now port it to your microcontroller.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/08/GaussianNB.png\" alt=\"GaussianNB\" /></p>\n<p><span id=\"more-1225\"></span></p>\n<h2>(Gaussian) Naive Bayes</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Naive_Bayes_classifier\">Naive Bayes</a> classifiers are simple models based on the probability theory that can be used for classification.</p>\n<p>They originate from the assumption of independence among the input variables. Even though this assumption doesn't hold true in the vast majority of the cases, they often perform very good at many classification tasks, so they're quite popular.</p>\n<p>Gaussian Naive Bayes stack another (mostly wrong) assumption: that the variables exhibit a Gaussian probability distribution.</p>\n<p>I (and many others like me) will never understand how it is possible that so many wrong assumptions lead to such good performances!</p>\n<p>Nevertheless, what is important to us is that <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.GaussianNB.html\">sklearn implements GaussianNB</a>, so we easily train such a classifier.<br />\nThe most interesting part is that <code>GaussianNB</code> can be tuned with just a single parameter: <code>var_smoothing</code>.</p>\n<p>Don't ask me what it does in theory: in practice you change it and your accuracy can boost. This leads to an easy tuning process that doesn't involves expensive <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html\">grid search</a>.</p>\n<pre><code class=\"language-python\">import sklearn.datasets as d\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import normalize\nfrom sklearn.naive_bayes import GaussianNB\n\ndef pick_best(X_train, X_test, y_train, y_test):\n    best = (None, 0)\n    for var_smoothing in range(-7, 1):\n        clf = GaussianNB(var_smoothing=pow(10, var_smoothing))\n        clf.fit(X_train, y_train)\n        y_pred = clf.predict(X_test)\n        accuracy = (y_pred == y_test).sum()\n        if accuracy &gt; best[1]:\n            best = (clf, accuracy)\n    print(&#039;best accuracy&#039;, best[1] / len(y_test))\n    return best[0]\n\niris = d.load_iris()\nX = normalize(iris.data)\ny = iris.target\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nclf = pick_best(X_train, X_test, y_train, y_test)</code></pre>\n<p>This simple procedure will train a bunch of classifiers with a different <code>var_smoothing</code> factor and pick the best performing one.</p>\n<h2>EloquentML integration</h2>\n<p>Once you have your trained classifier, porting it to C is as easy as always:</p>\n<pre><code class=\"language-python\">from micromlgen import port\n\nclf = pick_best()\nprint(port(clf))</code></pre>\n<p class=\"watchout\">Always remember to run </p>\n<pre><code>pip install --upgrade micromlgen</code></pre>\n</p>\n<p><code>port</code> is a magic method able to port many classifiers: it will automatically detect the proper converter for you.</p>\n<p>What does the exported code looks like?</p>\n<pre><code class=\"language-cpp\">#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class GaussianNB {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        float votes[3] = { 0.0f };\n                        float theta[4] = { 0 };\n                        float sigma[4] = { 0 };\n                        theta[0] = 0.801139789889; theta[1] = 0.54726920354; theta[2] = 0.234408773313; theta[3] = 0.039178084094;\n                        sigma[0] = 0.000366881742; sigma[1] = 0.000907992556; sigma[2] = 0.000740960787; sigma[3] = 0.000274925514;\n                        votes[0] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.748563871324; theta[1] = 0.349390892644; theta[2] = 0.536186138345; theta[3] = 0.166747384117;\n                        sigma[0] = 0.000529727082; sigma[1] = 0.000847956504; sigma[2] = 0.000690057342; sigma[3] = 0.000311828658;\n                        votes[1] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.704497203305; theta[1] = 0.318862439835; theta[2] = 0.593755956917; theta[3] = 0.217288784452;\n                        sigma[0] = 0.000363782089; sigma[1] = 0.000813846722; sigma[2] = 0.000415475678; sigma[3] = 0.000758478249;\n                        votes[2] = 0.333333333333 - gauss(x, theta, sigma);\n                        // return argmax of votes\n                        uint8_t classIdx = 0;\n                        float maxVotes = votes[0];\n\n                        for (uint8_t i = 1; i &lt; 3; i++) {\n                            if (votes[i] &gt; maxVotes) {\n                                classIdx = i;\n                                maxVotes = votes[i];\n                            }\n                        }\n\n                        return classIdx;\n                    }\n\n                protected:\n                    /**\n                    * Compute gaussian value\n                    */\n                    float gauss(float *x, float *theta, float *sigma) {\n                        float gauss = 0.0f;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            gauss += log(sigma[i]);\n                            gauss += pow(x[i] - theta[i], 2) / sigma[i];\n                        }\n\n                        return gauss;\n                    }\n                };\n            }\n        }\n    }</code></pre>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<p>As you can see, we need a couple of &quot;weight vectors&quot;:</p>\n<ul>\n<li><code>theta</code> is the mean of each feature</li>\n<li><code>sigma</code> is the standard deviation</li>\n</ul>\n<p>The computation is quite thin: just a couple of operations; the class with the highest score is then selected.</p>\n<h2>Benchmarks</h2>\n<p>Following there's a recap of a couple benchmarks I run on an Arduino Nano 33 Ble Sense.</p>\n<table>\n<thead>\n<tr>\n<th>Classifier</th>\n<th>Dataset</th>\n<th style=\"text-align: center;\">Flash</th>\n<th style=\"text-align: center;\">RAM</th>\n<th style=\"text-align: center;\">Execution time</th>\n<th style=\"text-align: center;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GaussianNB</td>\n<td>Iris (150x4)</td>\n<td style=\"text-align: center;\">82 kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">65 ms</td>\n<td style=\"text-align: center;\">97%</td>\n</tr>\n<tr>\n<td>LinearSVC</td>\n<td>Iris (150x4)</td>\n<td style=\"text-align: center;\">83 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">76 ms</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td>GaussianNB</td>\n<td>Breast cancer (80x40)</td>\n<td style=\"text-align: center;\">90 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">160 ms</td>\n<td style=\"text-align: center;\">77%</td>\n</tr>\n<tr>\n<td>LinearSVC</td>\n<td>Breast cancer (80x40)</td>\n<td style=\"text-align: center;\">112 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">378 ms</td>\n<td style=\"text-align: center;\">73%</td>\n</tr>\n<tr>\n<td>GaussianNB</td>\n<td>Wine (100x13)</td>\n<td style=\"text-align: center;\">85 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">130 ms</td>\n<td style=\"text-align: center;\">97%</td>\n</tr>\n<tr>\n<td>LinearSVC</td>\n<td>Wine (100x13)</td>\n<td style=\"text-align: center;\">89 Kb</td>\n<td style=\"text-align: center;\">42 Kb</td>\n<td style=\"text-align: center;\">125 ms</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n</tbody>\n</table>\n<p>We can see that the accuracy is on par with a linear SVM, reaching up to 97% on some datasets. Its semplicity shines with high-dimensional datasets (breast cancer) where execution time is half of the LinearSVC: I can see this pattern repeating with other real-world, medium-sized datasets.</p>\n<hr />\n<p>This is it, you can find the example project on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/GaussianNBClassificationExample/GaussianNBClassificationExample.ino\">Github</a>.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Are you looking for a top-performer classifiers with a minimal amount of parameters to tune? Look no further: Gaussian Naive Bayes is what you're looking for. And thanks to EloquentML you can now port it to your microcontroller.\n\n\n(Gaussian) Naive Bayes\nNaive Bayes classifiers are simple models based on the probability theory that can be used for classification.\nThey originate from the assumption of independence among the input variables. Even though this assumption doesn't hold true in the vast majority of the cases, they often perform very good at many classification tasks, so they're quite popular.\nGaussian Naive Bayes stack another (mostly wrong) assumption: that the variables exhibit a Gaussian probability distribution.\nI (and many others like me) will never understand how it is possible that so many wrong assumptions lead to such good performances!\nNevertheless, what is important to us is that sklearn implements GaussianNB, so we easily train such a classifier.\nThe most interesting part is that GaussianNB can be tuned with just a single parameter: var_smoothing.\nDon't ask me what it does in theory: in practice you change it and your accuracy can boost. This leads to an easy tuning process that doesn't involves expensive grid search.\nimport sklearn.datasets as d\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import normalize\nfrom sklearn.naive_bayes import GaussianNB\n\ndef pick_best(X_train, X_test, y_train, y_test):\n    best = (None, 0)\n    for var_smoothing in range(-7, 1):\n        clf = GaussianNB(var_smoothing=pow(10, var_smoothing))\n        clf.fit(X_train, y_train)\n        y_pred = clf.predict(X_test)\n        accuracy = (y_pred == y_test).sum()\n        if accuracy &gt; best[1]:\n            best = (clf, accuracy)\n    print(&#039;best accuracy&#039;, best[1] / len(y_test))\n    return best[0]\n\niris = d.load_iris()\nX = normalize(iris.data)\ny = iris.target\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\nclf = pick_best(X_train, X_test, y_train, y_test)\nThis simple procedure will train a bunch of classifiers with a different var_smoothing factor and pick the best performing one.\nEloquentML integration\nOnce you have your trained classifier, porting it to C is as easy as always:\nfrom micromlgen import port\n\nclf = pick_best()\nprint(port(clf))\nAlways remember to run \npip install --upgrade micromlgen\n\nport is a magic method able to port many classifiers: it will automatically detect the proper converter for you.\nWhat does the exported code looks like?\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class GaussianNB {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        float votes[3] = { 0.0f };\n                        float theta[4] = { 0 };\n                        float sigma[4] = { 0 };\n                        theta[0] = 0.801139789889; theta[1] = 0.54726920354; theta[2] = 0.234408773313; theta[3] = 0.039178084094;\n                        sigma[0] = 0.000366881742; sigma[1] = 0.000907992556; sigma[2] = 0.000740960787; sigma[3] = 0.000274925514;\n                        votes[0] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.748563871324; theta[1] = 0.349390892644; theta[2] = 0.536186138345; theta[3] = 0.166747384117;\n                        sigma[0] = 0.000529727082; sigma[1] = 0.000847956504; sigma[2] = 0.000690057342; sigma[3] = 0.000311828658;\n                        votes[1] = 0.333333333333 - gauss(x, theta, sigma);\n                        theta[0] = 0.704497203305; theta[1] = 0.318862439835; theta[2] = 0.593755956917; theta[3] = 0.217288784452;\n                        sigma[0] = 0.000363782089; sigma[1] = 0.000813846722; sigma[2] = 0.000415475678; sigma[3] = 0.000758478249;\n                        votes[2] = 0.333333333333 - gauss(x, theta, sigma);\n                        // return argmax of votes\n                        uint8_t classIdx = 0;\n                        float maxVotes = votes[0];\n\n                        for (uint8_t i = 1; i &lt; 3; i++) {\n                            if (votes[i] &gt; maxVotes) {\n                                classIdx = i;\n                                maxVotes = votes[i];\n                            }\n                        }\n\n                        return classIdx;\n                    }\n\n                protected:\n                    /**\n                    * Compute gaussian value\n                    */\n                    float gauss(float *x, float *theta, float *sigma) {\n                        float gauss = 0.0f;\n\n                        for (uint16_t i = 0; i &lt; 4; i++) {\n                            gauss += log(sigma[i]);\n                            gauss += pow(x[i] - theta[i], 2) / sigma[i];\n                        }\n\n                        return gauss;\n                    }\n                };\n            }\n        }\n    }\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nAs you can see, we need a couple of &quot;weight vectors&quot;:\n\ntheta is the mean of each feature\nsigma is the standard deviation\n\nThe computation is quite thin: just a couple of operations; the class with the highest score is then selected.\nBenchmarks\nFollowing there's a recap of a couple benchmarks I run on an Arduino Nano 33 Ble Sense.\n\n\n\nClassifier\nDataset\nFlash\nRAM\nExecution time\nAccuracy\n\n\n\n\nGaussianNB\nIris (150x4)\n82 kb\n42 Kb\n65 ms\n97%\n\n\nLinearSVC\nIris (150x4)\n83 Kb\n42 Kb\n76 ms\n99%\n\n\nGaussianNB\nBreast cancer (80x40)\n90 Kb\n42 Kb\n160 ms\n77%\n\n\nLinearSVC\nBreast cancer (80x40)\n112 Kb\n42 Kb\n378 ms\n73%\n\n\nGaussianNB\nWine (100x13)\n85 Kb\n42 Kb\n130 ms\n97%\n\n\nLinearSVC\nWine (100x13)\n89 Kb\n42 Kb\n125 ms\n99%\n\n\n\nWe can see that the accuracy is on par with a linear SVM, reaching up to 97% on some datasets. Its semplicity shines with high-dimensional datasets (breast cancer) where execution time is half of the LinearSVC: I can see this pattern repeating with other real-world, medium-sized datasets.\n\nThis is it, you can find the example project on Github.\nL'articolo EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino proviene da Eloquent Arduino Blog.",
            "date_published": "2020-08-02T10:44:36+02:00",
            "date_modified": "2020-08-02T11:36:42+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "ml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1079",
            "url": "https://eloquentarduino.github.io/2020/04/incremental-multiclass-classification-on-microcontrollers-one-vs-one/",
            "title": "Incremental multiclass classification on microcontrollers: One vs One",
            "content_html": "<p>In earlier posts I showed you can run incremental binary classification on your microcontroller with Stochastic Gradient Descent or Passive-Aggressive classifier. Now it is time to upgrade your toolbelt with a new item: One-vs-One multiclass classifier.</p>\n<p><span id=\"more-1079\"></span></p>\n<h2>One vs One</h2>\n<p>Many classifiers are, by nature, binary: they can only distinguish the positive class from the negative one. Many of real-world problems, however, are multiclass: you have 3 or more possible outcomes to distinguish from.</p>\n<p>There are a couple of ways to achieve this:</p>\n<ol>\n<li><strong>One vs All</strong>: if your classifier is able to output a confidence score of its prediction, for N classes you train N classifiers, each able to recognize a single class. During inference, you pick the &quot;most confident&quot; one.</li>\n<li><strong>One vs One</strong>: for N classes, you train N * (N-1) / 2 classifiers, one for each couple of classes. During inference, each classifier makes a prediction and you pick the class with the highest number of votes.</li>\n</ol>\n<p>Since SGD and Passive-Aggressive don't output a confidence score, I implemented the One vs One algorithm to tackle the multiclass classification problem on microcontrollers.</p>\n<p>Actually, One vs One is not a new type of classifier: it is really a &quot;coordinator&quot; class that sorts which samples go to which classifier. You can still choose your own classifier type to use.</p>\n<p>As SGD and Passive-Aggressive, OneVsOne implements the classifier interface, so you will use the well known <code>fitOne</code> and <code>predict</code> methods.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2>Example code</h2>\n<pre><code class=\"language-cpp\">// Esp32 has some problems with min/max\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n// you will actually need only one of SGD or PassiveAggressive\n#include &quot;EloquentSGD.h&quot;\n#include &quot;EloquentPassiveAggressive.h&quot;\n#include &quot;EloquentOneVsOne.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n// this file defines NUM_FEATURES, NUM_CLASSES, TRAIN_SAMPLES and TEST_SAMPLES\n#include &quot;dataset.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n}\n\nvoid loop() {\n  AccuracyScorer scorer;\n  // OneVsOne needs the actual classifier class, the number of features and the number of classes\n  OneVsOne&lt;SGD&lt;FEATURES_DIM&gt;, FEATURES_DIM, NUM_CLASSES&gt; clf;\n\n  // clf.set() propagates the configuration to the actual classifiers\n  // if a parameter does not exists on the classifier, it does nothing\n  // in this example, alpha and momentum refer to SGD, C to Passive-Aggressive\n  clf.set(&quot;alpha&quot;, 1);\n  clf.set(&quot;momentum&quot;, 0.7);\n  clf.set(&quot;C&quot;, 0.1);\n\n  // fit\n  // I noticed that repeating the training a few times over the same dataset increases performance  to a certain extent: if you re-train it too much, performance will decay\n  for (unsigned int i = 0; i &lt; TRAIN_SAMPLES * 5; i++) {\n      clf.fitOne(X_train[i % TRAIN_SAMPLES], y_train[i % TRAIN_SAMPLES]);\n  }\n\n  // predict\n  for (int i = 0; i &lt; TEST_SAMPLES; i++) {\n      int y_true = y_test[i];\n      int y_pred = clf.predict(X_test[i]);\n\n      Serial.print(&quot;Predicted &quot;);\n      Serial.print(y_pred);\n      Serial.print(&quot; vs &quot;);\n      Serial.println(y_true);\n      scorer.scoreOne(y_true, y_pred);\n  }\n\n  Serial.print(&quot;Accuracy = &quot;);\n  Serial.print(scorer.accuracy() * 100);\n  Serial.print(&quot; out of &quot;);\n  Serial.print(scorer.support());\n  Serial.println(&quot; samples&quot;);\n  delay(30000);\n}</code></pre>\n<p>If you refer to the previous posts on <a href=\"/2020/04/stochastic-gradient-descent-on-your-microcontroller/\">SGD</a> and <a href=\"/2020/04/passive-aggressive-classifier-for-embedded-devices/\">Passive-Aggressive</a>, you'll notice that you would be able to replace one with the other and your code will change by <strong>1 single line only</strong>. This let's you experiment to find the best configuration for your project without hassle.</p>\n<h2>Accuracy</h2>\n<p>Well, accuracy vary.</p>\n<p>In my tests, I couldn't get predictable accuracy on all datasets. I couldn't even get acceptable accuracy on the Iris dataset (60% max). But I got 90% accuracy on the Digits dataset from scikit-learn with 6 classes.</p>\n<p>You have to experiment. Try Passive-Aggressive with many <code>C</code> values. If it doesn't work, try SGD with varying <code>momentum</code> and <code>alpha</code>. Try to repeat the training over the dataset 5, 10 times.</p>\n<p>In a next post I'll report my benchmarks so you can see what works for you and what not.<br />\nThis is an emerging field for me, so I will need time to master it.</p>\n<hr />\n<p>As always, you can find the examle on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/OvOExample/OvOExample.ino\">Github</a> with a the dataset to experiment with.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/04/incremental-multiclass-classification-on-microcontrollers-one-vs-one/\">Incremental multiclass classification on microcontrollers: One vs One</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "In earlier posts I showed you can run incremental binary classification on your microcontroller with Stochastic Gradient Descent or Passive-Aggressive classifier. Now it is time to upgrade your toolbelt with a new item: One-vs-One multiclass classifier.\n\nOne vs One\nMany classifiers are, by nature, binary: they can only distinguish the positive class from the negative one. Many of real-world problems, however, are multiclass: you have 3 or more possible outcomes to distinguish from.\nThere are a couple of ways to achieve this:\n\nOne vs All: if your classifier is able to output a confidence score of its prediction, for N classes you train N classifiers, each able to recognize a single class. During inference, you pick the &quot;most confident&quot; one.\nOne vs One: for N classes, you train N * (N-1) / 2 classifiers, one for each couple of classes. During inference, each classifier makes a prediction and you pick the class with the highest number of votes.\n\nSince SGD and Passive-Aggressive don't output a confidence score, I implemented the One vs One algorithm to tackle the multiclass classification problem on microcontrollers.\nActually, One vs One is not a new type of classifier: it is really a &quot;coordinator&quot; class that sorts which samples go to which classifier. You can still choose your own classifier type to use.\nAs SGD and Passive-Aggressive, OneVsOne implements the classifier interface, so you will use the well known fitOne and predict methods.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nExample code\n// Esp32 has some problems with min/max\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n// you will actually need only one of SGD or PassiveAggressive\n#include &quot;EloquentSGD.h&quot;\n#include &quot;EloquentPassiveAggressive.h&quot;\n#include &quot;EloquentOneVsOne.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n// this file defines NUM_FEATURES, NUM_CLASSES, TRAIN_SAMPLES and TEST_SAMPLES\n#include &quot;dataset.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n}\n\nvoid loop() {\n  AccuracyScorer scorer;\n  // OneVsOne needs the actual classifier class, the number of features and the number of classes\n  OneVsOne&lt;SGD&lt;FEATURES_DIM&gt;, FEATURES_DIM, NUM_CLASSES&gt; clf;\n\n  // clf.set() propagates the configuration to the actual classifiers\n  // if a parameter does not exists on the classifier, it does nothing\n  // in this example, alpha and momentum refer to SGD, C to Passive-Aggressive\n  clf.set(&quot;alpha&quot;, 1);\n  clf.set(&quot;momentum&quot;, 0.7);\n  clf.set(&quot;C&quot;, 0.1);\n\n  // fit\n  // I noticed that repeating the training a few times over the same dataset increases performance  to a certain extent: if you re-train it too much, performance will decay\n  for (unsigned int i = 0; i &lt; TRAIN_SAMPLES * 5; i++) {\n      clf.fitOne(X_train[i % TRAIN_SAMPLES], y_train[i % TRAIN_SAMPLES]);\n  }\n\n  // predict\n  for (int i = 0; i &lt; TEST_SAMPLES; i++) {\n      int y_true = y_test[i];\n      int y_pred = clf.predict(X_test[i]);\n\n      Serial.print(&quot;Predicted &quot;);\n      Serial.print(y_pred);\n      Serial.print(&quot; vs &quot;);\n      Serial.println(y_true);\n      scorer.scoreOne(y_true, y_pred);\n  }\n\n  Serial.print(&quot;Accuracy = &quot;);\n  Serial.print(scorer.accuracy() * 100);\n  Serial.print(&quot; out of &quot;);\n  Serial.print(scorer.support());\n  Serial.println(&quot; samples&quot;);\n  delay(30000);\n}\nIf you refer to the previous posts on SGD and Passive-Aggressive, you'll notice that you would be able to replace one with the other and your code will change by 1 single line only. This let's you experiment to find the best configuration for your project without hassle.\nAccuracy\nWell, accuracy vary.\nIn my tests, I couldn't get predictable accuracy on all datasets. I couldn't even get acceptable accuracy on the Iris dataset (60% max). But I got 90% accuracy on the Digits dataset from scikit-learn with 6 classes.\nYou have to experiment. Try Passive-Aggressive with many C values. If it doesn't work, try SGD with varying momentum and alpha. Try to repeat the training over the dataset 5, 10 times.\nIn a next post I'll report my benchmarks so you can see what works for you and what not.\nThis is an emerging field for me, so I will need time to master it.\n\nAs always, you can find the examle on Github with a the dataset to experiment with.\nL'articolo Incremental multiclass classification on microcontrollers: One vs One proviene da Eloquent Arduino Blog.",
            "date_published": "2020-04-26T10:01:14+02:00",
            "date_modified": "2020-04-26T11:52:29+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "incremental-learning",
                "microml",
                "ml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=864",
            "url": "https://eloquentarduino.github.io/2020/01/easy-tinyml-on-esp32-and-arduino/",
            "title": "Easy Tensorflow TinyML on ESP32 and Arduino",
            "content_html": "<p>In this post I will show you how to easily deploy your Tensorflow Lite model to an ESP32 using the Arduino IDE <strong>without any compilation stuff</strong>.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/01/tf-arduino-esp.png\" alt=\"tf arduino esp\" /></p>\n<p><span id=\"more-864\"></span></p>\n<p>So I finally settled on giving a try to TinyML, which is a way to deploy Tensorflow Lite models to microcontrollers.<br />\nAs a first step, I downloaded the free chapters from <a href=\"https://tinymlbook.com/\">the TinyML book website</a> and rapidly skimmed through them.</p>\n<p>Let me say that, even if it starts from &quot;too beginner&quot; level for me (they explain why you need to use the arrow instead of the point to access a pointer's property), it is a very well written book. They uncover every single aspect you may encounter during your first steps and give a very sound introduction to the general topic of training, validating and testing a dataset on a model.</p>\n<p>If I will go on with this TinyML stuff, I'll probably buy a copy: I strongly recommend you to at least read the free sample.</p>\n<p>Once done reading the 6 chapters, I wanted to try the described tutorial on my ESP32. Sadly, it is not mentioned in the supported boards on the book, so I had to solve it by myself.</p>\n<p>In this post I'm going to make a sort of recap of my learnings about the steps you need to follow to implement TF models to a microcontroller and introduce you to a tiny library I wrote for the purpose of facilitating the deployment in the Arduino IDE: <a href=\"https://github.com/eloquentarduino/EloquentTinyML\">EloquentTinyML</a>.</p>\n<h2>Building our first model</h2>\n<p>First of all, we need a model to deploy.</p>\n<p>The book guides us on building a neural network capable of predicting the sine value of a given number, in the range from 0 to Pi (3.14).</p>\n<p>It's an easy model to get started (the &quot;Hello world&quot; of machine learning, according to the authors), so we'll stick with it.</p>\n<p>I won't go into too much details about generating data and training the classifier, because I suppose you already know that part if you want to port Tensorflow on a microcontroller.</p>\n<p>Here's the code from the book.</p>\n<pre><code class=\"language-python\">import math\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras import layers\n\ndef get_model():\n    SAMPLES = 1000\n    np.random.seed(1337)\n    x_values = np.random.uniform(low=0, high=2*math.pi, size=SAMPLES)\n    # shuffle and add noise\n    np.random.shuffle(x_values)\n    y_values = np.sin(x_values)\n    y_values += 0.1 * np.random.randn(*y_values.shape)\n\n    # split into train, validation, test\n    TRAIN_SPLIT =  int(0.6 * SAMPLES)\n    TEST_SPLIT = int(0.2 * SAMPLES + TRAIN_SPLIT)\n    x_train, x_test, x_validate = np.split(x_values, [TRAIN_SPLIT, TEST_SPLIT])\n    y_train, y_test, y_validate = np.split(y_values, [TRAIN_SPLIT, TEST_SPLIT])\n\n    # create a NN with 2 layers of 16 neurons\n    model = tf.keras.Sequential()\n    model.add(layers.Dense(16, activation=&#039;relu&#039;, input_shape=(1,)))\n    model.add(layers.Dense(16, activation=&#039;relu&#039;))\n    model.add(layers.Dense(1))\n    model.compile(optimizer=&#039;rmsprop&#039;, loss=&#039;mse&#039;, metrics=[&#039;mae&#039;])\n    model.fit(x_train, y_train, epochs=200, batch_size=16,\n                        validation_data=(x_validate, y_validate))\n    return model</code></pre>\n<h2>Exporting the model</h2>\n<p>Now that we have a model, we need to convert it into a form ready to be deployed on our microcontroller. This is actually just an array of bytes that the TF interpreter will read to recreate the model.</p>\n<pre><code class=\"language-python\">model = get_model()\nconverter = tf.lite.TFLiteConverter.from_keras_model(model)\nconverter.optimizations = [tf.lite.Optimize.OPTIMIZE_FOR_SIZE]\ntflite_model = converter.convert()\n\n# Save the model to disk\nopen(&quot;sine_model_quantized.tflite&quot;, &quot;wb&quot;).write(tflite_model)</code></pre>\n<p>Then you have to convert to a C array in the command line.</p>\n<pre><code class=\"language-bash\">xxd -i sine_model_quantized.tflite &gt; sine_model_quantized.cc</code></pre>\n<p>This is copy-paste code that hardly would change, so, for ease my development cycle, I wrapped this little snippet in a tiny package you can use: it's called <code>tinymlgen</code>.</p>\n<pre><code class=\"language-bash\">pip install tinymlgen</code></pre>\n<pre><code class=\"language-python\">from tinymlgen import port\n\nmodel = get_model()\nc_code = port(model, pretty_print=True)\nprint(c_code)</code></pre>\n<p>I point you to the <a href=\"https://github.com/eloquentarduino/tinymlgen\">Github repo</a> for a couple more options you can configure. </p>\n<p>Using this package, you don't have to open a terminal and use the <code>xxd</code> program to get a usable result.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2>Use the model</h2>\n<p>Now it is finally the time we deploy the model on our microcontroller. </p>\n<p>This part can be tricky, actually, if you don't have one of the supported boards in the book (Arduino Nano 33, SparkFun Edge or STM32F746G Discovery kit). </p>\n<p>I tried just setting &quot;ESP32&quot; as my target in the Arduino IDE and I got tons of errors.</p>\n<p>Luckily for us, a man called Wezley Sherman wrote a tutorial on <a href=\"https://towardsdatascience.com/tensorflow-meet-the-esp32-3ac36d7f32c7\">how to get a TinyML project to compile using the PlatformIO environment</a>. He saved me the effort to try to fix all the broken import errors on my own.</p>\n<p>Since I could get the project to compile using PlatformIO (which I don't use in my everyday tinkering), I settled to get the project to compile in the Arduino IDE.</p>\n<p>Fortunately, it was not difficult at all, so I can finally bring you this library that does all the heavy lifting for you.</p>\n<p>Thanks to the library, you won't need to download the full Tensorflow Lite framework and compile it on your own machine: it has been already done for you.</p>\n<p>As an added bonus, I created a wrapper class that incapsulates all the boring repetitive stuff, so you can focus solely on the application logic.</p>\n<p>Install the library from the library manager in the Arduino IDE: search for &quot;EloquentTinyML&quot;, or from <a href=\"https://github.com/eloquentarduino/EloquentTinyML\">Github</a> first.</p>\n<pre><code class=\"language-bash\">git clone https://github.com/eloquentarduino/EloquentTinyML.git</code></pre>\n<hr /><p><em>#EloquentTinyML escapes you from compiling Tensforflow on your own machine</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2020%2F01%2Feasy-tinyml-on-esp32-and-arduino%2F&#038;text=%23EloquentTinyML%20escapes%20you%20from%20compiling%20Tensforflow%20on%20your%20own%20machine&#038;via=EloquentArduino&#038;related=EloquentArduino' target='_blank' rel=\"noopener noreferrer\" >Click To Tweet</a><br /><hr />\n<p>Here is an example on how you use it.</p>\n<pre><code class=\"language-cpp\">#include &quot;EloquentTinyML.h&quot;\n// sine_model.h contains the array you exported from the previous step\n// with either xxd or tinymlgen\n#include &quot;sine_model.h&quot;\n\n#define NUMBER_OF_INPUTS 1\n#define NUMBER_OF_OUTPUTS 1\n// in future projects you may need to tweak this value\n// it&#039;s a trial and error process\n#define TENSOR_ARENA_SIZE 2*1024\n\nEloquent::TinyML::TfLite&lt;NUMBER_OF_INPUTS, NUMBER_OF_OUTPUTS, TENSOR_ARENA_SIZE&gt; ml(sine_model);\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\nvoid loop() {\n    // pick up a random x and predict its sine\n    float x = 3.14 * random(100) / 100;\n    float y = sin(x);\n    float input[1] = { x };\n    float predicted = ml.predict(input);\n\n    Serial.print(&quot;sin(&quot;);\n    Serial.print(x);\n    Serial.print(&quot;) = &quot;);\n    Serial.print(y);\n    Serial.print(&quot;\\t predicted: &quot;);\n    Serial.println(predicted);\n    delay(1000);\n}</code></pre>\n<p>Does it look easy to use? I bet so.</p>\n<p>For simple cases like this example where you have a single output, the <code>predict</code> method returns that output so you can esaily assign it to a variable.</p>\n<p>If this is not the case and you expect multiple output from your model, you have to declare an output array.</p>\n<pre><code class=\"language-cpp\">float input[10] = { ... };\nfloat output[5] = { 0 };\n\nml.predict(input, output);</code></pre>\n<p>You will find the complete code on <a href=\"https://github.com/eloquentarduino/EloquentTinyML/blob/master/examples/SineExample/SineExample.ino\">Github</a>, with the <code>sine_model.h</code> file too.</p>\n<h2>Wrapping up</h2>\n<p>I hoped this post helped you kickstart your next TinyML project on your ESP32.</p>\n<p>It served me as a foundation for the next experiments I'm willing to do on this platform which is really in its early stages, so needs a lot of investigation about its capabilities.</p>\n<p>I plan to do a comparison with my MicroML framework when I get more experience in both, so staty tuned for the upcoming updates.</p>\n<h2>Disclaimer</h2>\n<p>I tested the library on both Ubuntu 18.04 and Windows 10 64 bit: if you are on a different platform and get compiling errors, please let me know in the comments so I can fix them.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/01/easy-tinyml-on-esp32-and-arduino/\">Easy Tensorflow TinyML on ESP32 and Arduino</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "In this post I will show you how to easily deploy your Tensorflow Lite model to an ESP32 using the Arduino IDE without any compilation stuff.\n\n\nSo I finally settled on giving a try to TinyML, which is a way to deploy Tensorflow Lite models to microcontrollers.\nAs a first step, I downloaded the free chapters from the TinyML book website and rapidly skimmed through them.\nLet me say that, even if it starts from &quot;too beginner&quot; level for me (they explain why you need to use the arrow instead of the point to access a pointer's property), it is a very well written book. They uncover every single aspect you may encounter during your first steps and give a very sound introduction to the general topic of training, validating and testing a dataset on a model.\nIf I will go on with this TinyML stuff, I'll probably buy a copy: I strongly recommend you to at least read the free sample.\nOnce done reading the 6 chapters, I wanted to try the described tutorial on my ESP32. Sadly, it is not mentioned in the supported boards on the book, so I had to solve it by myself.\nIn this post I'm going to make a sort of recap of my learnings about the steps you need to follow to implement TF models to a microcontroller and introduce you to a tiny library I wrote for the purpose of facilitating the deployment in the Arduino IDE: EloquentTinyML.\nBuilding our first model\nFirst of all, we need a model to deploy.\nThe book guides us on building a neural network capable of predicting the sine value of a given number, in the range from 0 to Pi (3.14).\nIt's an easy model to get started (the &quot;Hello world&quot; of machine learning, according to the authors), so we'll stick with it.\nI won't go into too much details about generating data and training the classifier, because I suppose you already know that part if you want to port Tensorflow on a microcontroller.\nHere's the code from the book.\nimport math\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras import layers\n\ndef get_model():\n    SAMPLES = 1000\n    np.random.seed(1337)\n    x_values = np.random.uniform(low=0, high=2*math.pi, size=SAMPLES)\n    # shuffle and add noise\n    np.random.shuffle(x_values)\n    y_values = np.sin(x_values)\n    y_values += 0.1 * np.random.randn(*y_values.shape)\n\n    # split into train, validation, test\n    TRAIN_SPLIT =  int(0.6 * SAMPLES)\n    TEST_SPLIT = int(0.2 * SAMPLES + TRAIN_SPLIT)\n    x_train, x_test, x_validate = np.split(x_values, [TRAIN_SPLIT, TEST_SPLIT])\n    y_train, y_test, y_validate = np.split(y_values, [TRAIN_SPLIT, TEST_SPLIT])\n\n    # create a NN with 2 layers of 16 neurons\n    model = tf.keras.Sequential()\n    model.add(layers.Dense(16, activation=&#039;relu&#039;, input_shape=(1,)))\n    model.add(layers.Dense(16, activation=&#039;relu&#039;))\n    model.add(layers.Dense(1))\n    model.compile(optimizer=&#039;rmsprop&#039;, loss=&#039;mse&#039;, metrics=[&#039;mae&#039;])\n    model.fit(x_train, y_train, epochs=200, batch_size=16,\n                        validation_data=(x_validate, y_validate))\n    return model\nExporting the model\nNow that we have a model, we need to convert it into a form ready to be deployed on our microcontroller. This is actually just an array of bytes that the TF interpreter will read to recreate the model.\nmodel = get_model()\nconverter = tf.lite.TFLiteConverter.from_keras_model(model)\nconverter.optimizations = [tf.lite.Optimize.OPTIMIZE_FOR_SIZE]\ntflite_model = converter.convert()\n\n# Save the model to disk\nopen(&quot;sine_model_quantized.tflite&quot;, &quot;wb&quot;).write(tflite_model)\nThen you have to convert to a C array in the command line.\nxxd -i sine_model_quantized.tflite &gt; sine_model_quantized.cc\nThis is copy-paste code that hardly would change, so, for ease my development cycle, I wrapped this little snippet in a tiny package you can use: it's called tinymlgen.\npip install tinymlgen\nfrom tinymlgen import port\n\nmodel = get_model()\nc_code = port(model, pretty_print=True)\nprint(c_code)\nI point you to the Github repo for a couple more options you can configure. \nUsing this package, you don't have to open a terminal and use the xxd program to get a usable result.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nUse the model\nNow it is finally the time we deploy the model on our microcontroller. \nThis part can be tricky, actually, if you don't have one of the supported boards in the book (Arduino Nano 33, SparkFun Edge or STM32F746G Discovery kit). \nI tried just setting &quot;ESP32&quot; as my target in the Arduino IDE and I got tons of errors.\nLuckily for us, a man called Wezley Sherman wrote a tutorial on how to get a TinyML project to compile using the PlatformIO environment. He saved me the effort to try to fix all the broken import errors on my own.\nSince I could get the project to compile using PlatformIO (which I don't use in my everyday tinkering), I settled to get the project to compile in the Arduino IDE.\nFortunately, it was not difficult at all, so I can finally bring you this library that does all the heavy lifting for you.\nThanks to the library, you won't need to download the full Tensorflow Lite framework and compile it on your own machine: it has been already done for you.\nAs an added bonus, I created a wrapper class that incapsulates all the boring repetitive stuff, so you can focus solely on the application logic.\nInstall the library from the library manager in the Arduino IDE: search for &quot;EloquentTinyML&quot;, or from Github first.\ngit clone https://github.com/eloquentarduino/EloquentTinyML.git\n#EloquentTinyML escapes you from compiling Tensforflow on your own machineClick To Tweet\nHere is an example on how you use it.\n#include &quot;EloquentTinyML.h&quot;\n// sine_model.h contains the array you exported from the previous step\n// with either xxd or tinymlgen\n#include &quot;sine_model.h&quot;\n\n#define NUMBER_OF_INPUTS 1\n#define NUMBER_OF_OUTPUTS 1\n// in future projects you may need to tweak this value\n// it&#039;s a trial and error process\n#define TENSOR_ARENA_SIZE 2*1024\n\nEloquent::TinyML::TfLite&lt;NUMBER_OF_INPUTS, NUMBER_OF_OUTPUTS, TENSOR_ARENA_SIZE&gt; ml(sine_model);\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\nvoid loop() {\n    // pick up a random x and predict its sine\n    float x = 3.14 * random(100) / 100;\n    float y = sin(x);\n    float input[1] = { x };\n    float predicted = ml.predict(input);\n\n    Serial.print(&quot;sin(&quot;);\n    Serial.print(x);\n    Serial.print(&quot;) = &quot;);\n    Serial.print(y);\n    Serial.print(&quot;\\t predicted: &quot;);\n    Serial.println(predicted);\n    delay(1000);\n}\nDoes it look easy to use? I bet so.\nFor simple cases like this example where you have a single output, the predict method returns that output so you can esaily assign it to a variable.\nIf this is not the case and you expect multiple output from your model, you have to declare an output array.\nfloat input[10] = { ... };\nfloat output[5] = { 0 };\n\nml.predict(input, output);\nYou will find the complete code on Github, with the sine_model.h file too.\nWrapping up\nI hoped this post helped you kickstart your next TinyML project on your ESP32.\nIt served me as a foundation for the next experiments I'm willing to do on this platform which is really in its early stages, so needs a lot of investigation about its capabilities.\nI plan to do a comparison with my MicroML framework when I get more experience in both, so staty tuned for the upcoming updates.\nDisclaimer\nI tested the library on both Ubuntu 18.04 and Windows 10 64 bit: if you are on a different platform and get compiling errors, please let me know in the comments so I can fix them.\nL'articolo Easy Tensorflow TinyML on ESP32 and Arduino proviene da Eloquent Arduino Blog.",
            "date_published": "2020-01-25T20:36:29+01:00",
            "date_modified": "2020-06-03T19:10:18+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "ml",
                "tinyml",
                "Arduino Machine learning"
            ]
        }
    ]
}