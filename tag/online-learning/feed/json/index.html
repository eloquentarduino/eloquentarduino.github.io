{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/tag/online-learning/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/tag/online-learning/",
    "feed_url": "https://eloquentarduino.github.io/tag/online-learning/feed/json/",
    "language": "en-US",
    "title": "online-learning &#8211; Eloquent Arduino Blog",
    "description": "Machine learning on Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/?p=1062",
            "url": "https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/",
            "title": "Stochastic Gradient Descent on your microcontroller",
            "content_html": "<p>Stochastic gradient descent is a well know algorithm to train classifiers in an incremental fashion: that is, as training samples become available. This saves you critical memory on tiny devices while still achieving <strong>top performance</strong>! Now you can use it on your microcontroller with ease.</p>\n<p><span id=\"more-1062\"></span></p>\n<h2>A brief recap on Stochastic Gradient Descent</h2>\n<p>If you ever worked with Machine learning, you surely know about <a href=\"https://en.wikipedia.org/wiki/Gradient_descent\">Gradient descent</a>: it is an iterative algorithm to optimize a loss function. </p>\n<p>It is much general-purpose, in the sense that it is not bound to a particular application, but it has been heavily used in Neural networks in the recent years.</p>\n<p>Yet, it can be used as a classifier on its own if you set its loss function as the classification error.</p>\n<p><img src=\"https://mccormickml.com/assets/GradientDescent/GradientDescentOfMSETable.png\" alt=\"Update rule of Gradient descent\" /></p>\n<p>This is the core update rule of Gradient descent: quite simple.</p>\n<p>As you see, there's a summation in the formula: this means we need to cycle through the entire training set to compute the update to the weights.</p>\n<p>In case of large datasets, this can be slow or not possible at all.</p>\n<p>And requires a lot of memory.</p>\n<p>And we don't have memory on microcontrollers.</p>\n<p>So we need <a href=\"https://en.wikipedia.org/wiki/Stochastic_gradient_descent\">Stochastic gradient descent</a>.</p>\n<p>Stochastic gradient descent has the same exact update rule, but it is applied on the single training sample.</p>\n<p>Imagine the summation goes from 1 to 1, instead of m.</p>\n<p>That's it.</p>\n<div class=\"heateor_sss_sharing_container heateor_sss_horizontal_sharing\" ss-offset=\"0\" heateor-sss-data-href='https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/'><ul class=\"heateor_sss_sharing_ul\"><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" alt=\"Facebook\" Title=\"Facebook\" class=\"heateorSssSharing heateorSssFacebookBackground\" onclick='heateorSssPopup(\"https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Feloquent.blog%2F2020%2F04%2Fstochastic-gradient-descent-on-your-microcontroller%2F\")'><ss style=\"display:block;border-radius:999px;\" class=\"heateorSssSharingSvg heateorSssFacebookSvg\"></ss></i></li><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" alt=\"Twitter\" Title=\"Twitter\" class=\"heateorSssSharing heateorSssTwitterBackground\" onclick='heateorSssPopup(\"http://twitter.com/intent/tweet?via=EloquentArduino&text=Stochastic%20Gradient%20Descent%20on%20your%20microcontroller&url=http%3A%2F%2Feloquent.blog%2F2020%2F04%2Fstochastic-gradient-descent-on-your-microcontroller%2F\")'><ss style=\"display:block;border-radius:999px;\" class=\"heateorSssSharingSvg heateorSssTwitterSvg\"></ss></i></li><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" alt=\"Linkedin\" Title=\"Linkedin\" class=\"heateorSssSharing heateorSssLinkedinBackground\" onclick='heateorSssPopup(\"http://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Feloquent.blog%2F2020%2F04%2Fstochastic-gradient-descent-on-your-microcontroller%2F&title=Stochastic%20Gradient%20Descent%20on%20your%20microcontroller\")'><ss style=\"display:block;border-radius:999px;\" class=\"heateorSssSharingSvg heateorSssLinkedinSvg\"></ss></i></li><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" title=\"More\" alt=\"More\" class=\"heateorSssSharing heateorSssMoreBackground\" onclick=\"heateorSssMoreSharingPopup(this, 'https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/', 'Stochastic%20Gradient%20Descent%20on%20your%20microcontroller', '' )\" ><ss style=\"display:block\" class=\"heateorSssSharingSvg heateorSssMoreSvg\"></ss></i></li></ul><div class=\"heateorSssClear\"></div></div>\n<h2>How to use</h2>\n<p>The pattern of use is similar to that of the <a href=\"/2020/04/passive-aggressive-classifier-for-embedded-devices/\">Passive Aggressive classifier</a>: you have the <code>fitOne</code> and <code>predict</code> methods.</p>\n<p>First of all, <a href=\"https://github.com/eloquentarduino/EloquentMicroML\">download the library from Github</a>.</p>\n<pre><code class=\"language-c\">#include &lt;EloquentSGD.h&gt;\n#include &lt;EloquentAccuracyScorer.h&gt;\n#include &quot;iris.h&quot;\n\n#define VERBOSE\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n    Serial.begin(115200);\n    delay(3000);\n}\n\nvoid loop() {\n    int trainSamples;\n    int retrainingCycles;\n    SGD&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    // ....\n\n    // train\n    for (uint16_t cycle = 0; cycle &lt; retrainingCycles; cycle++)\n        for (uint16_t i = 0; i &lt; trainSamples; i++)\n            clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i];\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}</code></pre>\n<p>In this case we're working with known datasets, so we cycle through them for the training, but if you're learning &quot;on-line&quot;, from samples generated over time, it will work exactly the same.</p>\n<h2>A bit of momentum</h2>\n<p>Stochastic gradient descent works quite well out of the box in most cases.</p>\n<p>Sometimes, however, its updates can start &quot;oscillating&quot;.</p>\n<p><img src=\"https://media.springernature.com/original/springer-static/image/chp%3A10.1007%2F978-1-4842-4470-8_33/MediaObjects/463852_1_En_33_Fig1_HTML.jpg\" alt=\"SGD with and without momentum\" /></p>\n<p>To solve this problem, it <a href=\"https://doi.org/10.1038%2F323533a0\">has been proposed</a> the <strong>momentum</strong> technique, which can both speed up learning and increase the accuracy.</p>\n<p>In my personal tests, I was able to achieve up to +5% in accuracy on the majority of datasets.</p>\n<p>To use it, you only need to set a <em>decay factor</em> between 0 and 1.</p>\n<pre><code class=\"language-c\">SGD clf;\n\nclf.momentum(0.5);</code></pre>\n<h2>Run on your own</h2>\n<p>On <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/SGDExample/SGDExample.ino\">Github</a> you can find the full example with some benchmark datasets to try on your own.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the (more than) monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<p>The example is interactive an will ask you how many samples to use for the training and how many times to cycle through them.</p>\n<p>This is something you should consider: if you have a training set and can store it somehow (in memory or on Flash for example), re-presenting the same samples to the SGD classifier could (and probably will) increase its performance if done correctly.</p>\n<p>This happens because the algorithm needs some time to converge and if it doesn't receive enough samples it won't learn properly.</p>\n<p>Of course, if you re-use the same samples over and over again, you're likely to overfit.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/\">Stochastic Gradient Descent on your microcontroller</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Stochastic gradient descent is a well know algorithm to train classifiers in an incremental fashion: that is, as training samples become available. This saves you critical memory on tiny devices while still achieving top performance! Now you can use it on your microcontroller with ease.\n\nA brief recap on Stochastic Gradient Descent\nIf you ever worked with Machine learning, you surely know about Gradient descent: it is an iterative algorithm to optimize a loss function. \nIt is much general-purpose, in the sense that it is not bound to a particular application, but it has been heavily used in Neural networks in the recent years.\nYet, it can be used as a classifier on its own if you set its loss function as the classification error.\n\nThis is the core update rule of Gradient descent: quite simple.\nAs you see, there's a summation in the formula: this means we need to cycle through the entire training set to compute the update to the weights.\nIn case of large datasets, this can be slow or not possible at all.\nAnd requires a lot of memory.\nAnd we don't have memory on microcontrollers.\nSo we need Stochastic gradient descent.\nStochastic gradient descent has the same exact update rule, but it is applied on the single training sample.\nImagine the summation goes from 1 to 1, instead of m.\nThat's it.\n\nHow to use\nThe pattern of use is similar to that of the Passive Aggressive classifier: you have the fitOne and predict methods.\nFirst of all, download the library from Github.\n#include &lt;EloquentSGD.h&gt;\n#include &lt;EloquentAccuracyScorer.h&gt;\n#include &quot;iris.h&quot;\n\n#define VERBOSE\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n    Serial.begin(115200);\n    delay(3000);\n}\n\nvoid loop() {\n    int trainSamples;\n    int retrainingCycles;\n    SGD&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    // ....\n\n    // train\n    for (uint16_t cycle = 0; cycle &lt; retrainingCycles; cycle++)\n        for (uint16_t i = 0; i &lt; trainSamples; i++)\n            clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i];\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}\nIn this case we're working with known datasets, so we cycle through them for the training, but if you're learning &quot;on-line&quot;, from samples generated over time, it will work exactly the same.\nA bit of momentum\nStochastic gradient descent works quite well out of the box in most cases.\nSometimes, however, its updates can start &quot;oscillating&quot;.\n\nTo solve this problem, it has been proposed the momentum technique, which can both speed up learning and increase the accuracy.\nIn my personal tests, I was able to achieve up to +5% in accuracy on the majority of datasets.\nTo use it, you only need to set a decay factor between 0 and 1.\nSGD clf;\n\nclf.momentum(0.5);\nRun on your own\nOn Github you can find the full example with some benchmark datasets to try on your own.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nThe example is interactive an will ask you how many samples to use for the training and how many times to cycle through them.\nThis is something you should consider: if you have a training set and can store it somehow (in memory or on Flash for example), re-presenting the same samples to the SGD classifier could (and probably will) increase its performance if done correctly.\nThis happens because the algorithm needs some time to converge and if it doesn't receive enough samples it won't learn properly.\nOf course, if you re-use the same samples over and over again, you're likely to overfit.\nL'articolo Stochastic Gradient Descent on your microcontroller proviene da Eloquent Arduino Blog.",
            "date_published": "2020-04-10T19:43:45+02:00",
            "date_modified": "2020-04-12T19:31:52+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "online-learning",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1050",
            "url": "https://eloquentarduino.github.io/2020/04/passive-aggressive-classifier-for-embedded-devices/",
            "title": "Passive-aggressive classifier for embedded devices",
            "content_html": "<p>When working with memory constrained devices you may not able to keep all the training data in memory: passive-aggressive classifiers may help solve your memory problems.</p>\n<p><span id=\"more-1050\"></span></p>\n<h2>Batch learning</h2>\n<p>A couple weeks ago I started exploring the possibility to train a machine learning classifier directly on a microcontroller. Since I like SVM, <a href=\"/2020/03/so-you-want-to-train-an-ml-classifier-directly-on-an-arduino-board\">I ported the simplified SVM SMO (Sequential Minimal Optimization) algorithm</a> to plain C, ready to be deployed to embedded devices.</p>\n<p>Now, that kind of algorithm works in the so-called &quot;batch-mode&quot;: it needs all the training data to be available in memory to learn.</p>\n<p>This may be a limiting factor on resource-constrained devices, since it poses an upper bound to the number of samples you can train on. And when working with high-dimensional datasets, the number of samples could be not enough to achieve good accuracy.</p>\n<h2>Enter incremental learning</h2>\n<p>To solve this limitation, you need a totally different kind of learning algorithms: you need incremental (a.k.a online a.k.a out of core) learning.</p>\n<p>Incremental learning works by inspecting one training sample at a time, instead of all at once.</p>\n<p>The clear advantage is that you have a tiny memory footprint. And this is a <strong>huge</strong> advantage.</p>\n<p>The clear disadvantage is that you don't have the &quot;big picture&quot; of your data, so:</p>\n<ul>\n<li>the end result will probably be affected by the order of presentation of the samples</li>\n<li>you may not be able to achieve top accuracy</li>\n</ul>\n<h2>Passive-aggressive classifier</h2>\n<p>Passive-aggressive classification is one of the available incremental learning algorithms and it is very simple to implement, since it has a closed-form update rule.</p>\n<p>Please refer to this <a href=\"https://www.bonaccorso.eu/2017/10/06/ml-algorithms-addendum-passive-aggressive-algorithms/\">short explanation on Passive-aggressive classifiers</a> for a nice description with images.</p>\n<p>The core concept is that the classifier adjusts it weight vector for each mis-classified training sample it receives, trying to get it correct.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/04/passive-aggressive-classifier.png\" alt=\"Passive aggressive classifier\" /></p>\n<h2>Benchmarks</h2>\n<p>I run a couple benchmark on my Esp32 to assess both accuracy and training time.</p>\n<p>First of all: <strong>it is fast!</strong>. When I say it is fast I mean it takes ~1ms to train on 400 samples x 30 features each.</p>\n<p>Talking about accuracy instead... Uhm...</p>\n<p>Accuracy vary. <strong>Greatly</strong>. </p>\n<p>You can achieve 100% on some datasets. </p>\n<p>And 40% on others. But on those same datasets you can achieve &gt;85% if training on a different number of samples. Or in a different order.</p>\n<p>I guess this is the tradeoff for such a simple and space-efficient algorithm.</p>\n<p>I report my results in the following table. It is not meant to be an exhaustive benchmark of the classifier, since those number will vary based on the order of presentation, but still you can get an idea of what it is able to achieve.</p>\n<table>\n<thead>\n<tr>\n<th>Dataset size</th>\n<th style=\"text-align: center;\">Train samples</th>\n<th style=\"text-align: right;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BREAST CANCER</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>567 samples</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">62</td>\n</tr>\n<tr>\n<td>30 features</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">37</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">63</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: right;\">39</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">150</td>\n<td style=\"text-align: right;\">38</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">200</td>\n<td style=\"text-align: right;\">64</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">250</td>\n<td style=\"text-align: right;\">61</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">300</td>\n<td style=\"text-align: right;\">69</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">350</td>\n<td style=\"text-align: right;\">73</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">400</td>\n<td style=\"text-align: right;\">85</td>\n</tr>\n<tr>\n<td>IRIS</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>100 samples</td>\n<td style=\"text-align: center;\">10</td>\n<td style=\"text-align: right;\">50</td>\n</tr>\n<tr>\n<td>4 features</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">51</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">80</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td>DIGITS</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>358 samples</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">98</td>\n</tr>\n<tr>\n<td>64 features</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">98</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">99</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">150</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">200</td>\n<td style=\"text-align: right;\">99</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">250</td>\n<td style=\"text-align: right;\">98</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">300</td>\n<td style=\"text-align: right;\">95</td>\n</tr>\n<tr>\n<td>CLEVELAND HEART DISEASE</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>212 samples</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">76</td>\n</tr>\n<tr>\n<td>13 features</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">24</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">77</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: right;\">19</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">120</td>\n<td style=\"text-align: right;\">82</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">140</td>\n<td style=\"text-align: right;\">78</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">180</td>\n<td style=\"text-align: right;\">88</td>\n</tr>\n</tbody>\n</table>\n<h2>Time to code</h2>\n<p>Here I'll report an extract of the example code you can find on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PassiveAggressiveExample/PassiveAggressiveExample.ino\">Github</a> for this classifier.</p>\n<pre><code class=\"language-c\">#include &quot;EloquentPassiveAggressiveClassifier.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n#include &quot;iris.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid loop() {\n    int trainSamples;\n    PassiveAggressiveClassifier&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    trainSamples = readSerialNumber(&quot;How many samples will you use as training?&quot;, DATASET_SIZE - 2);\n\n    if (trainSamples == 0)\n        return;\n\n    clf.setC(1);\n\n    // train\n    for (uint16_t i = 0; i &lt; trainSamples; i++)\n        clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i] &gt; 0 ? 1 : -1;\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}</code></pre>\n<hr />\n<p>On the <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PassiveAggressiveExample/PassiveAggressiveExample.ino\">project page</a> you will find the code to reproduce these numbers.</p>\n<hr />\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/04/passive-aggressive-classifier-for-embedded-devices/\">Passive-aggressive classifier for embedded devices</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "When working with memory constrained devices you may not able to keep all the training data in memory: passive-aggressive classifiers may help solve your memory problems.\n\nBatch learning\nA couple weeks ago I started exploring the possibility to train a machine learning classifier directly on a microcontroller. Since I like SVM, I ported the simplified SVM SMO (Sequential Minimal Optimization) algorithm to plain C, ready to be deployed to embedded devices.\nNow, that kind of algorithm works in the so-called &quot;batch-mode&quot;: it needs all the training data to be available in memory to learn.\nThis may be a limiting factor on resource-constrained devices, since it poses an upper bound to the number of samples you can train on. And when working with high-dimensional datasets, the number of samples could be not enough to achieve good accuracy.\nEnter incremental learning\nTo solve this limitation, you need a totally different kind of learning algorithms: you need incremental (a.k.a online a.k.a out of core) learning.\nIncremental learning works by inspecting one training sample at a time, instead of all at once.\nThe clear advantage is that you have a tiny memory footprint. And this is a huge advantage.\nThe clear disadvantage is that you don't have the &quot;big picture&quot; of your data, so:\n\nthe end result will probably be affected by the order of presentation of the samples\nyou may not be able to achieve top accuracy\n\nPassive-aggressive classifier\nPassive-aggressive classification is one of the available incremental learning algorithms and it is very simple to implement, since it has a closed-form update rule.\nPlease refer to this short explanation on Passive-aggressive classifiers for a nice description with images.\nThe core concept is that the classifier adjusts it weight vector for each mis-classified training sample it receives, trying to get it correct.\n\nBenchmarks\nI run a couple benchmark on my Esp32 to assess both accuracy and training time.\nFirst of all: it is fast!. When I say it is fast I mean it takes ~1ms to train on 400 samples x 30 features each.\nTalking about accuracy instead... Uhm...\nAccuracy vary. Greatly. \nYou can achieve 100% on some datasets. \nAnd 40% on others. But on those same datasets you can achieve &gt;85% if training on a different number of samples. Or in a different order.\nI guess this is the tradeoff for such a simple and space-efficient algorithm.\nI report my results in the following table. It is not meant to be an exhaustive benchmark of the classifier, since those number will vary based on the order of presentation, but still you can get an idea of what it is able to achieve.\n\n\n\nDataset size\nTrain samples\nAccuracy\n\n\n\n\nBREAST CANCER\n\n\n\n\n567 samples\n20\n62\n\n\n30 features\n40\n37\n\n\n\n60\n63\n\n\n\n100\n39\n\n\n\n150\n38\n\n\n\n200\n64\n\n\n\n250\n61\n\n\n\n300\n69\n\n\n\n350\n73\n\n\n\n400\n85\n\n\nIRIS\n\n\n\n\n100 samples\n10\n50\n\n\n4 features\n20\n51\n\n\n\n40\n100\n\n\n\n60\n100\n\n\n\n80\n100\n\n\nDIGITS\n\n\n\n\n358 samples\n20\n98\n\n\n64 features\n40\n98\n\n\n\n60\n99\n\n\n\n100\n100\n\n\n\n150\n100\n\n\n\n200\n99\n\n\n\n250\n98\n\n\n\n300\n95\n\n\nCLEVELAND HEART DISEASE\n\n\n\n\n212 samples\n20\n76\n\n\n13 features\n40\n24\n\n\n\n60\n77\n\n\n\n100\n19\n\n\n\n120\n82\n\n\n\n140\n78\n\n\n\n180\n88\n\n\n\nTime to code\nHere I'll report an extract of the example code you can find on Github for this classifier.\n#include &quot;EloquentPassiveAggressiveClassifier.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n#include &quot;iris.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid loop() {\n    int trainSamples;\n    PassiveAggressiveClassifier&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    trainSamples = readSerialNumber(&quot;How many samples will you use as training?&quot;, DATASET_SIZE - 2);\n\n    if (trainSamples == 0)\n        return;\n\n    clf.setC(1);\n\n    // train\n    for (uint16_t i = 0; i &lt; trainSamples; i++)\n        clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i] &gt; 0 ? 1 : -1;\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}\n\nOn the project page you will find the code to reproduce these numbers.\n\nL'articolo Passive-aggressive classifier for embedded devices proviene da Eloquent Arduino Blog.",
            "date_published": "2020-04-05T19:04:10+02:00",
            "date_modified": "2020-05-01T10:34:15+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "microml",
                "online-learning",
                "Arduino Machine learning"
            ]
        }
    ]
}