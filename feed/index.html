<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Eloquent Arduino Blog</title>
	<atom:link href="https://eloquentarduino.github.io/feed/" rel="self" type="application/rss+xml" />
	<link>http://eloquentarduino.github.io/</link>
	<description>A blog about Arduino, programming &#38; electronics</description>
	<lastBuildDate>Mon, 16 Dec 2019 22:03:25 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.1</generator>
	<item>
		<title>Indoor positioning using Arduino and SVM Machine Learning</title>
		<link>https://eloquentarduino.github.io/2019/12/indoor-positioning-using-arduino-and-svm-machine-learning/</link>
				<pubDate>Sun, 08 Dec 2019 17:31:16 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Arduino Machine learning]]></category>
		<category><![CDATA[microml]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=224</guid>
				<description><![CDATA[<p>In this post we'll locate ourself in space using nearby WiFi access points and machine learning. The task of detecting where you are when GPS or satellite localization is not an option is called indoor positioning: it could be in a building, an airport, a parking garage. I opted for WiFi because it is widely [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/indoor-positioning-using-arduino-and-svm-machine-learning/">Indoor positioning using Arduino and SVM Machine Learning</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p>In this post we'll locate ourself in space using nearby WiFi access points and machine learning. The task of detecting where you are when GPS or satellite localization is not an option is called <a href="https://en.wikipedia.org/wiki/Indoor_positioning_system">indoor positioning</a>: it could be in a building, an airport, a parking garage. I opted for WiFi because it is widely available, but the same project could be re-purposed to use Bluetooth, if there are enough devices in your location.<br />
The inference will occur on a microcontroller thanks to the <a href="/2019/11/introducing-microml/" target="_blank">MicroML framework.</a> For this project to work you will need a Wifi equipped board, such as ESP8266 or ESP32.  </p>
<p><span id="more-224"></span></p>
<p>This tutorial is part of a <a href="/category/programming/arduino-machine-learning/" target="_blank">series of tutorials</a> about Machine learning on Arduino and all follow the same outline:</p>
<ol>
  <li>define the features</li>
  <li>record sample data: run a few scans for each location to be predicted and record the RSSI (signal strength) of each visible network</li>
 <li>train an SVM classifier with Python's scikit-learn and export it to optimized C code using <code><a href="https://github.com/agrimagsrl/micromlgen" target="_blank">micromlgen</a></code></li>
 <li>copy and paste the generated code in a <code>model.h</code> file in the Arduino project and call <code>predict()</code> from it</li>
</ol>
<h3>1. Record sample data</h3>
<p><b>What features are we going to use to run the prediction?</b> We'll use the RSSI of all the known networks, both currently visible and not. If a network is out of range, it will have an RSSI equal to 0.<br />
So, first of all we need to enumerate all the visble networks we will encounter during the inference process. This is because not all networks will be visible all the time but we have to work with a fixed number of features.<br />
We take a &quot;reconnaissance tour&quot; of the locations we want to predict and log all the networks we detect. The sketch below will print the detected networks: take note of them since we'll need them later.</p>
<pre><code class="language-cpp">#include &lt;WiFi.h&gt;

void setup() {
    Serial.begin(115200);
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
}

void loop() {
  int numNetworks = WiFi.scanNetworks();

  for (int i = 0; i &lt; numNetworks; i++) {
      Serial.println(WiFi.SSID(i));

  delay(3000);
}</code></pre>
<p>Now that we have a bunch of SSIDs, we need to assign to each SSID a fixed index, from 0 to MAX_NETWORKS. You can implement this part as you like, but in this demo I'll make use of a class I wrote called <code>Array</code> (you can see the <a href="https://github.com/agrimagsrl/EloquentArduino/blob/master/src/data_structures/Array.h">source code</a> and <a href="https://github.com/agrimagsrl/EloquentArduino/blob/master/examples/ArrayExample/ArrayExample.ino">example</a> on Github), which implements 2 useful functions: <code>push()</code> to add an element to the array and <code>indexOf()</code> to get the index of an element.</p>
<p>The first step is to populate the array with all the networks we saved from the reconnaissance tour.</p>
<pre><code class="language-cpp">#include &lt;eDataStructures.h&gt;

#define MAX_NETWORKS 10

using namespace Eloquent::DataStructures;

double features[MAX_NETWORKS];
Array&lt;String, MAX_NETWORKS&gt; knownNetworks(&quot;&quot;);

void setup() {
    Serial.begin(115200);
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();

    knownNetworks.push(&quot;Put your SSID #0&quot;);
    knownNetworks.push(&quot;Put your SSID #1&quot;);
    knownNetworks.push(&quot;Put your SSID #2&quot;);
    knownNetworks.push(&quot;Put your SSID #3&quot;);
    // and so on
}</code></pre>
<p>The second step is to convert the scan results into a features vector. Each feature will be the RSSI of the given SSID, in the exact order we populated the <code>knownNetworks</code> array. In practice:</p>
<pre><code class="language-cpp">features[0] == RSSI of &quot;Put your SSID #0&quot;;
features[1] == RSSI of &quot;Put your SSID #1&quot;;
features[2] == RSSI of &quot;Put your SSID #2&quot;;
features[3] == RSSI of &quot;Put your SSID #3&quot;;
// and so on</code></pre>
<p>The code below will do the job.</p>
<pre><code class="language-cpp">void loop() {
    scan();
    printFeatures();
    delay(3000);
}

void scan() {
    int numNetworks = WiFi.scanNetworks();

    resetFeatures();

    // assign RSSIs to feature vector
    for (int i = 0; i &lt; numNetworks; i++) {
        String ssid = WiFi.SSID(i);
        uint16_t networkIndex = knownNetworks.indexOf(ssid);

        // only create feature if the current SSID is a known one
        if (!isnan(networkIndex))
            features[networkIndex] = WiFi.RSSI(i);
    }
}</code></pre>
<pre><code class="language-cpp">
void resetFeatures() {
    const uint16_t numFeatures = sizeof(features) / sizeof(double);
    
    for (int i = 0; i < numFeatues; i++)
        features[i] = 0;
}

void printFeatures() {
    const uint16_t numFeatures = sizeof(features) / sizeof(double);
    
    for (int i = 0; i < numFeatures; i++) {
        Serial.print(features[i]);
        Serial.print(i == numFeatures - 1 ? '\n' : ',');
    }
}
</code></pre>
<p>Grab some recordings just staying in a location for a few seconds and save the serial output to a file; then move to the next location and repeat: 10-15 samples for each location will suffice.</p>
<p>If you do a good job, you should end with distinguible features, as show in the plot below.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-from-Wifi-indoor-positioning-features.svg" alt="Decision boundaries of 2 PCA components from Wifi indoor positioning features" /></p>
<div class="watchout">
RSSIs may be a little noisy, mostly on the boundaries where weak networks may appear and disappear with a very low RSSI: this was not a problem for me, but if you're getting bad results you may filter out those low values.</p>
<pre><code class="language-cpp">
// replace
features[networkIndex] = WiFi.RSSI(i);

// with
#define MIN_RSSI -90 // adjust to your needs

features[networkIndex] = WiFi.RSSI(i) > MIN_RSSI ? WiFi.RSSI(i) : 0;
</code></pre>
</div>
<h3>3. Train and export the SVM classifier</h3>

<p>For a detailed guide refer to the <a href="/2019/11/how-to-train-a-classifier-in-scikit-learn" target="_blank">tutorial</a></p>

<p>
<pre><code class="language-python">from sklearn.svm import SVC
from micromlgen import port

# put your samples in the dataset folder
# one class per file
# one feature vector per line, in CSV format
features, classmap = load_features('dataset/')
X, y = features[:, :-1], features[:, -1]
classifier = SVC(kernel='linear').fit(X, y)
c_code = port(classifier, classmap=classmap)
print(c_code)</code></pre>

<p>At this point you have to copy the printed code and import it in your Arduino project, in a file called <code>model.h</code>.</p>
<h3>3. Run the inference</h3>
<pre><code class="language-cpp">#include &quot;model.h&quot;

void loop() {
    scan();
    classify();
    delay(3000);
}

void classify() {
    Serial.print(&quot;You are in &quot;);
    Serial.println(classIdxToName(predict(features)));
}</code></pre>
<p>Move around your house/office/whatever and see your location printed on the serial monitor!</p>
<hr />
<p>View the project <a href="https://github.com/agrimagsrl/EloquentArduino/blob/master/examples/MicromlWifiIndoorPositioningExample/MicromlWifiIndoorPositioningExample.ino">on Github</a></p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/indoor-positioning-using-arduino-and-svm-machine-learning/">Indoor positioning using Arduino and SVM Machine Learning</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
		<item>
		<title>Pin</title>
		<link>https://eloquentarduino.github.io/2019/12/pin/</link>
				<pubDate>Fri, 06 Dec 2019 16:15:13 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Eloquent library]]></category>
		<category><![CDATA[eloquent]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=167</guid>
				<description><![CDATA[<p>Pin is a class for pin manipulation: you can read, write, turnOn, turnOff, toggle and a lot more. Please, stop writing horrible code like digitalWrite(led, HIGH) and start writing led.turnOn() instead. Pin is actually an abstract class, so you won't use it directly, but through its specialized implementations: DigitalIn DigitalOut AnalogIn AnalogOut If you don't [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/pin/">Pin</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p><code>Pin</code> is a class for pin manipulation: you can <code>read</code>, <code>write</code>, <code>turnOn</code>, <code>turnOff</code>, <code>toggle</code> and a lot more. Please, stop writing horrible code like <code>digitalWrite(led, HIGH)</code> and start writing <code>led.turnOn()</code> instead. </p>
<p><span id="more-167"></span></p>
<p><code>Pin</code> is actually an abstract class, so you won't use it directly, but through its specialized implementations:</p>
<ol>
<li>DigitalIn</li>
<li>DigitalOut</li>
<li>AnalogIn</li>
<li>AnalogOut</li>
</ol>
<p>If you don't believe a whole class is worthwhile to work with pins, I'll show a few use cases to illustrate my point.</p>
<h3>Use case #1: active low LED</h3>
<p>The ESP8266 has a builtin LED you can control, but it is an <em>active low</em> one: it will turn on when you write <code>LOW</code>. In this case, <code>digitalWrite(BUILTIN_LED, LOW)</code> can be misleading regarding your actual intentions. It doesn't look intuitive,  it doesn't look <em>eloquent</em>!. <code>builtinLed.turnOn()</code> does, however. All you need to get it working correctly is calling <code>builtinLed.activeLow()</code> once in your setup.</p>
<h3>Use case #2: toggle</h3>
<p>If you need to toggle the current state of a digital output, you need an helper variable to keep track of the state and remember to <strong>always</strong> update that variable when you write to the output. With a class, the state is tightly bound to the instance, so you have a <a href="https://en.wikipedia.org/wiki/Single_source_of_truth">single source of truth</a>: <code>turnOn()</code>, <code>turnOff()</code> and <code>toggle()</code> will take care of updating the inner state accordingly.</p>
<pre><code class="language-cpp">// BEFORE
#define LED 1

bool ledState = true;

loop() {
    digitalWrite(LED, ledState);
    ledState = !ledState
}</code></pre>
<pre><code class="language-cpp">// AFTER
DigitalOut led(1);

void loop() {
    led.toggle();
}</code></pre>
<h3>Use case #3: analog delta</h3>
<p>What if you have an analog input and want to know if its valued changed by at least X from your latest reading? You would need an helper variable again. Now imagine if you have 5 analog inputs you want to track: you'll end up with 10 variables and of course you have again to <strong>always</strong> keep both in sync. <code>AnalogIn</code>, conveniently, provides a <code>delta()</code> method that gives you the change from the previous reading and will always be in sync. Awesome!</p>
<pre><code class="language-cpp">// BEFORE
#define INPUT1 A1
#define INPUT2 A2

uint16_t current1, prev1;
uint16_t current2, prev2;

void loop() {
    prev1 = current1;
    current1 = analogRead(INPUT1);
    prev2 = current2;
    current2 = analogRead(INPUT2);

    if (abs(current1 - prev1) &gt; THRESHOLD)
        ...</code></pre>
<pre><code class="language-cpp">// AFTER
AnalogIn input1(A1), input2(A2);

void loop() {
    input1.read();
    input2.read();

    if (input1.absDelta() &gt; THRESHOLD)
        ...
}</code></pre>
<p>@todo continue</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/pin/">Pin</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
		<item>
		<title>Eloquent bounded waiting: the await construct</title>
		<link>https://eloquentarduino.github.io/2019/12/arduino-bounded-waiting/</link>
				<pubDate>Thu, 05 Dec 2019 18:50:59 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Eloquent library]]></category>
		<category><![CDATA[eloquent]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=211</guid>
				<description><![CDATA[<p>Sometimes you may need to wait for a certain condition to become true, but you don't want to wait forever: it may be awaiting for Serial, for the Wifi to connect to a network, or the response from a SoftwareSerial peripheral. The await construct lets you put an upper bound to the time you're willing [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/arduino-bounded-waiting/">Eloquent bounded waiting: the await construct</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p>Sometimes you may need to wait for a certain condition to become true, but you don't want to wait forever: it may be awaiting for Serial, for the Wifi to connect to a network, or the response from a SoftwareSerial peripheral. The <code>await</code> construct lets you put an upper bound to the time you're willing to wait.</p>
<p><span id="more-211"></span></p>
<p>Most often, you see example code of this kind:</p>
<pre><code class="language-cpp">Serial.print(&quot;Attempting to connect to WiFi&quot;);

while (WiFi.status() != WL_CONNECTED) {
    Serial.print(&quot;.&quot;);
    delay(500);
}</code></pre>
<p>If the connection doesn't succeed (maybe the AP is out of range or is down), you're stuck in an endless wait. A proper way for handling such situations is with a timeout that gets you out of the loop with an error status so you can handle the failure.<br />
<code>await</code> is exactly this: a construct to await for a condition to become true until a timeout expires, returning true or false as a response.</p>
<h3>Definition</h3>
<pre><code class="language-cpp">#define await(condition, timeout) await_with_interval(condition, timeout, 10)
#define await_with_interval(condition, timeout, interval) \
  ([]() { \
    uint32_t start = millis(); \
    while (millis() - start &lt;= timeout) { \
      if (condition) return true; \
      delay(interval); \
    } \
  return false; })()</code></pre>
<h3>How to use</h3>
<p><code>await</code> needs at least two arguments:</p>
<ol>
<li>the condition to await for</li>
<li>the timeout, in milliseconds</li>
</ol>
<pre><code>// these are for greater code readability
#define Millis 
#define Second  *1000
#define Seconds *1000
</code></pre>
<pre><code class="language-cpp">bool wifiConnected = await(WiFi.status() == WL_CONNECTED, 10 Seconds)</code></pre>
<p>The code above will wait 10 seconds for the wifi to connect: on failure, <code>wifiConnected</code> will be false and you can gently fail. </p>
<p>You can use it for any kind of check, like waiting for <code>Serial</code>.</p>
<pre><code class="language-cpp">bool serialReady = await(Serial, 5 Seconds)
bool serialHasCharacters = await(Serial.available(), 5 Seconds)</code></pre>
<p>The default interval between checks is 10 milliseconds: if you need a custom delay interval you can use the more verbose <code>await_with_interval</code>:</p>
<pre><code class="language-cpp">// await WiFi for 10 seconds, check if connected every 500 millis
bool wifiConnected = await_with_interval(WiFi.status() == WL_CONNECTED, 10 Seconds, 500 Millis)</code></pre>
<h3>How it works</h3>
<p>The <code>await</code> macro creates an <a href="http://www.cplusplus.com/articles/2LywvCM9/">inline function</a> that loops until the timeout expires. At every loop it checks if the condition is true: if that's the case, it returns true. The inline function construct is needed to get a return value, so you can assign it to a variable or embed directly inside an <code>if</code> test. The following code sample gives you an idea of what's happening.</p>
<pre><code class="language-cpp">bool wifiConnected = await(WiFi.status() == WL_CONNECTED, 10 Seconds)

// conceptually translates to

bool inline_function() {
    uint32_t start = millis();

    while (millis() - start &lt;= 10000) {
      if (WiFi.status() == WL_CONNECTED)
        return true;

      delay(10);
    }

   return false;
}

bool wifiConnected = inline_function();</code></pre>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/arduino-bounded-waiting/">Eloquent bounded waiting: the await construct</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
		<item>
		<title>Eloquent non-blocking code: the Every construct</title>
		<link>https://eloquentarduino.github.io/2019/12/non-blocking-arduino-code/</link>
				<pubDate>Thu, 05 Dec 2019 18:42:45 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Eloquent library]]></category>
		<category><![CDATA[eloquent]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=209</guid>
				<description><![CDATA[<p>The every construct lets you run a piace of code at regular intervals in a fluent way. If you don't need to start, stop, pause your timer, this construct is a valid alternative to more complex timer libraries already available: it only takes a time interval as argument and will execute the code block periodically. [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/non-blocking-arduino-code/">Eloquent non-blocking code: the Every construct</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p>The <code>every</code> construct lets you run a piace of code at regular intervals in a fluent way. If you don't need to start, stop, pause your timer, this construct is a valid alternative to more complex timer libraries already available: it only takes a time interval as argument and will execute the code block periodically.</p>
<p><span id="more-209"></span></p>
<h3>Definition</h3>
<pre><code class="language-cpp">#define every(interval) \
    static uint32_t __every__##interval = millis(); \
    if (millis() - __every__##interval &gt;= interval &amp;&amp; (__every__##interval = millis()))</code></pre>
<h3>How to use</h3>
<pre><code>// these are for greater code readability
#define Millis 
#define Second  *1000
#define Seconds *1000
</code></pre>
<pre><code class="language-cpp">int interval = 1 Second;

void setup() {
    Serial.begin(115200);
}

void loop() {
    every(1000 Millis) {
        Serial.println(&quot;This line is printed every 1 second&quot;);
    }

    every(2000 Millis) {
        Serial.println(&quot;This line is printed every 2 seconds&quot;);
    }

    every(interval) {
        interval += 1 Second;
        Serial.print(&quot;You can have variable intervals too! &quot;);
        Serial.print(&quot;This line will be printed again in &quot;);
        Serial.print(interval / 1000);
        Serial.println(&quot; seconds&quot;);
    }
}</code></pre>
<h3>Caveats</h3>
<p><code>every</code> is just a macro definition and is not a proper timer, so it has some limitations:</p>
<ol>
<li>you can't stop, pause or resume it: once set, it will run forever</li>
<li>its argument must be the suffix of a valid identifier</li>
<li>you can't use several <code>every</code> with the exact same argument: you have to put all the code that needs to happen at the same interval in the same block</li>
</ol>
<h4>Caveat #2</h4>
<p>The macro works by generating a variable named like <code>__every__##argument</code></p>
<pre><code class="language-cpp">every(1) ==&gt; uint32_t __every__1;
every(2) ==&gt; uint32_t __every__2;
every(a_given_interval) ==&gt; uint32_t __every__a_given_interval;
every(an invalid interval) ==&gt; uint32_t __every__an invalid interval; // Syntax error
every(1 Second) ==&gt; uint32_t __every__1 *1000; // Syntax error</code></pre>
<p>So every integer literal and any variable are all valid arguments. Any expression is forbidden.</p>
<h4>Caveat #3</h4>
<p>If you use two <code>every</code> with the exact same argument, two variables with the exact same name will be created and it will rise a compile-time error.</p>
<p>If you can live with this limitations, <code>every</code> only needs the space of an <code>uint32_t</code> to work.</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/non-blocking-arduino-code/">Eloquent non-blocking code: the Every construct</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
		<item>
		<title>Gesture Identification using Arduino and MicroML</title>
		<link>https://eloquentarduino.github.io/2019/12/gesture-identification-using-arduino-and-microml/</link>
				<pubDate>Sun, 01 Dec 2019 13:25:46 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Arduino Machine learning]]></category>
		<category><![CDATA[microml]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=35</guid>
				<description><![CDATA[<p>In this post we're going to replicate the tutorial found on the Tensorflow blog where an Arduino BLE 33 Nano Sense is used to classify IMU readings into gestures. We’re going to target a lot less powerful chip in this tutorial, tough: an Arduino Nano (old generation), equipped with 32 kb of flash and 2 [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/gesture-identification-using-arduino-and-microml/">Gesture Identification using Arduino and MicroML</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p>In this post we're going to replicate the tutorial found on the <a href="https://blog.tensorflow.org/2019/11/how-to-get-started-with-machine.html">Tensorflow blog </a>where an Arduino BLE 33 Nano Sense is used to classify IMU readings into gestures. We’re going to target a lot less powerful chip in this tutorial, tough: an Arduino Nano (old generation), equipped with 32 kb of flash and 2 kb of RAM. In this project the features are going to be 30 IMU accelerometer readings, taken starting from when a movement is detected. You can decide the use all the 6 axis from the IMU (accelerometer + gyroscope), or only 3 of them (either accelerometer or gyroscope): it will depend on the gestures you want to recognize and the amount of program space you have. Of course 3 dimesionsions will lead to a smaller model, at the cost of some loss in accuracy; do some tests and pick the one that best fits your needs. </p>
<p><span id="more-35"></span></p>
<p>This tutorial is part of a <a href="/category/programming/arduino-machine-learning/" target="_blank">series of tutorials</a> about Machine learning on Arduino and all follow the same outline:</p>
<ol>
  <li>define the features</li>
  <li>record sample data: repeat each gesture a few times and save the values from the serial monitor to a file, one for each gesture</li>
 <li>train an SVM classifier with Python's scikit-learn and export it to optimized C code using <code><a href="https://github.com/agrimagsrl/micromlgen" target="_blank">micromlgen</a></code></li>
 <li>copy and paste the generated code in a <code>model.h</code> file in the Arduino project and call <code>predict()</code> from it</li>
</ol>
<h3>1. Record sample data</h3>
<p>First of all, we need to read the raw data from the IMU. This piece of code will be different based on the specific chip you use. To keep things consistent, we'll wrap the IMU logic in 2 functions: <code>imu_setup</code> and <code>imu_read</code>. I'll report a couple of example implementations for the <code>MPU6050</code> and the <code>MPU9250</code>. You should save whichever code you use in a file called <code>imu.h</code>. </p>
<pre><code class="language-cpp">#include &lt;Wire.h&gt;
// library from https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050
#include &lt;MPU6050.h&gt;
#define OUTPUT_READABLE_ACCELGYRO

MPU6050 imu;

void imu_setup() {
    Wire.begin();
    imu.initialize();
}

void imu_read(float *ax, float *ay, float *az, float *gx, float *gy, float *gz) {
    imu.getMotion6(&amp;ax, &amp;ay, &amp;az, &amp;gx, &amp;gy, &amp;gz);
}</code></pre>
<pre><code class="language-cpp">#include &lt;Wire.h&gt;
// library from https://github.com/bolderflight/MPU9250
#include &lt;MPU9250.h&gt;

MPU9250 imu(Wire, 0x68);

void imu_setup() {
    Wire.begin();
    imu.begin();
}

void imu_read(float *ax, float *ay, float *az, float *gx, float *gy, float *gz) {
    imu.readSensor();

    *ax = imu.getAccelX_mss();
    *ay = imu.getAccelY_mss();
    *az = imu.getAccelZ_mss();
    *gx = imu.getGyroX_rads();
    *gy = imu.getGyroY_rads();
    *gz = imu.getGyroZ_rads();
}</code></pre>
<p>Now we need to check if motion is happening. To keep it simple, we'll use a naive approach that will look for an high value in the acceleration: if a threshold is exceeded, a gesture is starting. To determine the threshold, look at the raw acceleration data when in idle; then make a movement and determine a good value that will discriminate between the two. </p>
<pre><code class="language-cpp">#include imu.h

#define ACCEL_THRESHOLD 3
#define NUM_SAMPLES 30
#define csv(x) Serial.print(x); Serial.print(&#039;\t&#039;);

// naive motion detection
bool motionDetected() {
  float ax, ay, az, gx, gy, gz;

  imu_read(&amp;ax, &amp;ay, &amp;az, &amp;gx, &amp;gy, &amp;gz);

  return abs(ax) + abs(ay) + abs(az) &gt; ACCEL_THRESHOLD);
}</code></pre>
<p>In the <code>loop</code> we'll check for motion: if no motion is happening, we don't take any action and keep watching. If motion is happening, we print the next 30 readings to Serial. </p>
<pre><code class="language-cpp">void setup() {
  Serial.begin(115200);

  if (!imu_setup()) {
    Serial.println(&quot;Cannot start IMU&quot;);
    while (1) delay(10000);
  };
}

void loop() {
  if (!motionDetected())
    return delay(10);

  record();
}

void record() {
  float ax, ay, az, gx, gy, gz;

  for (uint16_t i = 0; i &lt; NUM_SAMPLES; i++) {
    imu_read(&amp;ax, &amp;ay, &amp;az, &amp;gx, &amp;gy, &amp;gz);
    csv(ax);
    csv(ay);
    csv(az);
    csv(gx);
    csv(gy);
    csv(gz);
  }

  Serial.println();
  delay(2000);
}</code></pre>
<p>Record 10-15 samples for each geasture and save them to a file, one for each gesture. If you did a good job, you should end with quite distinguible features, as show in the plot below.<br />
<img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/gesture-identification-pca.svg" alt="2 components PCA for fruit colors" /></p>
<h3>2. Train and export the SVM classifier</h3>
<p>Refere to the <a href="/2019/11/how-to-train-a-classifier-in-scikit-learn/" title="Tutorial">tutorial</a></p>
<h3>3. Run the inference</h3>
<p>Now to run the inference process we need to pack the 30 readings in an array and call <code>predict</code> from the generated <code>model.h</code>file. </p>
<pre><code class="language-cpp">#include imu.h
#include model.h

// same as before...
void loop() {
  if (!motionDetected())
    return delay(10);

  classify();
}

void classify() {
  float ax, ay, az, gx, gy, gz;
  float features[6 * NUM_SAMPLES] = { 0 };

  for (uint16_t i = 0; i &lt; NUM_SAMPLES; i++) {
    imu_read(&amp;ax, &amp;ay, &amp;az, &amp;gx, &amp;gy, &amp;gz);
    features[i * 6 + 0] = ax;
    features[i * 6 + 1] = ay;
    features[i * 6 + 2] = az;
    features[i * 6 + 3] = gx;
    features[i * 6 + 4] = gy;
    features[i * 6 + 5] = gz;
}

  Serial.print(Gesture detected );
  Serial.println(classIdxToName(predict(features)));
  delay(2000);
}</code></pre>
<p>And that's it: gesture identification through machine learning on your Arduino board!</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/gesture-identification-using-arduino-and-microml/">Gesture Identification using Arduino and MicroML</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
		<item>
		<title>How to do Morse alphabet identification through machine learning on Arduino</title>
		<link>https://eloquentarduino.github.io/2019/12/how-to-do-morse-alphabet-identification-on-arduino/</link>
				<pubDate>Sun, 01 Dec 2019 12:07:38 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Arduino Machine learning]]></category>
		<category><![CDATA[microml]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=194</guid>
				<description><![CDATA[<p>In this Arduno Machine learning project we're going to identify the letters from the Morse alphabet. In practice, we'll translate dots (•) and dashes (‒) &#34;typed&#34; with a push button into meaningful characters. In this tutorial we're going to target an Arduino Nano board (old generation), equipped with 32 kb of flash and only 2 [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/how-to-do-morse-alphabet-identification-on-arduino/">How to do Morse alphabet identification through machine learning on Arduino</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p>In this Arduno Machine learning project we're going to identify the letters from the <a href="https://en.wikipedia.org/wiki/Morse_code">Morse alphabet</a>.<br />
In practice, we'll translate dots (•) and dashes (‒)  &quot;typed&quot; with a push button into meaningful characters.<br />
In this tutorial we're going to target an Arduino Nano board (old generation), equipped with 32 kb of flash and only 2 kb of RAM.</p>
<p><span id="more-194"></span></p>
<p><img src="https://i.ytimg.com/vi/L6gxfX4GrbI/maxresdefault.jpg" alt="credits to https://www.youtube.com/watch?v=L6gxfX4GrbI" /></p>
<p>This tutorial is part of a <a href="/category/programming/arduino-machine-learning/" target="_blank">series of tutorials</a> about Machine learning on Arduino and all follow the same outline:</p>
<ol>
  <li>define the features</li>
  <li>record sample data: repeat each letter a few times and save the values from the serial monitor to a file, one for each letter.</li>
 <li>train an SVM classifier with Python's scikit-learn and export it to optimized C code using <code><a href="https://github.com/agrimagsrl/micromlgen" target="_blank">micromlgen</a></code></li>
 <li>copy and paste the generated code in a <code>model.h</code> file in the Arduino project and call <code>predict()</code> from it</li>
</ol>
<h3>1. Features definition</h3>
<p>For our task we'll use a simple push button as input and a fixed number of samples taken at a fixed interval (100 ms), starting from the first detection of the button press. I chose to record 30 samples for each letter, but you can easily customize the value as per your needs. </p>
<p>With 30 samples at 100 ms frequency, we'll have 3 seconds to &quot;type&quot; the letter and on the Serial monitor will appear a sequence of 0s and 1s, representing if the button was pressed or not; the inference procedure will translate this sequence into a letter.<br />
As a reference, here are a couple example of what we'll be working with.</p>
<pre><code class="language-cpp">// A (•‒)
0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1

// D (‒••)
0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1

// E (•)
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1</code></pre>
<h3>2. Record sample data</h3>
<p>To the bare minimum, we'll need a push button and two wires: one to ground and the other to a digital pin. Since in the example we'll make the button an <code>INPUT_PULLUP</code>, we'll read 0 when the button is pressed and 1 when not.  </p>
<p><img src="https://www.arduino.cc/en/uploads/Tutorial/PullUp_bbd.png" alt="credits to https://www.arduino.cc/en/Tutorial/DigitalInputPullup" /></p>
<p>All we need to do is detect a press and record the following 30 samples of the digital pin:</p>
<pre><code class="language-cpp">#define IN 4
#define NUM_SAMPLES 30
#define INTERVAL 100

double features[NUM_SAMPLES];

void setup() {
  Serial.begin(115200);
  pinMode(IN, INPUT_PULLUP);
}

void loop() {
  if (digitalRead(IN) == 0) {
    recordButtonStatus();
    printFeatures();
    delay(1000);
  }

  delay(10);
}

void recordButtonStatus() {
  for (int i = 0; i &lt; NUM_SAMPLES; i++) {
    features[i] = digitalRead(IN);
    delay(INTERVAL);
  } 
}</code></pre>
<pre><code class="language-cpp">
void printFeatures() {
    const uint16_t numFeatures = sizeof(features) / sizeof(double);
    
    for (int i = 0; i < numFeatures; i++) {
        Serial.print(features[i]);
        Serial.print(i == numFeatures - 1 ? '\n' : ',');
    }
}
</code></pre>
<p>Open the Serial monitor and type a few times each letter: try to introduce some variations each time, for example waiting some more milliseconds before releasing the dash.</p>
<div class="watchout"> If you've never typed morse code before (as me), choose letters with few keystrokes and quite differentiable, otherwise you will need to be very good with the timing.</div>
<p>Save the recordings for each letter in a file named after the letter, so you will get meaningful results later on.</p>
<p>You may end with duplicate recordings: don't worry, that's not a problem. I'll paste my recordings for a few letters, as a reference.</p>
<pre><code>// A (•‒)
0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1
0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1
0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1

// D (‒••)
0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1
0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1
0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1
0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1
0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1
0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1
0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1
0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1
0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1

// E (•)
0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1

// S (•••)
0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1

// T (‒)
0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1</code></pre>
<p>If you do a good job, you should end with quite distinguible features, as show in the plot below.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-from-Morse-alphabet-identification-features.svg" alt="Decision boundaries of 2 PCA components from Morse alphabet identification features" /></p>
<h3>3. Train and export the SVM classifier</h3>

<p>For a detailed guide refer to the <a href="/2019/11/how-to-train-a-classifier-in-scikit-learn" target="_blank">tutorial</a></p>

<p>
<pre><code class="language-python">from sklearn.svm import SVC
from micromlgen import port

# put your samples in the dataset folder
# one class per file
# one feature vector per line, in CSV format
features, classmap = load_features('dataset/')
X, y = features[:, :-1], features[:, -1]
classifier = SVC(kernel='linear').fit(X, y)
c_code = port(classifier, classmap=classmap)
print(c_code)</code></pre>

<p>At this point you have to copy the printed code and import it in your Arduino project, in a file called <code>model.h</code>.</p>
<h3>3. Run the inference</h3>
<pre><code class="language-cpp">#include &quot;model.h&quot;

void loop() {
  if (digitalRead(IN) == 0) {
    recordButtonStatus();
    Serial.print(&quot;Detected letter: &quot;);
    Serial.println(classIdxToName(predict(features)));
    delay(1000);
  }

  delay(10);
}</code></pre>
<p>Type some letter using the push button and see the identified value printed on the serial monitor.</p>
<p>That’s it: you deployed machine learning in 2 Kb! </p>
<p><h4>Project figures</h4>
<p>On my machine, the sketch targeted at the Arduino Nano (old generation) requires 12546 bytes (40%) of program space and 366 bytes (17%) of RAM. This means you could actually run machine learning in even less space than what the Arduino Nano provides. So, the answer to the question <em>Can I run machine learning on Arduino?</em> is <strong>definetly YES</strong>.<br />
<br><p>Did you find this tutorial useful? Was is it easy to follow or did I miss something? Let me know in the comments so I can keep improving the blog.</p></p>
<hr />
<p>View the project on <a href="https://github.com/eloquentarduino/EloquentArduino/tree/master/examples/MicromlMorseIdentificationExample/MicromlMorseIdentificationExample.ino">Github</a></p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/how-to-do-morse-alphabet-identification-on-arduino/">How to do Morse alphabet identification through machine learning on Arduino</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
		<item>
		<title>How to do color identification through machine learning on Arduino</title>
		<link>https://eloquentarduino.github.io/2019/12/how-to-do-color-identification-on-arduino/</link>
				<pubDate>Sun, 01 Dec 2019 10:35:29 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Arduino Machine learning]]></category>
		<category><![CDATA[microml]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=6</guid>
				<description><![CDATA[<p>In this Arduno Machine learning project we're going to use an RGB sensor to identify objects based on their color. This is a remake of the project found on the Tensorflow blog. We're going to use a lot less powerful chip in this tutorial, tough: an Arduino Nano (old generation), equipped with 32 kb of [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/how-to-do-color-identification-on-arduino/">How to do color identification through machine learning on Arduino</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p>In this Arduno Machine learning project we're going to use an RGB sensor to identify objects based on their color.<br />
This is a remake of the project found on the <a href="https://blog.tensorflow.org/2019/11/fruit-identification-using-arduino-and-tensorflow.html">Tensorflow blog</a>. We're going to use a lot less powerful chip in this tutorial, tough: an Arduino Nano (old generation), equipped with 32 kb of flash and only 2 kb of RAM.</p>
<p><span id="more-6"></span></p>
<p>This tutorial is part of a <a href="/category/programming/arduino-machine-learning/" target="_blank">series of tutorials</a> about Machine learning on Arduino and all follow the same outline:</p>
<ol>
  <li>define the features</li>
  <li>record sample data: put some colored objects in front of your sensor and save the readings</li>
 <li>train an SVM classifier with Python's scikit-learn and export it to optimized C code using <code><a href="https://github.com/agrimagsrl/micromlgen" target="_blank">micromlgen</a></code></li>
 <li>copy and paste the generated code in a <code>model.h</code> file in the Arduino project and call <code>predict()</code> from it</li>
</ol>
<h2>1. Features definition</h2>
<p>We're going to use the RGB components of a color sensor (TCS3200 in my case) to infer which object we're pointing it at. This means our features are going to be of 3-dimensional, which leads to a really simple model with very high accuracy.</p>
<hr /><p><em>You can do color identification on Arduino using Machine learning without Neural Networks</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-color-identification-on-arduino%2F&#038;text=You%20can%20do%20color%20identification%20on%20Arduino%20using%20Machine%20learning%20without%20Neural%20Networks&#038;via=ArduinoEloquent&#038;related=ArduinoEloquent' target='_blank' rel="noopener noreferrer" >Click To Tweet</a><br /><hr />
<h2>2. Record sample data</h2>
<p>We don't need any processing to get from the sensor readings to the feature vector, so the code will be straight-forward: read each component from the sensor and assign it to the features array. This part will vary based on the specific chip you have: I'll report the code for a TCS 230/3200. </p>
<pre><code class="language-cpp">#define S2 2
#define S3 3
#define sensorOut 4

double features[3];

void setup() {
  Serial.begin(115200);
  pinMode(S2, OUTPUT);
  pinMode(S3, OUTPUT);
  pinMode(sensorOut, INPUT);
}

void loop() {
  readRGB();
  printFeatures();
  delay(100);
}

int readComponent(bool s2, bool s3) {
  delay(10);
  digitalWrite(S2, s2);
  digitalWrite(S3, s3);

  return pulseIn(sensorOut, LOW);
}

void readRGB() {
  features[0] = readComponent(LOW, LOW);
  features[1] = readComponent(HIGH, HIGH);
  features[2] = readComponent(LOW, HIGH);
}</code></pre>
<pre><code class="language-cpp">
void printFeatures() {
    const uint16_t numFeatures = sizeof(features) / sizeof(double);
    
    for (int i = 0; i < numFeatures; i++) {
        Serial.print(features[i]);
        Serial.print(i == numFeatures - 1 ? '\n' : ',');
    }
}
</code></pre>
<p>Open the Serial monitor and put some colored objects in front of the sensor: move the object a bit and rotate it, so the samples will include different shades of the color.</p>
<p>Save the recordings for each color in a file named after the color, so you will get meaningful results later on.</p>
<div class="watchout">
Don’t forget to sample the “empty color” too: don’t put anything in front of the sensor and let it record for a while.
</div>
<p>If you do a good job, you should end with distinguible features, as show in the contour plot below.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-from-the-colors-features.svg" alt="Decision boundaries of 2 PCA components from the colors features" /></p>
<h3>3. Train and export the SVM classifier</h3>

<p>For a detailed guide refer to the <a href="/2019/11/how-to-train-a-classifier-in-scikit-learn" target="_blank">tutorial</a></p>

<p>
<pre><code class="language-python">from sklearn.svm import SVC
from micromlgen import port

# put your samples in the dataset folder
# one class per file
# one feature vector per line, in CSV format
features, classmap = load_features('dataset/')
X, y = features[:, :-1], features[:, -1]
classifier = SVC(kernel='linear').fit(X, y)
c_code = port(classifier, classmap=classmap)
print(c_code)</code></pre>

<p>At this point you have to copy the printed code and import it in your Arduino project, in a file called <code>model.h</code>.</p>
<h2>4. Run the inference</h2>
<pre><code class="language-cpp">#include model.h

void loop() {
  readRGB();
  Serial.println(classIdxToName(predict(features)));
  delay(1000);
}</code></pre>
<p>Put some colored object in front of the sensor and see the identified object name printed on the serial monitor.</p>
<div class="watchout">Do you remember the "empty color"? It needs to be recorded so you will get "empty" when no object is present, otherwise you'll get unexpected predictions</div>
<p>Given the simplicity of the task, you should easily achieve near 100% accuracy for different colors (I had some troubles distinguishing orange from yellow because of the bad illumination). Just be sure to replicate the exact same setup both during training and classification.</p>
<p>That’s it: you deployed machine learning in 2 Kb! </p>
<h2><h4>Project figures</h4>
<p>On my machine, the sketch targeted at the Arduino Nano (old generation) requires 5570 bytes (18%) of program space and 266 bytes (12%) of RAM. This means you could actually run machine learning in even less space than what the Arduino Nano provides. So, the answer to the question <em>Can I run machine learning on Arduino?</em> is <strong>definetly YES</strong>.<br />
<br><p>Did you find this tutorial useful? Was is it easy to follow or did I miss something? Let me know in the comments so I can keep improving the blog.</p></h2>
<p>View the full project on <a href="https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/MicromlColorIdentificationExample/MicromlColorIdentificationExample.ino">Github</a></p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/how-to-do-color-identification-on-arduino/">How to do color identification through machine learning on Arduino</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
		<item>
		<title>How to do Iris classification through machine learning on Arduino</title>
		<link>https://eloquentarduino.github.io/2019/12/how-to-do-iris-classification-on-arduino/</link>
				<pubDate>Sun, 01 Dec 2019 09:02:02 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Arduino Machine learning]]></category>
		<category><![CDATA[microml]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=409</guid>
				<description><![CDATA[<p>In this first tutorial from the series Arduino Machine learning we're going to implement the &#34;Hello world&#34; of Machine learning projects: classifying the Iris dataset on an Arduino board. The Iris dataset is a well known one in the Machine learning world and is often used in introductory tutorials about classification. In this tutorial we're [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/how-to-do-iris-classification-on-arduino/">How to do Iris classification through machine learning on Arduino</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p>In this first tutorial from the series <em><a href="/category/programming/arduino-machine-learning/">Arduino Machine learning</a></em> we're going to implement the &quot;Hello world&quot; of Machine learning projects: classifying the Iris dataset on an Arduino board. The <a href="https://en.wikipedia.org/wiki/Iris_flower_data_set">Iris dataset</a> is a well known one in the Machine learning world and is often used in introductory tutorials about classification.<br />
In this tutorial we're going to run the classification directly on a Arduino Nano board (old generation), equipped with 32 kb of flash and only 2 kb of RAM: that's the only thing you will need!</p>
<p><span id="more-409"></span></p>
<p>This tutorial is part of a <a href="/category/programming/arduino-machine-learning/" target="_blank">series of tutorials</a> about Machine learning on Arduino and all follow the same outline:</p>
<ol>
  <li>define the features</li>
  <li>record sample data: we'll use the publicly available dataset</li>
 <li>train an SVM classifier with Python's scikit-learn and export it to optimized C code using <code><a href="https://github.com/agrimagsrl/micromlgen" target="_blank">micromlgen</a></code></li>
 <li>copy and paste the generated code in a <code>model.h</code> file in the Arduino project and call <code>predict()</code> from it</li>
</ol>
<h3>1. Features definition</h3>
<p>There are 4 features in this dataset: sepal length, sepal width, petal length, petal width; and 3 classes: Setosa, Versicolor, Virginica. You can see in the picture below how they relate to the actual flower.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/iris-278x300.png" alt="Iris features illustrated @ credits to https://gallery.azure.ai/Experiment/Classify-Iris-Dataset-using-Decision-Forest-1" /></p>
<h3>2. Sample data</h3>
<p>You may download the dataset <a href="https://gist.github.com/netj/8836201">here</a>.<br />
An excerpt of the dataset is reported in the following table.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">sepal.length</th>
<th style="text-align: center;">sepal.width</th>
<th style="text-align: center;">petal.length</th>
<th style="text-align: center;">petal.width</th>
<th style="text-align: center;">variety</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">5.1</td>
<td style="text-align: center;">3.5</td>
<td style="text-align: center;">1.4</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">Setosa</td>
</tr>
<tr>
<td style="text-align: center;">4.9</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">1.4</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">Setosa</td>
</tr>
<tr>
<td style="text-align: center;">4.6</td>
<td style="text-align: center;">3.1</td>
<td style="text-align: center;">1.5</td>
<td style="text-align: center;">0.2</td>
<td style="text-align: center;">Setosa</td>
</tr>
<tr>
<td style="text-align: center;">5.8</td>
<td style="text-align: center;">2.6</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">1.2</td>
<td style="text-align: center;">Versicolor</td>
</tr>
<tr>
<td style="text-align: center;">5.6</td>
<td style="text-align: center;">2.7</td>
<td style="text-align: center;">4.2</td>
<td style="text-align: center;">1.3</td>
<td style="text-align: center;">Versicolor</td>
</tr>
<tr>
<td style="text-align: center;">6.3</td>
<td style="text-align: center;">2.5</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">1.9</td>
<td style="text-align: center;">Virginica</td>
</tr>
<tr>
<td style="text-align: center;">6.5</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5.2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">Virginica</td>
</tr>
<tr>
<td style="text-align: center;">5.9</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5.1</td>
<td style="text-align: center;">1.8</td>
<td style="text-align: center;">Virginica</td>
</tr>
</tbody>
</table>
<p>A contour plot of this dataset is depicted in the image below.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Iris-features.svg" alt="Decision boundaries of 2 PCA components of Iris features" /></p>
<h3>3. Train and export the SVM classifier</h3>

<p>For a detailed guide refer to the <a href="/2019/11/how-to-train-a-classifier-in-scikit-learn" target="_blank">tutorial</a></p>

<p>
<pre><code class="language-python">from sklearn.svm import SVC
from micromlgen import port

# put your samples in the dataset folder
# one class per file
# one feature vector per line, in CSV format
features, classmap = load_features('dataset/')
X, y = features[:, :-1], features[:, -1]
classifier = SVC(kernel='linear').fit(X, y)
c_code = port(classifier, classmap=classmap)
print(c_code)</code></pre>

<p>At this point you have to copy the printed code and import it in your Arduino project, in a file called <code>model.h</code>.</p>
<h3>4. Run the inference</h3>
<p>We will be running the inferences from the features entered via Serial monitor: you type 4 float values representing the 4 features and get back the predicted Iris species.</p>
<pre><code class="language-cpp">#include &quot;iris.h&quot;

void setup() {
    Serial.begin(115200);
}

void loop() {
    if (Serial.available()) {
        double features[4];

        for (int i = 0; i &lt; 4; i++) {
            // split features on comma (,)
            String feature = Serial.readStringUntil(&#039;,&#039;);

            features[i] = atof(feature.c_str());
        }

        Serial.print(&quot;Detected species: &quot;);
        Serial.println(classIdxToName(predict(features)));
    }

    delay(10);
}</code></pre>
<p>If you open the Serial monitor you should see something like the next picture as you type in the features from different species.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Iris-serial.png" alt="Iris classification serial output" /></p>
<p>That’s it: you deployed machine learning in 2 Kb!</p>
<p><h4>Project figures</h4>
<p>On my machine, the sketch targeted at the Arduino Nano (old generation) requires 7446 bytes (24%) of program space and 302 bytes (14%) of RAM. This means you could actually run machine learning in even less space than what the Arduino Nano provides. So, the answer to the question <em>Can I run machine learning on Arduino?</em> is <strong>definetly YES</strong>.<br />
<br><p>Did you find this tutorial useful? Was is it easy to follow or did I miss something? Let me know in the comments so I can keep improving the blog.</p></p>
<hr />
<p>View the project on <a href="https://github.com/eloquentarduino/EloquentArduino/tree/master/examples/MicromlIrisExample/MicromlIrisExample.ino">Github</a></p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/how-to-do-iris-classification-on-arduino/">How to do Iris classification through machine learning on Arduino</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
		<item>
		<title>This is how I create my Arduino Machine learning classifiers in 4 easy steps</title>
		<link>https://eloquentarduino.github.io/2019/11/how-to-create-a-classifier-for-arduino-machine-learning-projects/</link>
				<pubDate>Mon, 11 Nov 2019 21:10:51 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Arduino Machine learning]]></category>
		<category><![CDATA[microml]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=104</guid>
				<description><![CDATA[<p>In this post I'll show you how I train my classifiers in scikit-learn and export them for Arduino machine learning projects. Since this is a repetitive task, you can save a short snippet of Python code on your PC and use it whenever you need to train a classifier from Arduino data. It really is [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/11/how-to-create-a-classifier-for-arduino-machine-learning-projects/">This is how I create my Arduino Machine learning classifiers in 4 easy steps</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p>In this post I'll show you how I train my classifiers in scikit-learn and export them for Arduino machine learning projects. Since this is a repetitive task, you can save a short snippet of Python code on your PC and use it whenever you need to train a classifier from Arduino data. It really is a general-purpose piece of code that reads the files from a folder and generates a features matrix from them; the useful bit, so to say, is that it generates a classmap to translate class indexes to readable names.</p>
<p><span id="more-104"></span></p>
<h2>Setup</h2>
<div class="watchout">The code assumes you've saved your samples in a folder, one class per file, one sample per line.</div>
<pre><code class="language-python">import numpy as np
from glob import glob
from os.path import basename

def load_features(folder):
    dataset = None
    classmap = {}
    for class_idx, filename in enumerate(glob(&#039;%s/*.csv&#039; % folder)):
        class_name = basename(filename)[:-4]
        classmap[class_idx] = class_name
        samples = np.loadtxt(filename)
        labels = np.ones((len(samples), 1)) * class_idx
        samples = np.hstack((samples, labels))
        dataset = samples if dataset is None else np.vstack((dataset, samples))
    return dataset, classmap</code></pre>
<h2>Train the classifier</h2>
<p>Include the snippet in your scikit-learn project and use it to train your SVM classifier.</p>
<pre><code class="language-python">from sklearn.svm import SVC

features, classmap = load_features(&#039;datasets/colors/&#039;)
X, y = features[:, :-1], features[:, -1]
classifier = SVC(kernel=&#039;linear&#039;).fit(X, y)</code></pre>
<h2>Generate C code</h2>
<p>Now you can convert the trained classifier to C code using the <a href="https://github.com/agrimagsrl/micromlgen"><code>micromlgen</code></a> package.</p>
<pre><code class="language-python">pip install micromlgen</code></pre>
<pre><code class="language-python">from micromlgen import port

c_code = port(classifier)
print(c_code)</code></pre>
<p>This is the code you need to import in your Arduino project. To follow along with the tutorials on this blog, save it in a file called <code>model.h</code>.</p>
<h2>Use in Arduino project</h2>
<p>There are two methods you will need to call to run the predictions in your project:</p>
<ol>
<li><code>predict(double features[])</code>: it runs the actual prediction and returns a number representing the predicted class</li>
<li><code>classIdxToName(uint8_t classIdx)</code>: converts the class index to a readable string, based on the classmap generated from your files</li>
</ol>
<pre><code class="language-cpp">#include &quot;model.h&quot;

void classify() {
    Serial.print(&quot;Predicted class: &quot;);
    Serial.println(classIdxToName(predict(features)));
}</code></pre>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/11/how-to-create-a-classifier-for-arduino-machine-learning-projects/">This is how I create my Arduino Machine learning classifiers in 4 easy steps</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
		<item>
		<title>You can run Machine learning on Arduino. And any other MCU out there too!</title>
		<link>https://eloquentarduino.github.io/2019/11/you-can-run-machine-learning-on-arduino/</link>
				<pubDate>Sun, 10 Nov 2019 19:18:40 +0000</pubDate>
		<dc:creator><![CDATA[simone]]></dc:creator>
				<category><![CDATA[Arduino Machine learning]]></category>
		<category><![CDATA[microml]]></category>

		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=76</guid>
				<description><![CDATA[<p>A lot of forum threads ask about the possibility to run Machine learning on Arduino. The answers mostly follow in one of these 3 categories: Arduino is too resource-constrained to handle Machine learning Come up with a naive implementation of a Multi Layer Perceptron (recently) Sure! You can use Tensorflow Lite for Microcontrollers No single [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/11/you-can-run-machine-learning-on-arduino/">You can run Machine learning on Arduino. And any other MCU out there too!</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
								<content:encoded><![CDATA[<p><a href="https://www.quora.com/I-want-to-make-a-robot-with-an-Arduino-that-uses-basic-machine-learning-where-can-I-start">A</a> <a href="https://robotics.stackexchange.com/questions/568/is-it-possible-to-run-a-neural-network-on-a-microcontroller">lot</a> <a href="https://www.reddit.com/r/robotics/comments/bnmm75/arduino_for_machine_learning/">of</a> <a href="https://www.quora.com/How-do-I-use-machine-learning-with-Arduino">forum</a> <a href="https://forum.arduino.cc/index.php?topic=63981.0">threads</a> ask about the possibility to run Machine learning on Arduino.<br />
The answers mostly follow in one of these 3 categories:</p>
<ol>
<li>Arduino is too resource-constrained to handle Machine learning</li>
<li>Come up with a naive implementation of a <a href="https://en.wikipedia.org/wiki/Multilayer_perceptron">Multi Layer Perceptron</a></li>
<li>(recently) Sure! You can use <a href="https://www.tensorflow.org/lite/microcontrollers">Tensorflow Lite for Microcontrollers</a></li>
</ol>
<p>No single answer I read talked about the other 100s alghoritms that fall under the Machine learning umbrella. <strong>No. Single. One.</strong> Let me explain what I think is wrong with this.</p>
<p><span id="more-76"></span></p>
<p>First of all I'd like to state one absolutely important thing:</p>
<hr /><p><em>Artificial intelligence ≠ Machine learning ≠ Neural networks. This should be clear</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F11%2Fyou-can-run-machine-learning-on-arduino%2F&#038;text=Artificial%20intelligence%20%E2%89%A0%20Machine%20learning%20%E2%89%A0%20Neural%20networks.%20This%20should%20be%20clear&#038;via=ArduinoEloquent&#038;related=ArduinoEloquent' target='_blank' rel="noopener noreferrer" >Click To Tweet</a><br /><hr />
<p>I admit most of those questions seemed to come from principiants. Also the answers, though, most often lack any sound knowledge about the topic.</p>
<hr /><p><em>You can run classification and regression on Arduino boards, even the less powerful ones: just don&#039;t use Neural networks. It&#039;s that simple.</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F11%2Fyou-can-run-machine-learning-on-arduino%2F&#038;text=You%20can%20run%20classification%20and%20regression%20on%20Arduino%20boards%2C%20even%20the%20less%20powerful%20ones%3A%20just%20don%27t%20use%20Neural%20networks.%20It%27s%20that%20simple.&#038;via=ArduinoEloquent&#038;related=ArduinoEloquent' target='_blank' rel="noopener noreferrer" >Click To Tweet</a><br /><hr />
<h2>Introducing MicroML generator</h2>
<p>So I do you <em>actually</em> run machine learning on such constrained devices?</p>
<p>Here you are: <a href="https://github.com/eloquentarduino/micromlgen">MicroML</a> is a project to bring Machine learning algorithms to microcontrollers. It was born as an alternative to Tensorflow for Microcontrollers, which is solely dedicated to Artificial Neural Networks: here you will find leaner alternatives to neural networks to run inference <strong>even on 8-bit microcontrollers</strong>.</p>
<p>Quoting from the Tensoflow blog: <em>The core runtime fits in 16 KB on an Arm Cortex M3</em> (that's just the runtime, without any actual operator!). MicroML, on the other hand, lets you deploy models that fit in <strong>under 2 Kb of RAM</strong>.</p>
<p>At the current state, it can convert <a href="https://en.wikipedia.org/wiki/Support-vector_machine">Support Vector Machines</a> to optimized C code you can deploy on any MCU of you choice: Arduino (Uno, Nano, Micro...), ESP8266, ESP32, Particle Photon, Sparkfun Edge, Adafruit Feather, you name it.</p>
<p>Why Support Vector Machines? Because they're really good at classifying highly-dimensional features and are quite easy to optimize for RAM-constrained environments.</p>
<h2>How to port a classifier</h2>
<p>First of all, you need to train a classifier. You have to use the Python's library <a href="https://scikit-learn.org/stable/">scikit-learn</a> — which you're probably already using considering its widespread adoption. Then you need to install the MicroML package.</p>
<pre><code class="language-python">pip install micromlgen</code></pre>
<p>Finally, you <code>port</code> your trained classifier to optimized C code.</p>
<pre><code class="language-python">from micromlgen import port
from sklearn.svm import SVC
from sklearn.datasets import load_iris

if __name__ == &#039;__main__&#039;:
    iris = load_iris()
    X = iris.data
    y = iris.target
    clf = SVC(kernel=&#039;linear&#039;).fit(X, y)
    print(port(clf))</code></pre>
<p>That's it: you now have all you need to do classification in your Arduino projects.</p>
<h2>Existing alternatives</h2>
<p>There exists some alternatives to this library, but they suffer from some limitations:</p>
<ol>
<li><a href="https://github.com/nok/sklearn-porter">sklearn-porter</a> can output C code (among the others), but it's not optimized for microcontrollers. You'll hit a wall on RAM because it needs to declare all the support vectors in memory (to have an idea, the <a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_breast_cancer.html">breast cancer dataset</a> produces a 57x30 matrix of doubles, totalling 6840 bytes just for the support vectors).</li>
<li>I found one once, but can't find it again </li>
</ol>
<p>My effort was to find an implementation that needed the least amount possible of memory: this was possible sacrificing the program space, but that's less often a problem since RAM is usually the most limiting factor. If your model fills up the program space you can revert to <code>sklearn-porter</code> (if you have enough RAM, of course).</p>
<h2>Use in Arduino project</h2>
<p>There are two methods you will need to call to run the predictions in your project:</p>
<ol>
<li><code>predict(double features[])</code>: it runs the actual prediction and returns a number representing the predicted class</li>
<li><code>classIdxToName(uint8_t classIdx)</code>: converts the class index to a readable string, based on the classmap generated from your files</li>
</ol>
<pre><code class="language-cpp">#include &quot;model.h&quot;

void classify() {
    Serial.print(&quot;Predicted class: &quot;);
    Serial.println(classIdxToName(predict(features)));
}</code></pre>
<hr />
<p>I'm starting a series of tutorials about hands-on projects to put Machine learning in use: you can follow the <strong>Related posts</strong> links to follow along, so keep reading!</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/11/you-can-run-machine-learning-on-arduino/">You can run Machine learning on Arduino. And any other MCU out there too!</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
										</item>
	</channel>
</rss>
