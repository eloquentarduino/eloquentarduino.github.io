{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/category/senza-categoria/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/category/senza-categoria/",
    "feed_url": "https://eloquentarduino.github.io/category/senza-categoria/feed/json/",
    "language": "en-US",
    "title": "Senza categoria &#8211; Eloquent Arduino Blog",
    "description": "Machine learning on Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/?p=1365",
            "url": "https://eloquentarduino.github.io/2020/11/tinyml-on-arduino-and-stm32-cnn-convolutional-neural-network-example/",
            "title": "TinyML on Arduino and STM32: CNN (Convolutional Neural Network) example",
            "content_html": "<p>Are you fascinated by TinyML and Tensorflow for microcontrollers? </p>\n<p>Do you want to run a CNN (Convolutional Neural Network) on your Arduino and STM32 boards? </p>\n<p>Do you want to do it without pain? </p>\n<p>EloquentTinyML is the library for you!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/11/CNN-topology.png\" alt=\"CNN topology\" /></p>\n<p><span id=\"more-1365\"></span></p>\n<p><a href=\"https://github.com/eloquentarduino/EloquentTinyML\">EloquentTinyML</a>, my library to easily run Tensorflow Lite neural networks on Arduino microcontrollers, is gaining some popularity so I think it's time for a good tutorial on the topic.</p>\n<p>If you're a seasoned follower of my blog, you may know that I don't really like Tensorflow on microcontrollers, because it is often <em>&quot;over-sized&quot;</em> for the project at hand and there are <a href=\"/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/\">leaner</a>, <a href=\"/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/\">faster</a> <a href=\"/2020/10/decision-tree-random-forest-and-xgboost-on-arduino/\">alternatives</a>.</p>\n<p>Nonetheless, Tensorflow is gaining much popularity in the embedded world so I'll try to give my contribute too.</p>\n<p>In this tutorial, I'm going to show you <strong>step by step</strong> how to train a CNN in Tensorflow and deploy it to you board: I tested the code both on the <strong>Arduino Nano 33 BLE Sense</strong> and the <strong>STM32 Nucleus L432KC</strong>.</p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tochow-to-train-a-cnn-in-tensorflow\">How to train a CNN in Tensorflow</a><ol><li><a href=\"#tocstep-1-import-the-libraries\">Step 1. Import the libraries</a><li><a href=\"#tocstep-2-generate-train-validation-and-test-data\">Step 2. Generate train, validation and test data</a><li><a href=\"#tocstep-3-create-and-train-the-model\">Step 3. Create and train the model</a><li><a href=\"#tocstep-4-testing-the-model-accuracy\">Step 4. Testing the model accuracy</a><li><a href=\"#tocstep-5-exporting-the-model\">Step 5. Exporting the model</a></li></ol><li><a href=\"#tochow-to-run-a-cnn-on-arduino-and-stm32-boards-with-eloquenttinyml\">How to run a CNN on Arduino and STM32 boards with EloquentTinyML</a><ol><li><a href=\"#toccnn-on-arduino-and-stm32-figures\">CNN on Arduino and STM32 figures</a></li></ol><li><a href=\"#tocand-you\">And you?</a></ol></div></p>\n<h2 id=\"tochow-to-train-a-cnn-in-tensorflow\">How to train a CNN in Tensorflow</h2>\n<p>I'm not an expert either in Tensorflow nor Convolutional Neural Networks, so I kept the project as simple as possible. I used an <em>image-like</em> dataset to create a setup where CNN should perform well: the dataset is the <a href=\"http://yann.lecun.com/exdb/mnist/\">MNIST handwritten digits</a> one.</p>\n<p><img src=\"https://miro.medium.com/max/800/1*LyRlX__08q40UJohhJG9Ow.png\" alt=\"MNIST dataset example\" /></p>\n<p>It is composed by <strong>8x8</strong> images of handwritten digits, from 0 to 9 and can be easily imported via the <code>scikit-learn</code> Python package.</p>\n<p>Regarding the CNN topology, I wanted to stay as lean as possible: the goal of this tutorial is to teach you how to deploy your own network, not about achieving 100% accuracy.</p>\n<p>Let's see step by step how to produce a usable model.</p>\n<h3 id=\"tocstep-1-import-the-libraries\">Step 1. Import the libraries</h3>\n<p>We will need <code>numpy</code> and <code>Tensorflow</code>, of course, plus <code>scikit-learn</code> to load the dataset and <a href=\"https://github.com/eloquentarduino/tinymlgen\">tinymlgen</a> to port the CNN to plain C.</p>\n<pre><code class=\"language-python\">import numpy as np\nfrom sklearn.datasets import load_digits\nimport tensorflow as tf\nfrom tensorflow.keras import layers\nfrom tinymlgen import port</code></pre>\n<h3 id=\"tocstep-2-generate-train-validation-and-test-data\">Step 2. Generate train, validation and test data</h3>\n<p>To train the network, we need:</p>\n<ul>\n<li><code>training data</code>: this is the data the network uses to learn its weights</li>\n<li><code>validation data</code>: this is the data the network uses to understand if it's doing well during learning</li>\n<li><code>test data</code>: this is the data we use to test the network accuracy once it's done learning</li>\n</ul>\n<pre><code class=\"language-python\">def get_data():\n    np.random.seed(1337)\n    x_values, y_values = load_digits(return_X_y=True)\n    x_values /= x_values.max()\n    # reshape to (8 x 8 x 1)\n    x_values = x_values.reshape((len(x_values), 8, 8, 1))\n\n    # split into train, validation, test\n    TRAIN_SPLIT = int(0.6 * len(x_values))\n    TEST_SPLIT = int(0.2 * len(x_values) + TRAIN_SPLIT)\n    x_train, x_test, x_validate = np.split(x_values, [TRAIN_SPLIT, TEST_SPLIT])\n    y_train, y_test, y_validate = np.split(y_values, [TRAIN_SPLIT, TEST_SPLIT])\n\n    return x_train, x_test, x_validate, y_train, y_test, y_validate</code></pre>\n<h3 id=\"tocstep-3-create-and-train-the-model\">Step 3. Create and train the model</h3>\n<p>Now we have to create our network topology.</p>\n<p>As I stated earlier, I wanted to keep this as simple as possible (also considering that we're using a toy dataset): I added a single convolution layer (without even max pooling) followed by the output layer.</p>\n<pre><code class=\"language-python\">def get_model():\n    x_train, x_test, x_validate, y_train, y_test, y_validate = get_data()\n\n    # create a CNN\n    model = tf.keras.Sequential()\n    model.add(layers.Conv2D(8, (3, 3), activation=&#039;relu&#039;, input_shape=(8, 8, 1)))\n    # model.add(layers.MaxPooling2D((2, 2)))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(len(np.unique(y_train))))\n\n    model.compile(optimizer=&#039;adam&#039;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[&#039;accuracy&#039;])\n    model.fit(x_train, y_train, epochs=50, batch_size=16,\n                        validation_data=(x_validate, y_validate))\n    return model, x_test, y_test</code></pre>\n<h3 id=\"tocstep-4-testing-the-model-accuracy\">Step 4. Testing the model accuracy</h3>\n<p>Do you think this topology is too simple to learn something useful in so few epochs?</p>\n<p>Think again: it achieved <strong>97%</strong> accuracy!</p>\n<p>Not bad.</p>\n<pre><code class=\"language-python\">def test_model(model, x_test, y_test):\n    x_test = (x_test / x_test.max()).reshape((len(x_test), 8, 8, 1))\n    y_pred = model.predict(x_test).argmax(axis=1)\n\n    print(&#039;ACCURACY&#039;, (y_pred == y_test).sum() / len(y_test))</code></pre>\n<h3 id=\"tocstep-5-exporting-the-model\">Step 5. Exporting the model</h3>\n<p>Once we have a trained model that performs well, we want to deploy it to our microcontroller. Thanks to the <code>tinymlgen</code> packages, is as easy as a one-liner.</p>\n<pre><code class=\"language-python\">if __name__ == &#039;__main__&#039;:\n    model, x_test, y_test = get_model()\n    test_model(model, x_test, y_test)\n    c_code = port(model, variable_name=&#039;digits_model&#039;, pretty_print=True)\n    print(c_code)</code></pre>\n<h2 id=\"tochow-to-run-a-cnn-on-arduino-and-stm32-boards-with-eloquenttinyml\">How to run a CNN on Arduino and STM32 boards with EloquentTinyML</h2>\n<p>Ok, now we have the content we need to create an Arduino sketch to run the CNN on our microcontroller.</p>\n<p>We will use the <code>EloquentTinyML</code> library to do this without pain.</p>\n<p>This is a library to run TinyML models on your microcontroller without messing around with complex compilation procedures and esoteric errors.</p>\n<p>You must first install the library at its latest version (0.0.5 or 0.0.4 if not available), either via the Library Manager or directly from Github.</p>\n<pre><code class=\"language-cpp\">#include &lt;EloquentTinyML.h&gt;\n\n// copy the printed code from tinymlgen into this file\n#include &quot;digits_model.h&quot;\n\n#define NUMBER_OF_INPUTS 64\n#define NUMBER_OF_OUTPUTS 10\n#define TENSOR_ARENA_SIZE 8*1024\n\nEloquent::TinyML::TfLite&lt;NUMBER_OF_INPUTS, NUMBER_OF_OUTPUTS, TENSOR_ARENA_SIZE&gt; ml;\n\nvoid setup() {\n    Serial.begin(115200);\n    ml.begin(digits_model);\n}\n\nvoid loop() {\n    // a random sample from the MNIST dataset (precisely the last one)\n    float x_test[64] = { 0., 0. , 0.625 , 0.875 , 0.5   , 0.0625, 0. , 0. ,\n                    0. , 0.125 , 1. , 0.875 , 0.375 , 0.0625, 0. , 0. ,\n                    0. , 0. , 0.9375, 0.9375, 0.5   , 0.9375, 0. , 0. ,\n                    0. , 0. , 0.3125, 1. , 1. , 0.625 , 0. , 0. ,\n                    0. , 0. , 0.75  , 0.9375, 0.9375, 0.75  , 0. , 0. ,\n                    0. , 0.25  , 1. , 0.375 , 0.25  , 1. , 0.375 , 0. ,\n                    0. , 0.5   , 1. , 0.625 , 0.5   , 1. , 0.5   , 0. ,\n                    0. , 0.0625, 0.5   , 0.75  , 0.875 , 0.75  , 0.0625, 0. };\n    // the output vector for the model predictions\n    float y_pred[10] = {0};\n    // the actual class of the sample\n    int y_test = 8;\n\n    // let&#039;s see how long it takes to classify the sample\n    uint32_t start = micros();\n\n    ml.predict(x_test, y_pred);\n\n    uint32_t timeit = micros() - start;\n\n    Serial.print(&quot;It took &quot;);\n    Serial.print(timeit);\n    Serial.println(&quot; micros to run inference&quot;);\n\n    // let&#039;s print the raw predictions for all the classes\n    // these values are not directly interpretable as probabilities!\n    Serial.print(&quot;Test output is: &quot;);\n    Serial.println(y_test);\n    Serial.print(&quot;Predicted proba are: &quot;);\n\n    for (int i = 0; i &lt; 10; i++) {\n        Serial.print(y_pred[i]);\n        Serial.print(i == 9 ? &#039;\\n&#039; : &#039;,&#039;);\n    }\n\n    // let&#039;s print the &quot;most probable&quot; class\n    // you can either use probaToClass() if you also want to use all the probabilities\n    Serial.print(&quot;Predicted class is: &quot;);\n    Serial.println(ml.probaToClass(y_pred));\n    // or you can skip the predict() method and call directly predictClass()\n    Serial.print(&quot;Sanity check: &quot;);\n    Serial.println(ml.predictClass(x_test));\n\n    delay(1000);\n}</code></pre>\n<p>That's it: if everything went fine, you should see that the predicted class is <code>8</code>.</p>\n<h3 id=\"toccnn-on-arduino-and-stm32-figures\">CNN on Arduino and STM32 figures</h3>\n<p>I'll report the figures I get for compiling and running this project on the two boards I used.</p>\n<table>\n<thead>\n<tr>\n<th>Board</th>\n<th style=\"text-align: right;\">Flash</th>\n<th style=\"text-align: right;\">RAM</th>\n<th style=\"text-align: right;\">Inference time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Nucleus  L432KC</td>\n<td style=\"text-align: right;\">154560</td>\n<td style=\"text-align: right;\">not available*</td>\n<td style=\"text-align: right;\">7187</td>\n</tr>\n<tr>\n<td>Arduino Nano 33 BLE Sense</td>\n<td style=\"text-align: right;\">197656</td>\n<td style=\"text-align: right;\">56160</td>\n<td style=\"text-align: right;\">9400</td>\n</tr>\n</tbody>\n</table>\n<p><em>I used the Grumpyoldpizza compiler for the Nucleus, which doesn't report back the RAM usage</em></p>\n<h2 id=\"tocand-you\">And you?</h2>\n<p>Were you able to deploy a CNN to your microcontroller thanks to this tutorial? Or are you having troubles?</p>\n<p>Let me know in the comment and I will help you or share your experience with us.</p>\n<hr />\n<p>You can find the whole code on <a href=\"https://github.com/eloquentarduino/EloquentTinyML/tree/master/examples/DigitsExample\">Github</a>.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/11/tinyml-on-arduino-and-stm32-cnn-convolutional-neural-network-example/\">TinyML on Arduino and STM32: CNN (Convolutional Neural Network) example</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Are you fascinated by TinyML and Tensorflow for microcontrollers? \nDo you want to run a CNN (Convolutional Neural Network) on your Arduino and STM32 boards? \nDo you want to do it without pain? \nEloquentTinyML is the library for you!\n\n\nEloquentTinyML, my library to easily run Tensorflow Lite neural networks on Arduino microcontrollers, is gaining some popularity so I think it's time for a good tutorial on the topic.\nIf you're a seasoned follower of my blog, you may know that I don't really like Tensorflow on microcontrollers, because it is often &quot;over-sized&quot; for the project at hand and there are leaner, faster alternatives.\nNonetheless, Tensorflow is gaining much popularity in the embedded world so I'll try to give my contribute too.\nIn this tutorial, I'm going to show you step by step how to train a CNN in Tensorflow and deploy it to you board: I tested the code both on the Arduino Nano 33 BLE Sense and the STM32 Nucleus L432KC.\nTable of contentsHow to train a CNN in TensorflowStep 1. Import the librariesStep 2. Generate train, validation and test dataStep 3. Create and train the modelStep 4. Testing the model accuracyStep 5. Exporting the modelHow to run a CNN on Arduino and STM32 boards with EloquentTinyMLCNN on Arduino and STM32 figuresAnd you?\nHow to train a CNN in Tensorflow\nI'm not an expert either in Tensorflow nor Convolutional Neural Networks, so I kept the project as simple as possible. I used an image-like dataset to create a setup where CNN should perform well: the dataset is the MNIST handwritten digits one.\n\nIt is composed by 8x8 images of handwritten digits, from 0 to 9 and can be easily imported via the scikit-learn Python package.\nRegarding the CNN topology, I wanted to stay as lean as possible: the goal of this tutorial is to teach you how to deploy your own network, not about achieving 100% accuracy.\nLet's see step by step how to produce a usable model.\nStep 1. Import the libraries\nWe will need numpy and Tensorflow, of course, plus scikit-learn to load the dataset and tinymlgen to port the CNN to plain C.\nimport numpy as np\nfrom sklearn.datasets import load_digits\nimport tensorflow as tf\nfrom tensorflow.keras import layers\nfrom tinymlgen import port\nStep 2. Generate train, validation and test data\nTo train the network, we need:\n\ntraining data: this is the data the network uses to learn its weights\nvalidation data: this is the data the network uses to understand if it's doing well during learning\ntest data: this is the data we use to test the network accuracy once it's done learning\n\ndef get_data():\n    np.random.seed(1337)\n    x_values, y_values = load_digits(return_X_y=True)\n    x_values /= x_values.max()\n    # reshape to (8 x 8 x 1)\n    x_values = x_values.reshape((len(x_values), 8, 8, 1))\n\n    # split into train, validation, test\n    TRAIN_SPLIT = int(0.6 * len(x_values))\n    TEST_SPLIT = int(0.2 * len(x_values) + TRAIN_SPLIT)\n    x_train, x_test, x_validate = np.split(x_values, [TRAIN_SPLIT, TEST_SPLIT])\n    y_train, y_test, y_validate = np.split(y_values, [TRAIN_SPLIT, TEST_SPLIT])\n\n    return x_train, x_test, x_validate, y_train, y_test, y_validate\nStep 3. Create and train the model\nNow we have to create our network topology.\nAs I stated earlier, I wanted to keep this as simple as possible (also considering that we're using a toy dataset): I added a single convolution layer (without even max pooling) followed by the output layer.\ndef get_model():\n    x_train, x_test, x_validate, y_train, y_test, y_validate = get_data()\n\n    # create a CNN\n    model = tf.keras.Sequential()\n    model.add(layers.Conv2D(8, (3, 3), activation=&#039;relu&#039;, input_shape=(8, 8, 1)))\n    # model.add(layers.MaxPooling2D((2, 2)))\n    model.add(layers.Flatten())\n    model.add(layers.Dense(len(np.unique(y_train))))\n\n    model.compile(optimizer=&#039;adam&#039;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[&#039;accuracy&#039;])\n    model.fit(x_train, y_train, epochs=50, batch_size=16,\n                        validation_data=(x_validate, y_validate))\n    return model, x_test, y_test\nStep 4. Testing the model accuracy\nDo you think this topology is too simple to learn something useful in so few epochs?\nThink again: it achieved 97% accuracy!\nNot bad.\ndef test_model(model, x_test, y_test):\n    x_test = (x_test / x_test.max()).reshape((len(x_test), 8, 8, 1))\n    y_pred = model.predict(x_test).argmax(axis=1)\n\n    print(&#039;ACCURACY&#039;, (y_pred == y_test).sum() / len(y_test))\nStep 5. Exporting the model\nOnce we have a trained model that performs well, we want to deploy it to our microcontroller. Thanks to the tinymlgen packages, is as easy as a one-liner.\nif __name__ == &#039;__main__&#039;:\n    model, x_test, y_test = get_model()\n    test_model(model, x_test, y_test)\n    c_code = port(model, variable_name=&#039;digits_model&#039;, pretty_print=True)\n    print(c_code)\nHow to run a CNN on Arduino and STM32 boards with EloquentTinyML\nOk, now we have the content we need to create an Arduino sketch to run the CNN on our microcontroller.\nWe will use the EloquentTinyML library to do this without pain.\nThis is a library to run TinyML models on your microcontroller without messing around with complex compilation procedures and esoteric errors.\nYou must first install the library at its latest version (0.0.5 or 0.0.4 if not available), either via the Library Manager or directly from Github.\n#include &lt;EloquentTinyML.h&gt;\n\n// copy the printed code from tinymlgen into this file\n#include &quot;digits_model.h&quot;\n\n#define NUMBER_OF_INPUTS 64\n#define NUMBER_OF_OUTPUTS 10\n#define TENSOR_ARENA_SIZE 8*1024\n\nEloquent::TinyML::TfLite&lt;NUMBER_OF_INPUTS, NUMBER_OF_OUTPUTS, TENSOR_ARENA_SIZE&gt; ml;\n\nvoid setup() {\n    Serial.begin(115200);\n    ml.begin(digits_model);\n}\n\nvoid loop() {\n    // a random sample from the MNIST dataset (precisely the last one)\n    float x_test[64] = { 0., 0. , 0.625 , 0.875 , 0.5   , 0.0625, 0. , 0. ,\n                    0. , 0.125 , 1. , 0.875 , 0.375 , 0.0625, 0. , 0. ,\n                    0. , 0. , 0.9375, 0.9375, 0.5   , 0.9375, 0. , 0. ,\n                    0. , 0. , 0.3125, 1. , 1. , 0.625 , 0. , 0. ,\n                    0. , 0. , 0.75  , 0.9375, 0.9375, 0.75  , 0. , 0. ,\n                    0. , 0.25  , 1. , 0.375 , 0.25  , 1. , 0.375 , 0. ,\n                    0. , 0.5   , 1. , 0.625 , 0.5   , 1. , 0.5   , 0. ,\n                    0. , 0.0625, 0.5   , 0.75  , 0.875 , 0.75  , 0.0625, 0. };\n    // the output vector for the model predictions\n    float y_pred[10] = {0};\n    // the actual class of the sample\n    int y_test = 8;\n\n    // let&#039;s see how long it takes to classify the sample\n    uint32_t start = micros();\n\n    ml.predict(x_test, y_pred);\n\n    uint32_t timeit = micros() - start;\n\n    Serial.print(&quot;It took &quot;);\n    Serial.print(timeit);\n    Serial.println(&quot; micros to run inference&quot;);\n\n    // let&#039;s print the raw predictions for all the classes\n    // these values are not directly interpretable as probabilities!\n    Serial.print(&quot;Test output is: &quot;);\n    Serial.println(y_test);\n    Serial.print(&quot;Predicted proba are: &quot;);\n\n    for (int i = 0; i &lt; 10; i++) {\n        Serial.print(y_pred[i]);\n        Serial.print(i == 9 ? &#039;\\n&#039; : &#039;,&#039;);\n    }\n\n    // let&#039;s print the &quot;most probable&quot; class\n    // you can either use probaToClass() if you also want to use all the probabilities\n    Serial.print(&quot;Predicted class is: &quot;);\n    Serial.println(ml.probaToClass(y_pred));\n    // or you can skip the predict() method and call directly predictClass()\n    Serial.print(&quot;Sanity check: &quot;);\n    Serial.println(ml.predictClass(x_test));\n\n    delay(1000);\n}\nThat's it: if everything went fine, you should see that the predicted class is 8.\nCNN on Arduino and STM32 figures\nI'll report the figures I get for compiling and running this project on the two boards I used.\n\n\n\nBoard\nFlash\nRAM\nInference time\n\n\n\n\nNucleus  L432KC\n154560\nnot available*\n7187\n\n\nArduino Nano 33 BLE Sense\n197656\n56160\n9400\n\n\n\nI used the Grumpyoldpizza compiler for the Nucleus, which doesn't report back the RAM usage\nAnd you?\nWere you able to deploy a CNN to your microcontroller thanks to this tutorial? Or are you having troubles?\nLet me know in the comment and I will help you or share your experience with us.\n\nYou can find the whole code on Github.\nL'articolo TinyML on Arduino and STM32: CNN (Convolutional Neural Network) example proviene da Eloquent Arduino Blog.",
            "date_published": "2020-11-10T17:37:13+01:00",
            "date_modified": "2020-11-10T19:04:39+01:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "Senza categoria"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1237",
            "url": "https://eloquentarduino.github.io/2020/08/the-ultimate-guide-to-wifi-indoor-positioning-using-arduino-and-machine-learning/",
            "title": "The Ultimate Guide to Wifi Indoor Positioning using Arduino and Machine Learning",
            "content_html": "<p>This will be the most detailed, easy to follow tutorial over the Web on how to implement Wifi indoor positioning using an Arduino microcontroller and Machine Learning. It contains all the steps, tools and code from the start to the end of the project.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2019/12/illustrations_ambient-wifi-site-survey2.jpg\" alt=\"\" /><br />\n<em>ri-elaborated from <a href=\"https://www.accuware.com/blog/ambient-signals-plus-video-images/\">https://www.accuware.com/blog/ambient-signals-plus-video-images/</a></em></p>\n<p><span id=\"more-1237\"></span></p>\n<p><a href=\"/2019/12/wifi-indoor-positioning-on-arduino/\">My original post</a> abot Wifi indoor positioning is one of my top-performing post of all time (after <a href=\"/2020/01/motion-detection-with-esp32-cam-only-arduino-version/\">motion detection using ESP32 camera</a> and <a href=\"/2019/11/you-can-run-machine-learning-on-arduino/\">the introductory post on Machine Learning for Arduino</a>). This is why I settled to revamp it and add some more details, tools and scripts to create <strong>the most complete free guide</strong> on how to implement such a system, from the beginning to the end.</p>\n<p>This post will cover all the necessary steps and provide all the code you need: for an introduction to the topic, I point you to <a href=\"/2019/12/wifi-indoor-positioning-on-arduino/\">the original post</a>.</p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tocfeatures-definition\">Features definition</a><li><a href=\"#tocdata-gathering\">Data gathering</a><li><a href=\"#tocgenerating-the-features-converter\">Generating the features converter</a><li><a href=\"#tocgenerating-the-classifier\">Generating the classifier</a><li><a href=\"#tocwrapping-it-all-together\">Wrapping it all together</a><ol><li><a href=\"#tocdisclaimer\">Disclaimer</a></ol></div></p>\n<h2 id=\"tocfeatures-definition\">Features definition</h2>\n<p>This part stays the same as the original post: we will use the RSSIs (signal strength) of the nearby Wifi hotspots to classifiy which location we're in.</p>\n<p>Each location will &quot;see&quot; a certain number of networks, each with a RSSI that will stay <em>mostly</em> the same: the unique combination of these RSSIs will become a fingerprint to distinguish the locations from one another.</p>\n<p>Since not all networks will be visible all the time, the shape of our data will be more likely a sparse matrix.<br />\nA <a href=\"https://en.wikipedia.org/wiki/Sparse_matrix\">sparse matrix</a> is a matrix where most of the elements will be zero, meaning the absence of the given feature. Only the relevant elements will be non-zero and will represent the RSSI of the nth network.</p>\n<p>The following example table should give you an idea of what our data will look like.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">Location</th>\n<th style=\"text-align: right;\">Net #1</th>\n<th style=\"text-align: right;\">Net #2</th>\n<th style=\"text-align: right;\">Net #3</th>\n<th style=\"text-align: right;\">Net #4</th>\n<th style=\"text-align: right;\">Net #5</th>\n<th style=\"text-align: right;\">Net #6</th>\n<th style=\"text-align: right;\">Net #7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">Kitchen/1</td>\n<td style=\"text-align: right;\"><strong>50</strong></td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>60</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Kitchen/2</td>\n<td style=\"text-align: right;\"><strong>55</strong></td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>55</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>5</strong></td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Kitchen/3</td>\n<td style=\"text-align: right;\"><strong>50</strong></td>\n<td style=\"text-align: right;\"><strong>35</strong></td>\n<td style=\"text-align: right;\"><strong>65</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>5</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bedroom/1</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>40</strong></td>\n<td style=\"text-align: right;\"><strong>40</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bedroom/2</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>85</strong></td>\n<td style=\"text-align: right;\"><strong>10</strong></td>\n<td style=\"text-align: right;\"><strong>20</strong></td>\n<td style=\"text-align: right;\"><strong>20</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bedroom/3</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>70</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>85</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>40</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bathroom/1</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\"><strong>80</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bathroom/2</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>10</strong></td>\n<td style=\"text-align: right;\"><strong>90</strong></td>\n<td style=\"text-align: right;\"><strong>85</strong></td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Bathroom/3</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\">0</td>\n<td style=\"text-align: right;\"><strong>30</strong></td>\n<td style=\"text-align: right;\"><strong>90</strong></td>\n<td style=\"text-align: right;\"><strong>90</strong></td>\n<td style=\"text-align: right;\"><strong>5</strong></td>\n<td style=\"text-align: right;\">0</td>\n</tr>\n</tbody>\n</table>\n<p>Even though the numbers in this table are fake, you should recognize a pattern:</p>\n<ul>\n<li>each location is characterized by a certain combination of always-visible networks</li>\n<li>some sample could be &quot;noised&quot; by weak networks (the <strong>5</strong> in the table)</li>\n</ul>\n<p>Our machine learning algorithm should be able to extract each location's fingerprint without being fooled by this inconsistent features.</p>\n<h2 id=\"tocdata-gathering\">Data gathering</h2>\n<p>Now that we know what our data should look like, we need to first get it.</p>\n<p>In the original post, this point was the one I'm unhappy with since it's not as straight-forward as I would have liked. The method I present you in this post, instead, is by far way simpler to follow.</p>\n<p>First of all, you will need a Wifi equipped board. I will use an <a href=\"https://store.arduino.cc/arduino-mkr-wifi-1010\">Arduino MKR WiFi 1010</a>, but any ESP8266 / ESP32 or the like will work.</p>\n<p>The following sketch will do the job: it scans the visible networks at a regular interval and prints their RSSIs encoded in JSON format.</p>\n<pre><code class=\"language-cpp\">// file DataGathering.h\n\n#include &quot;WiFi.h&quot;\n\n#define print(string) Serial.print(string);\n#define quote(string) print(&#039;&quot;&#039;); print(string); print(&#039;&quot;&#039;);\n\nString location = &quot;&quot;;\n\n/**\n * \n */\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n  WiFi.disconnect();\n}\n\n/**\n * \n */\nvoid loop() {  \n  // if location is set, scan networks\n  if (location != &quot;&quot;) {\n    int numNetworks = WiFi.scanNetworks();\n\n    // print location\n    print(&#039;{&#039;);\n    quote(&quot;__location&quot;);\n    print(&quot;: &quot;);\n    quote(location);\n    print(&quot;, &quot;);\n\n    // print each network SSID and RSSI\n    for (int i = 0; i &lt; numNetworks; i++) {\n      quote(WiFi.SSID(i));\n      print(&quot;: &quot;);\n      print(WiFi.RSSI(i));\n      print(i == numNetworks - 1 ? &quot;}\\n&quot; : &quot;, &quot;);\n    }\n\n    delay(1000);\n  }\n  // else wait for user to enter the location\n  else {\n    String input;\n\n    Serial.println(&quot;Enter &#039;scan {location}&#039; to start the scanning&quot;);\n\n    while (!Serial.available())\n      delay(200);\n\n    input = Serial.readStringUntil(&#039;\\n&#039;);\n\n    if (input.indexOf(&quot;scan &quot;) == 0) {\n      input.replace(&quot;scan &quot;, &quot;&quot;);\n      location = input;\n    }\n    else {\n      location = &quot;&quot;;\n    }\n  }\n}</code></pre>\n<p>Upload the sketch to your board and start mapping your house / office: go to the target location and type <code>scan {location}</code> in the serial monitor, where <code>{location}</code>is the name you want to give to the current location (so, for example, if you're mapping the kitchen, type <code>scan kitchen</code>).</p>\n<p>Move around the room a bit so you capture a few variations of the visible hotspots: this will lead to a more robust classification later on.</p>\n<p>To stop the recording just type <code>stop</code> in the serial monitor.</p>\n<p>Now repeat this process for each location you want to classify. At this point you should have ended with something similar to the following:</p>\n<pre><code class=\"language-python\">{&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n{&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n{&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n{&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}</code></pre>\n<p>In your case, &quot;N1&quot;, &quot;N2&quot;... will contain the name of the visible networks.</p>\n<p>When you're happy with your training data, it's time to convert it to something useful.</p>\n<h2 id=\"tocgenerating-the-features-converter\">Generating the features converter</h2>\n<p>Given the data we have, we want to generate C code that can convert a Wifi scan result into a feature vector we can use for classification.</p>\n<p>Since I'm a fan of code-generators, I wrote one specifically for this very project. And since I already have a code-generator library I use for Machine Learning code written in Python, I updated it with this new functionality.</p>\n<div class=\"watchout\">You must have Python installed on your system</div>\n<p>Start by installing the library.</p>\n<pre><code class=\"language-bash\"># be sure it installs version &gt;= 1.1.8\npip install --upgrade micromlgen</code></pre>\n<p>Now create a script with the following code:</p>\n<pre><code class=\"language-python\">from micromlgen import port_wifi_indoor_positioning\n\nif __name__ == &#039;__main__&#039;:\n    samples = &#039;&#039;&#039;\n    {&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\n    &#039;&#039;&#039;\n    X, y, classmap, converter_code = port_wifi_indoor_positioning(samples)\n    print(converter_code)</code></pre>\n<p>Of course you have to replace the <code>samples</code> content with the output you got in the previous step. </p>\n<p>In the console you should see a C++ class we will use later in the Arduino sketch. The class should be similar to the following example code.</p>\n<pre><code class=\"language-cpp\">// Save this code in your sketch as Converter.h\n\n#pragma once\nnamespace Eloquent {\n    namespace Projects {\n        class WifiIndoorPositioning {\n            public:\n                /**\n                * Get feature vector\n                */\n                float* getFeatures() {\n                    static float features[5] = {0};\n                    uint8_t numNetworks = WiFi.scanNetworks();\n\n                    for (uint8_t i = 0; i &lt; 5; i++) {\n                        features[i] = 0;\n                    }\n\n                    for (uint8_t i = 0; i &lt; numNetworks; i++) {\n                        int featureIdx = ssidToFeatureIdx(WiFi.SSID(i));\n\n                        if (featureIdx &gt;= 0) {\n                            features[featureIdx] = WiFi.RSSI(i);\n                        }\n                    }\n\n                    return features;\n                }\n\n            protected:\n                /**\n                * Convert SSID to featureIdx\n                */\n                int ssidToFeatureIdx(String ssid) {\n                    if (ssid.equals(&quot;N1&quot;))\n                    return 0;\n\n                    if (ssid.equals(&quot;N2&quot;))\n                    return 1;\n\n                    if (ssid.equals(&quot;N3&quot;))\n                    return 2;\n\n                    if (ssid.equals(&quot;N4&quot;))\n                    return 3;\n\n                    if (ssid.equals(&quot;N5&quot;))\n                    return 4;\n\n                    return -1;\n                }\n            };\n        }\n    }</code></pre>\n<p>I will briefly explain what it does: when you call <code>getFeatures()</code>, it runs a Wifi scan and for each network it finds, it fills the corresponding element in the feature vector (if the network is a known one).</p>\n<p>At the end of the procedure, your feature vector will look something like <code>[0, 10, 0, 0, 50, 0, 0]</code>, each element representing the RSSI of a given network.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2 id=\"tocgenerating-the-classifier\">Generating the classifier</h2>\n<p>To close the loop of the project, we need to be able to classify the features vector into one of the recorded location. Since we already have <code>micromlgen</code> installed, it will be very easy to do so.</p>\n<p>Let's update the Python code we already have: this time, instead of printing the converter code, we will print the classifier code.</p>\n<pre><code class=\"language-bash\"># install ml package first\npip install scikit-learn</code></pre>\n<pre><code class=\"language-python\">from sklearn.tree import DecisionTreeClassifier\nfrom micromlgen import port_wifi_indoor_positioning, port\n\nif __name__ == &#039;__main__&#039;:\n    samples = &#039;&#039;&#039;\n    {&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\n    &#039;&#039;&#039;\n    X, y, classmap, converter_code = port_wifi_indoor_positioning(samples)\n    clf = DecisionTreeClassifier()\n    clf.fit(X, y)\n    print(port(clf, classmap=classmap))</code></pre>\n<p>Here I chose <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html\">Decision tree</a> because it is a very lightweight algorithm and should work fine for the kind of features we're working with.<br />\nIf you're not satisfied with the results, you can try to use <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html?highlight=svc#sklearn.svm.SVC\">SVM</a> or <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.GaussianNB.html?highlight=gaussiannb#sklearn.naive_bayes.GaussianNB\">Gaussian Naive Bayes</a>, which are both supported by <code>micromlgen</code>.</p>\n<p>In the console you will see the generated code for the classifier you trained. In the case of <code>DecisionTree</code> the code will look like the following.</p>\n<pre><code class=\"language-cpp\">// Save this code in your sketch as Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class DecisionTree {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        if (x[2] &lt;= 25.0) {\n                            if (x[4] &lt;= 50.0) {\n                                return 1;\n                            }\n\n                            else {\n                                return 2;\n                            }\n                        }\n\n                        else {\n                            return 0;\n                        }\n                    }\n\n                    /**\n                    * Convert class idx to readable name\n                    */\n                    const char* predictLabel(float *x) {\n                        switch (predict(x)) {\n                            case 0:\n                            return &quot;Bathroom&quot;;\n                            case 1:\n                            return &quot;Bedroom&quot;;\n                            case 2:\n                            return &quot;Kitchen&quot;;\n                            default:\n                            return &quot;Houston we have a problem&quot;;\n                        }\n                    }\n\n                protected:\n                };\n            }\n        }\n    }</code></pre>\n<h2 id=\"tocwrapping-it-all-together\">Wrapping it all together</h2>\n<p>Now that we have all the pieces together, we only need to merge them to get a complete working example.</p>\n<pre><code class=\"language-cpp\">// file WifiIndoorPositioning.h\n\n#include &quot;WiFi.h&quot;\n#include &quot;Converter.h&quot;\n#include &quot;Classifier.h&quot;\n\nEloquent::Projects::WifiIndoorPositioning positioning;\nEloquent::ML::Port::DecisionTree classifier;\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  Serial.print(&quot;You&#039;re in &quot;);\n  Serial.println(classifier.predictLabel(positioning.getFeatures()));\n  delay(3000);\n}</code></pre>\n<p>To the bare minimum, the above code runs the scan and tells you which location you're in. That's it.</p>\n<h3 id=\"tocdisclaimer\">Disclaimer</h3>\n<p>This system should be pretty accurate and robust if you properly gather the data, though I can quantify how much accurate.</p>\n<p>This is not an <em>indoor navigation system</em>: it can't tell you &quot;the coordinates&quot; of where you are, it can only detect in which room you're in.</p>\n<p>If your location lack of nearby Wifi hotspots, an easy and cheap solution would be to spawn a bunch of ESP8266 / ESP32 boards around your house each acting as Access Point: with this simple trick you should be able to be as accurate as needed by just adding more boards.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<hr />\n<p>With this in-depth tutorial I hope I helped you going from start to end of setting up a Wifi indoor positioning system using cheap hardware as ESP8266 / ESP32 boards and the Arduino IDE. </p>\n<p>As you can see, Machine learning has not to be intimidating even for beginners: you just need the right tools to get the job done.</p>\n<p>If this guide excited you about Machine learning on microcontrollers, I invite you to read the many other posts I wrote on the topic and share them on the socials.</p>\n<p>You can find the whole project on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/tree/master/examples/TheUltimateGuideToWifiIndoorPositioning\">Github</a>. Don't forget to star the repo if you like it.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/08/the-ultimate-guide-to-wifi-indoor-positioning-using-arduino-and-machine-learning/\">The Ultimate Guide to Wifi Indoor Positioning using Arduino and Machine Learning</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "This will be the most detailed, easy to follow tutorial over the Web on how to implement Wifi indoor positioning using an Arduino microcontroller and Machine Learning. It contains all the steps, tools and code from the start to the end of the project.\n\nri-elaborated from https://www.accuware.com/blog/ambient-signals-plus-video-images/\n\nMy original post abot Wifi indoor positioning is one of my top-performing post of all time (after motion detection using ESP32 camera and the introductory post on Machine Learning for Arduino). This is why I settled to revamp it and add some more details, tools and scripts to create the most complete free guide on how to implement such a system, from the beginning to the end.\nThis post will cover all the necessary steps and provide all the code you need: for an introduction to the topic, I point you to the original post.\nTable of contentsFeatures definitionData gatheringGenerating the features converterGenerating the classifierWrapping it all togetherDisclaimer\nFeatures definition\nThis part stays the same as the original post: we will use the RSSIs (signal strength) of the nearby Wifi hotspots to classifiy which location we're in.\nEach location will &quot;see&quot; a certain number of networks, each with a RSSI that will stay mostly the same: the unique combination of these RSSIs will become a fingerprint to distinguish the locations from one another.\nSince not all networks will be visible all the time, the shape of our data will be more likely a sparse matrix.\nA sparse matrix is a matrix where most of the elements will be zero, meaning the absence of the given feature. Only the relevant elements will be non-zero and will represent the RSSI of the nth network.\nThe following example table should give you an idea of what our data will look like.\n\n\n\nLocation\nNet #1\nNet #2\nNet #3\nNet #4\nNet #5\nNet #6\nNet #7\n\n\n\n\nKitchen/1\n50\n30\n60\n0\n0\n0\n0\n\n\nKitchen/2\n55\n30\n55\n0\n0\n5\n0\n\n\nKitchen/3\n50\n35\n65\n0\n0\n0\n5\n\n\nBedroom/1\n0\n80\n0\n80\n0\n40\n40\n\n\nBedroom/2\n0\n80\n0\n85\n10\n20\n20\n\n\nBedroom/3\n0\n70\n0\n85\n0\n30\n40\n\n\nBathroom/1\n0\n0\n30\n80\n80\n0\n0\n\n\nBathroom/2\n0\n0\n10\n90\n85\n0\n0\n\n\nBathroom/3\n0\n0\n30\n90\n90\n5\n0\n\n\n\nEven though the numbers in this table are fake, you should recognize a pattern:\n\neach location is characterized by a certain combination of always-visible networks\nsome sample could be &quot;noised&quot; by weak networks (the 5 in the table)\n\nOur machine learning algorithm should be able to extract each location's fingerprint without being fooled by this inconsistent features.\nData gathering\nNow that we know what our data should look like, we need to first get it.\nIn the original post, this point was the one I'm unhappy with since it's not as straight-forward as I would have liked. The method I present you in this post, instead, is by far way simpler to follow.\nFirst of all, you will need a Wifi equipped board. I will use an Arduino MKR WiFi 1010, but any ESP8266 / ESP32 or the like will work.\nThe following sketch will do the job: it scans the visible networks at a regular interval and prints their RSSIs encoded in JSON format.\n// file DataGathering.h\n\n#include &quot;WiFi.h&quot;\n\n#define print(string) Serial.print(string);\n#define quote(string) print(&#039;&quot;&#039;); print(string); print(&#039;&quot;&#039;);\n\nString location = &quot;&quot;;\n\n/**\n * \n */\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n  WiFi.disconnect();\n}\n\n/**\n * \n */\nvoid loop() {  \n  // if location is set, scan networks\n  if (location != &quot;&quot;) {\n    int numNetworks = WiFi.scanNetworks();\n\n    // print location\n    print(&#039;{&#039;);\n    quote(&quot;__location&quot;);\n    print(&quot;: &quot;);\n    quote(location);\n    print(&quot;, &quot;);\n\n    // print each network SSID and RSSI\n    for (int i = 0; i &lt; numNetworks; i++) {\n      quote(WiFi.SSID(i));\n      print(&quot;: &quot;);\n      print(WiFi.RSSI(i));\n      print(i == numNetworks - 1 ? &quot;}\\n&quot; : &quot;, &quot;);\n    }\n\n    delay(1000);\n  }\n  // else wait for user to enter the location\n  else {\n    String input;\n\n    Serial.println(&quot;Enter &#039;scan {location}&#039; to start the scanning&quot;);\n\n    while (!Serial.available())\n      delay(200);\n\n    input = Serial.readStringUntil(&#039;\\n&#039;);\n\n    if (input.indexOf(&quot;scan &quot;) == 0) {\n      input.replace(&quot;scan &quot;, &quot;&quot;);\n      location = input;\n    }\n    else {\n      location = &quot;&quot;;\n    }\n  }\n}\nUpload the sketch to your board and start mapping your house / office: go to the target location and type scan {location} in the serial monitor, where {location}is the name you want to give to the current location (so, for example, if you're mapping the kitchen, type scan kitchen).\nMove around the room a bit so you capture a few variations of the visible hotspots: this will lead to a more robust classification later on.\nTo stop the recording just type stop in the serial monitor.\nNow repeat this process for each location you want to classify. At this point you should have ended with something similar to the following:\n{&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n{&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n{&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n{&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\nIn your case, &quot;N1&quot;, &quot;N2&quot;... will contain the name of the visible networks.\nWhen you're happy with your training data, it's time to convert it to something useful.\nGenerating the features converter\nGiven the data we have, we want to generate C code that can convert a Wifi scan result into a feature vector we can use for classification.\nSince I'm a fan of code-generators, I wrote one specifically for this very project. And since I already have a code-generator library I use for Machine Learning code written in Python, I updated it with this new functionality.\nYou must have Python installed on your system\nStart by installing the library.\n# be sure it installs version &gt;= 1.1.8\npip install --upgrade micromlgen\nNow create a script with the following code:\nfrom micromlgen import port_wifi_indoor_positioning\n\nif __name__ == &#039;__main__&#039;:\n    samples = &#039;&#039;&#039;\n    {&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\n    &#039;&#039;&#039;\n    X, y, classmap, converter_code = port_wifi_indoor_positioning(samples)\n    print(converter_code)\nOf course you have to replace the samples content with the output you got in the previous step. \nIn the console you should see a C++ class we will use later in the Arduino sketch. The class should be similar to the following example code.\n// Save this code in your sketch as Converter.h\n\n#pragma once\nnamespace Eloquent {\n    namespace Projects {\n        class WifiIndoorPositioning {\n            public:\n                /**\n                * Get feature vector\n                */\n                float* getFeatures() {\n                    static float features[5] = {0};\n                    uint8_t numNetworks = WiFi.scanNetworks();\n\n                    for (uint8_t i = 0; i &lt; 5; i++) {\n                        features[i] = 0;\n                    }\n\n                    for (uint8_t i = 0; i &lt; numNetworks; i++) {\n                        int featureIdx = ssidToFeatureIdx(WiFi.SSID(i));\n\n                        if (featureIdx &gt;= 0) {\n                            features[featureIdx] = WiFi.RSSI(i);\n                        }\n                    }\n\n                    return features;\n                }\n\n            protected:\n                /**\n                * Convert SSID to featureIdx\n                */\n                int ssidToFeatureIdx(String ssid) {\n                    if (ssid.equals(&quot;N1&quot;))\n                    return 0;\n\n                    if (ssid.equals(&quot;N2&quot;))\n                    return 1;\n\n                    if (ssid.equals(&quot;N3&quot;))\n                    return 2;\n\n                    if (ssid.equals(&quot;N4&quot;))\n                    return 3;\n\n                    if (ssid.equals(&quot;N5&quot;))\n                    return 4;\n\n                    return -1;\n                }\n            };\n        }\n    }\nI will briefly explain what it does: when you call getFeatures(), it runs a Wifi scan and for each network it finds, it fills the corresponding element in the feature vector (if the network is a known one).\nAt the end of the procedure, your feature vector will look something like [0, 10, 0, 0, 50, 0, 0], each element representing the RSSI of a given network.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nGenerating the classifier\nTo close the loop of the project, we need to be able to classify the features vector into one of the recorded location. Since we already have micromlgen installed, it will be very easy to do so.\nLet's update the Python code we already have: this time, instead of printing the converter code, we will print the classifier code.\n# install ml package first\npip install scikit-learn\nfrom sklearn.tree import DecisionTreeClassifier\nfrom micromlgen import port_wifi_indoor_positioning, port\n\nif __name__ == &#039;__main__&#039;:\n    samples = &#039;&#039;&#039;\n    {&quot;__location&quot;: &quot;Kitchen&quot;, &quot;N1&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bedroom&quot;, &quot;N3&quot;: 100, &quot;N2&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N1&quot;: 100, &quot;N4&quot;: 50}\n    {&quot;__location&quot;: &quot;Bathroom&quot;, &quot;N5&quot;: 100, &quot;N4&quot;: 50}\n    &#039;&#039;&#039;\n    X, y, classmap, converter_code = port_wifi_indoor_positioning(samples)\n    clf = DecisionTreeClassifier()\n    clf.fit(X, y)\n    print(port(clf, classmap=classmap))\nHere I chose Decision tree because it is a very lightweight algorithm and should work fine for the kind of features we're working with.\nIf you're not satisfied with the results, you can try to use SVM or Gaussian Naive Bayes, which are both supported by micromlgen.\nIn the console you will see the generated code for the classifier you trained. In the case of DecisionTree the code will look like the following.\n// Save this code in your sketch as Classifier.h\n\n#pragma once\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class DecisionTree {\n                public:\n                    /**\n                    * Predict class for features vector\n                    */\n                    int predict(float *x) {\n                        if (x[2] &lt;= 25.0) {\n                            if (x[4] &lt;= 50.0) {\n                                return 1;\n                            }\n\n                            else {\n                                return 2;\n                            }\n                        }\n\n                        else {\n                            return 0;\n                        }\n                    }\n\n                    /**\n                    * Convert class idx to readable name\n                    */\n                    const char* predictLabel(float *x) {\n                        switch (predict(x)) {\n                            case 0:\n                            return &quot;Bathroom&quot;;\n                            case 1:\n                            return &quot;Bedroom&quot;;\n                            case 2:\n                            return &quot;Kitchen&quot;;\n                            default:\n                            return &quot;Houston we have a problem&quot;;\n                        }\n                    }\n\n                protected:\n                };\n            }\n        }\n    }\nWrapping it all together\nNow that we have all the pieces together, we only need to merge them to get a complete working example.\n// file WifiIndoorPositioning.h\n\n#include &quot;WiFi.h&quot;\n#include &quot;Converter.h&quot;\n#include &quot;Classifier.h&quot;\n\nEloquent::Projects::WifiIndoorPositioning positioning;\nEloquent::ML::Port::DecisionTree classifier;\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  Serial.print(&quot;You&#039;re in &quot;);\n  Serial.println(classifier.predictLabel(positioning.getFeatures()));\n  delay(3000);\n}\nTo the bare minimum, the above code runs the scan and tells you which location you're in. That's it.\nDisclaimer\nThis system should be pretty accurate and robust if you properly gather the data, though I can quantify how much accurate.\nThis is not an indoor navigation system: it can't tell you &quot;the coordinates&quot; of where you are, it can only detect in which room you're in.\nIf your location lack of nearby Wifi hotspots, an easy and cheap solution would be to spawn a bunch of ESP8266 / ESP32 boards around your house each acting as Access Point: with this simple trick you should be able to be as accurate as needed by just adding more boards.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n\nWith this in-depth tutorial I hope I helped you going from start to end of setting up a Wifi indoor positioning system using cheap hardware as ESP8266 / ESP32 boards and the Arduino IDE. \nAs you can see, Machine learning has not to be intimidating even for beginners: you just need the right tools to get the job done.\nIf this guide excited you about Machine learning on microcontrollers, I invite you to read the many other posts I wrote on the topic and share them on the socials.\nYou can find the whole project on Github. Don't forget to star the repo if you like it.\nL'articolo The Ultimate Guide to Wifi Indoor Positioning using Arduino and Machine Learning proviene da Eloquent Arduino Blog.",
            "date_published": "2020-08-08T15:21:25+02:00",
            "date_modified": "2020-08-09T16:19:32+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "Senza categoria"
            ]
        }
    ]
}