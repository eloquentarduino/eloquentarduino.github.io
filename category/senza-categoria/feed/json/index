{
    "version": "https://jsonfeed.org/version/1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/category/senza-categoria/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/category/senza-categoria/",
    "feed_url": "https://eloquentarduino.github.io/category/senza-categoria/feed/json/",
    "title": "Eloquent Arduino Blog",
    "description": "Machine learning on Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/2020/01/motion-detection-with-esp32-cam-only-arduino-version/",
            "url": "https://eloquentarduino.github.io/2020/01/motion-detection-with-esp32-cam-only-arduino-version/",
            "title": "Motion detection with ESP32 cam only (Arduino version)",
            "content_html": "<p>Do you have an <strong>ESP32 camera</strong>? Do you want to do motion detection <em>WITHOUT ANY</em> external hardware?</p>\n<p>Here's a tutorial made just for you: <strong>30 lines of code</strong> and you will know when something changes in your video stream  \ud83c\udfa5</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.gif\" alt=\"ESP32 camera motion detection example\" /></p>\n<p><span id=\"more-779\"></span></p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tocwhat-is-naive-motion-detection\">What is (naive) motion detection?</a><li><a href=\"#toccant-i-use-an-external-pir\">Can't I use an external PIR?</a><ol><li><a href=\"#tocexternal-hardware\">External hardware</a><li><a href=\"#tocfield-of-view\">Field of View</a><li><a href=\"#toccold-objects\">Cold objects</a></li></ol><li><a href=\"#tocwhat-do-you-need\">What do you need?</a><li><a href=\"#tochow-does-it-work\">How does it work?</a><ol><li><a href=\"#tocdownsampling\">Downsampling</a><li><a href=\"#tocblocks-difference-threshold\">Blocks difference threshold</a><li><a href=\"#tocimage-difference-threshold\">Image difference threshold</a><li><a href=\"#toccombining-all-together\">Combining all together</a></li></ol><li><a href=\"#tocreal-world-example\">Real world example</a></ol></div></p>\n<h2 id=\"tocwhat-is-naive-motion-detection\">What is (naive) motion detection?</h2>\n<p>Quoting from Wikipedia</p>\n<blockquote>\n<p>Motion detection is the process of detecting a change in the position of an object relative to its surroundings or a change in the surroundings relative to an object</p>\n</blockquote>\n<p>In this project, we're implementing what I call <em>naive</em> motion detection: that is, we're not focusing on a particular object and following its motion.</p>\n<p>We'll only detect if any considerable portion of the image changed from one frame to the next.</p>\n<p>We won't identify the location of motion (that's the subject for a next project), neither what caused it. We will analyze video stream in (almost) real-time and compare frame by frame: if lots of pixels changed, we'll call it motion.</p>\n<h2 id=\"toccant-i-use-an-external-pir\">Can't I use an external PIR?</h2>\n<p>Several projects on the internet about motion detection with an ESP32 cam use an external <a href=\"https://en.wikipedia.org/wiki/Passive_infrared_sensor\">PIR sensor</a> to trigger the video recording.</p>\n<p>What's the problem with that approach? </p>\n<h3 id=\"tocexternal-hardware\">1. External hardware</h3>\n<p>First of all, you need external hardware. If you're using a breadboard, no problem, you just need a couple more wires and you're good to go. But I have a nice <a href=\"https://www.banggood.com/M5CameraF-ESP32-Fish-eye-Camera-Development-Board-Module-OV2640-Mini-Fisheye-Camera-Unit-Demoboard-p-1496820.html?rmmds=search&amp;cur_warehouse=CN\">M5stick camera</a> (no affiliate link), that's already well packaged, so it won't be that easy to add a PIR sensor.</p>\n<h3 id=\"tocfield-of-view\">2. Field of View</h3>\n<p>PIR sensors have a limited FOV (field of view), so you will need more than one to cover the whole range of the camera. </p>\n<p>My camera, for example, has fish-eye lens which give me 160\u00b0 of view. Most cheap PIR sensors have a 120\u00b0 field of view, so one will not suffice. This adds even more space to my project.</p>\n<h3 id=\"toccold-objects\">3. Cold objects</h3>\n<p>PIR sensors gets triggered by infrared light. Infrared light gets emitted by hot bodies (like people and animals).</p>\n<p>But motion in a video stream can happen for a variety of reasons, not necessarily due to hot bodies, for example if you want to monitor a street for cars passing by.</p>\n<p>A PIR sensor can't do this: video motion detection can.</p>\n<hr /><p><em>ESP32 cam pure video motion detection can detect motion due to cold objects</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2020%2F01%2Fmotion-detection-with-esp32-cam-only-arduino-version%2F&#038;text=ESP32%20cam%20pure%20video%20motion%20detection%20can%20detect%20motion%20due%20to%20cold%20objects&#038;via=EloquentArduino&#038;related=EloquentArduino' target='_blank' rel=\"noopener noreferrer\" >Click To Tweet</a><br /><hr />\n<h2 id=\"tocwhat-do-you-need\">What do you need?</h2>\n<p>All you need for this project is a board with a camera sensor. As I said, I have a M5Stick Camera with fish-eye lens, but any ESP32 based camera should work out of the box:</p>\n<ul>\n<li>ESP32 cam</li>\n<li>ESP32 eye</li>\n<li>TTGO camera</li>\n<li>... any other flavor of ESP32 camera</li>\n</ul>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-models.jpg\" alt=\"ESP32 camera models\" /></p>\n<h2 id=\"tochow-does-it-work\">How does it work?</h2>\n<p>Ok, let's go to the &quot;technical&quot; stuff.</p>\n<p>Simply put, the algorithm counts the number of different pixels from one frame to the next: if many pixels changed, it will detect motion.</p>\n<p>Well, it's <em>almost</em> like this.</p>\n<p>Of course such an algorithm will be very sensitive to noise (which is quite high on these low-cost cameras). We need to mitigate false-positive triggers.</p>\n<h3 id=\"tocdownsampling\">Downsampling</h3>\n<p>One super-simple and super-effective way of doing this is to <strong>work with blocks</strong>, instead of pixels. A block is simply an N x N square, whose value is the average of the pixels it contains.</p>\n<p>This greatly reduces sensitivity to noise, providing a more robust detection. Here's an example of what the the &quot;block-ing&quot; operation does to an image.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/01/Image-downsampling-example.jpg\" alt=\"Image downsampling example\" /></p>\n<p>It's really a &quot;pixelating&quot; effect: you take the orginal image (let's say 320x240 pixels) and resize it to 10x smaller, 32x24.  </p>\n<p>This has the added benefit that it's much more lightweight to work with 32x24 matrix instead of 320x240 matrix: if you want to do real-time detection, this is a MUST.</p>\n<p>How should you choose the scale factor?</p>\n<p>Well, it depends.</p>\n<p>It depends on the sensitivity you want to achieve. The higher the downsampling, the less sensitive your detection will be. </p>\n<p>If you want to detect a person passing 50cm away from the camera, you can increase this number without any problem. If you want to detect a dog 10m away, you should keep it in the 5-10 range.</p>\n<p>Experiment with your own use case a tweak with trial-and-error.</p>\n<h3 id=\"tocblocks-difference-threshold\">Blocks difference threshold</h3>\n<p>Once we've defined the block size, we need to detect if a block changed from one frame to the next.</p>\n<p>Of course, just testing for difference (<code>current != prev</code>) would be again too sensitive to noise. A block can change for a variety of reasons, the first of which is the bad camera quality.</p>\n<p>So we instead define a percent threshold above which we can say for sure the block actually changed. A good starting point could be 10-20%, but again you need to tweak this to your needs.</p>\n<p>The higher the threshold, the less sensitive the algorithm will be.</p>\n<p>In code it is calculated as</p>\n<pre><code class=\"language-cpp\">float delta = abs(currentBlockValue - prevBlockValue) / prevBlockValue;</code></pre>\n<p>which indicates the relative increment/decrement from the previous value.</p>\n<h3 id=\"tocimage-difference-threshold\">Image difference threshold</h3>\n<p>Now that we can detect if a block changed from one frame to the next, we can actually detect if the image changed.</p>\n<p>You could decide to trigger motion even if a single block changed, but I suggest you to set an higher value here.</p>\n<p>Let's return to the 320x240 image example. With a 10x10 block, you'll be working with <code>32x24 = 768</code> blocks: will you call it &quot;motion&quot; if 1 out of 768 blocks changed value?</p>\n<p>I don't think so. You want something more robust. You want 50 blocks to change. Or at least 20 blocks. If you do the math, 20 blocks out of 768 is only the 2.5% of change, which is hardly noticeable.</p>\n<p>If you want to be robust, don't set this threshold to a too low value. Again, tweak with real world experimenting.</p>\n<p>In code it is calculated as:</p>\n<pre><code class=\"language-cpp\">float changedBlocksPercent = changedBlocks / totalBlocks</code></pre>\n<h3 id=\"toccombining-all-together\">Combining all together</h3>\n<p>Recapping: when running the motion detection algorithm you have 3 parameters to set:</p>\n<ol>\n<li>the block size</li>\n<li>the block difference threshold</li>\n<li>the image differerence threshold</li>\n</ol>\n<p>Let's pick 3 sensible defaults: <code>block size = 10</code>, <code>block threshold = 15%</code>, <code>image threshold = 20%</code>.</p>\n<p>What does these parameters translate to in the practice?</p>\n<p>They mean that motion will be detected if <code>20% of the image, averaged in blocks of 10x10, changed its value by at least 15% from one frame to the next</code>.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-example.jpg\" alt=\"ESP32 camera motion example\" /></p>\n<p>As you can see, you don't need high-definition images to (naively) detect if something happened to the image. Large area of motion will be easily detectable, even at very low resolution.</p>\n<h2 id=\"tocreal-world-example\">Real world example</h2>\n<p>Now the fun part. I'll show you how it performs on a real-world scenario.</p>\n<p>To keep it simple, I wrote a sketch that does only motion detection, not video streaming over HTTP. </p>\n<p>This means you won't be able to see the original image recorded from the camera. Nevertheless, I have kept the block size to a minimum to allow for the best quality possible.</p>\n<div style=\"width: 652px;\" class=\"wp-video\"><!--[if lt IE 9]><script>document.createElement('video');</script><![endif]-->\n<video class=\"wp-video-shortcode\" id=\"video-779-1\" width=\"652\" height=\"604\" preload=\"metadata\" controls=\"controls\"><source type=\"video/mp4\" src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.mp4?_=1\" /><a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.mp4\">https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.mp4</a></video></div>\n<p>This is me passing my arm in front of the camera a few times.</p>\n<p>The grid you see represents the actual pixels used for the computation. Each cell corresponds to one pixel of the downscaled image.</p>\n<p>The orange cells highlight the pixels that the algorithm sees as &quot;different&quot; from one frame to the next. As you can see, some pixels are detected even if no motion is happening. That's the noise I talked about multiple times during the post.</p>\n<p>When I move my arm in the frame, you see lots of pixels become activated, so the &quot;Motion&quot; text appears. </p>\n<p>While moving the arm, you may notice what I call the &quot;ghost&quot; effect. You actually see 2 regions of motion: one is where my arm is now, which of course changed. The other is the region where my arm was in the previous frame, which returned to its original content.</p>\n<p>This is why I suggest you keep the <code>image difference threshold</code> to a high value: if some real motion happens, you will notice it for sure because the activated region of the image will be actually bigger than the actual object moving.</p>\n<p>Do you like the grid effect of the sample video? Let me know in the comment if you want me to share it.</p>\n<p>Or even better: subscribe to the newsletter I you will get it directly in your inbox with my next mail.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">STAY UP TO DATE</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<hr>\r\n<p>Check the full project code on <a href=\"https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/ESP32CameraNaiveMotionDetection/ESP32CameraNaiveMotionDetection.ino\" target=\"_blank\" rel=\"noopener noreferrer\">Github</a></p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/01/motion-detection-with-esp32-cam-only-arduino-version/\">Motion detection with ESP32 cam only (Arduino version)</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Do you have an ESP32 camera? Do you want to do motion detection WITHOUT ANY external hardware?\nHere's a tutorial made just for you: 30 lines of code and you will know when something changes in your video stream  \ud83c\udfa5\n\n\nTable of contentsWhat is (naive) motion detection?Can't I use an external PIR?External hardwareField of ViewCold objectsWhat do you need?How does it work?DownsamplingBlocks difference thresholdImage difference thresholdCombining all togetherReal world example\nWhat is (naive) motion detection?\nQuoting from Wikipedia\n\nMotion detection is the process of detecting a change in the position of an object relative to its surroundings or a change in the surroundings relative to an object\n\nIn this project, we're implementing what I call naive motion detection: that is, we're not focusing on a particular object and following its motion.\nWe'll only detect if any considerable portion of the image changed from one frame to the next.\nWe won't identify the location of motion (that's the subject for a next project), neither what caused it. We will analyze video stream in (almost) real-time and compare frame by frame: if lots of pixels changed, we'll call it motion.\nCan't I use an external PIR?\nSeveral projects on the internet about motion detection with an ESP32 cam use an external PIR sensor to trigger the video recording.\nWhat's the problem with that approach? \n1. External hardware\nFirst of all, you need external hardware. If you're using a breadboard, no problem, you just need a couple more wires and you're good to go. But I have a nice M5stick camera (no affiliate link), that's already well packaged, so it won't be that easy to add a PIR sensor.\n2. Field of View\nPIR sensors have a limited FOV (field of view), so you will need more than one to cover the whole range of the camera. \nMy camera, for example, has fish-eye lens which give me 160\u00b0 of view. Most cheap PIR sensors have a 120\u00b0 field of view, so one will not suffice. This adds even more space to my project.\n3. Cold objects\nPIR sensors gets triggered by infrared light. Infrared light gets emitted by hot bodies (like people and animals).\nBut motion in a video stream can happen for a variety of reasons, not necessarily due to hot bodies, for example if you want to monitor a street for cars passing by.\nA PIR sensor can't do this: video motion detection can.\nESP32 cam pure video motion detection can detect motion due to cold objectsClick To Tweet\nWhat do you need?\nAll you need for this project is a board with a camera sensor. As I said, I have a M5Stick Camera with fish-eye lens, but any ESP32 based camera should work out of the box:\n\nESP32 cam\nESP32 eye\nTTGO camera\n... any other flavor of ESP32 camera\n\n\nHow does it work?\nOk, let's go to the &quot;technical&quot; stuff.\nSimply put, the algorithm counts the number of different pixels from one frame to the next: if many pixels changed, it will detect motion.\nWell, it's almost like this.\nOf course such an algorithm will be very sensitive to noise (which is quite high on these low-cost cameras). We need to mitigate false-positive triggers.\nDownsampling\nOne super-simple and super-effective way of doing this is to work with blocks, instead of pixels. A block is simply an N x N square, whose value is the average of the pixels it contains.\nThis greatly reduces sensitivity to noise, providing a more robust detection. Here's an example of what the the &quot;block-ing&quot; operation does to an image.\n\nIt's really a &quot;pixelating&quot; effect: you take the orginal image (let's say 320x240 pixels) and resize it to 10x smaller, 32x24.  \nThis has the added benefit that it's much more lightweight to work with 32x24 matrix instead of 320x240 matrix: if you want to do real-time detection, this is a MUST.\nHow should you choose the scale factor?\nWell, it depends.\nIt depends on the sensitivity you want to achieve. The higher the downsampling, the less sensitive your detection will be. \nIf you want to detect a person passing 50cm away from the camera, you can increase this number without any problem. If you want to detect a dog 10m away, you should keep it in the 5-10 range.\nExperiment with your own use case a tweak with trial-and-error.\nBlocks difference threshold\nOnce we've defined the block size, we need to detect if a block changed from one frame to the next.\nOf course, just testing for difference (current != prev) would be again too sensitive to noise. A block can change for a variety of reasons, the first of which is the bad camera quality.\nSo we instead define a percent threshold above which we can say for sure the block actually changed. A good starting point could be 10-20%, but again you need to tweak this to your needs.\nThe higher the threshold, the less sensitive the algorithm will be.\nIn code it is calculated as\nfloat delta = abs(currentBlockValue - prevBlockValue) / prevBlockValue;\nwhich indicates the relative increment/decrement from the previous value.\nImage difference threshold\nNow that we can detect if a block changed from one frame to the next, we can actually detect if the image changed.\nYou could decide to trigger motion even if a single block changed, but I suggest you to set an higher value here.\nLet's return to the 320x240 image example. With a 10x10 block, you'll be working with 32x24 = 768 blocks: will you call it &quot;motion&quot; if 1 out of 768 blocks changed value?\nI don't think so. You want something more robust. You want 50 blocks to change. Or at least 20 blocks. If you do the math, 20 blocks out of 768 is only the 2.5% of change, which is hardly noticeable.\nIf you want to be robust, don't set this threshold to a too low value. Again, tweak with real world experimenting.\nIn code it is calculated as:\nfloat changedBlocksPercent = changedBlocks / totalBlocks\nCombining all together\nRecapping: when running the motion detection algorithm you have 3 parameters to set:\n\nthe block size\nthe block difference threshold\nthe image differerence threshold\n\nLet's pick 3 sensible defaults: block size = 10, block threshold = 15%, image threshold = 20%.\nWhat does these parameters translate to in the practice?\nThey mean that motion will be detected if 20% of the image, averaged in blocks of 10x10, changed its value by at least 15% from one frame to the next.\n\nAs you can see, you don't need high-definition images to (naively) detect if something happened to the image. Large area of motion will be easily detectable, even at very low resolution.\nReal world example\nNow the fun part. I'll show you how it performs on a real-world scenario.\nTo keep it simple, I wrote a sketch that does only motion detection, not video streaming over HTTP. \nThis means you won't be able to see the original image recorded from the camera. Nevertheless, I have kept the block size to a minimum to allow for the best quality possible.\n\nhttps://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.mp4\nThis is me passing my arm in front of the camera a few times.\nThe grid you see represents the actual pixels used for the computation. Each cell corresponds to one pixel of the downscaled image.\nThe orange cells highlight the pixels that the algorithm sees as &quot;different&quot; from one frame to the next. As you can see, some pixels are detected even if no motion is happening. That's the noise I talked about multiple times during the post.\nWhen I move my arm in the frame, you see lots of pixels become activated, so the &quot;Motion&quot; text appears. \nWhile moving the arm, you may notice what I call the &quot;ghost&quot; effect. You actually see 2 regions of motion: one is where my arm is now, which of course changed. The other is the region where my arm was in the previous frame, which returned to its original content.\nThis is why I suggest you keep the image difference threshold to a high value: if some real motion happens, you will notice it for sure because the activated region of the image will be actually bigger than the actual object moving.\nDo you like the grid effect of the sample video? Let me know in the comment if you want me to share it.\nOr even better: subscribe to the newsletter I you will get it directly in your inbox with my next mail.\n\r\n\r\n\r\n    \r\n\tSTAY UP TO DATE\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n\r\nCheck the full project code on Github\nL'articolo Motion detection with ESP32 cam only (Arduino version) proviene da Eloquent Arduino Blog.",
            "date_published": "2020-01-05T12:08:08+01:00",
            "date_modified": "2020-01-05T15:06:34+01:00",
            "author": {
                "name": "simone",
                "url": "https://eloquentarduino.github.io/author/simone/",
                "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
            },
            "tags": [
                "Senza categoria"
            ],
            "attachments": [
                [
                    {
                        "url": "https://eloquentarduino.github.io/wp-content/uploads/2020/01/ESP32-camera-motion-detection-example.mp4",
                        "mime_type": "video/mp4",
                        "size_in_bytes": 1673368
                    }
                ]
            ]
        }
    ]
}