<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Eloquent library &#8211; Eloquent Arduino Blog</title>
	<atom:link href="https://eloquentarduino.github.io/category/programming/eloquent-library/feed/" rel="self" type="application/rss+xml" />
	<link>http://eloquentarduino.github.io/</link>
	<description>Machine learning on Arduino, programming &#38; electronics</description>
	<lastBuildDate>Wed, 24 Jun 2020 18:26:23 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.3.6</generator>
	<item>
		<title>Easy ESP32 camera HTTP video streaming server</title>
		<link>https://eloquentarduino.github.io/2020/06/easy-esp32-camera-http-video-streaming-server/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Wed, 24 Jun 2020 17:27:33 +0000</pubDate>
				<category><![CDATA[Eloquent library]]></category>
		<category><![CDATA[camera]]></category>
		<category><![CDATA[esp32]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=1203</guid>

					<description><![CDATA[<p>This will be a short post where I introduce a new addition to the Arduino Eloquent library aimed to make video streaming from an ESP32 camera over HTTP super easy. It will be the first component of a larger project I'm going to implement. If you Google &#34;esp32 video streaming&#34; you will get a bunch [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/06/easy-esp32-camera-http-video-streaming-server/">Easy ESP32 camera HTTP video streaming server</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This will be a short post where I introduce a new addition to the Arduino Eloquent library aimed to make video streaming from an ESP32 camera over HTTP super easy. It will be the first component of a larger project I'm going to implement.</p>
<p><span id="more-1203"></span></p>
<p>If you Google &quot;esp32 video streaming&quot; you will get a bunch of results that are essentialy copy-pasted from the official Espressif repo: many of them neither copy-pasted the code, just tell you to load the example sketch.</p>
<p>And if you try to read it and try to modify just a bit for your own use-case, you won't understand much.</p>
<p>This is the exact environment for an Eloquent component to live: make it painfully easy what's messy.</p>
<p>I still have to find a good naming scheme for my libraries since Arduino IDE doesn't allow nested imports, so forgive me if &quot;ESP32CameraHTTPVideoStreamingServer.h&quot; was the best that came to mind.</p>
<p>How easy is it to use?</p>
<p>1 line of code if used in conjuction with my other library <a href="https://github.com/eloquentarduino/EloquentVision">EloquentVision</a>.</p>
<pre><code class="language-cpp">#define CAMERA_MODEL_M5STACK_WIDE
#include &quot;WiFi.h&quot;
#include &quot;EloquentVision.h&quot;
#include &quot;ESP32CameraHTTPVideoStreamingServer.h&quot;

using namespace Eloquent::Vision;
using namespace Eloquent::Vision::Camera;

ESP32Camera camera;
HTTPVideoStreamingServer server(81);

/**
 *
 */
void setup() {
    Serial.begin(115200);
    WiFi.softAP(&quot;ESP32&quot;, &quot;12345678&quot;);

    camera.begin(FRAMESIZE_QVGA, PIXFORMAT_JPEG);
    server.start();

    Serial.print(&quot;Camera Ready! Use &#039;http://&quot;);
    Serial.print(WiFi.softAPIP());
    Serial.println(&quot;:81&#039; to stream&quot;);
}

void loop() {
}</code></pre>
<p><code>HTTPVideoStreamingServer</code> assumes you already initialized your camera. You can achieve this task in the way you prefer: <code>ESP32Camera</code> class makes this a breeze.</p>
<p><code>81</code> in the server constructor is the port you want the server to be listening to.</p>
<p>Once connected to WiFi or started in AP mode, all you have to do is call <code>start()</code>: that's it!</p>
<!-- Begin Mailchimp Signup Form -->
<div id="mc_embed_signup">
<form action="https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
	<h2 style="margin: 0; text-align: center">Finding this content useful?</h2>
<div class="mc-field-group">
	<input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="join the monthly newsletter">
</div>
	<div id="mce-responses" class="clear">
		<div class="response" id="mce-error-response" style="display:none"></div>
		<div class="response" id="mce-success-response" style="display:none"></div>
	</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_f0eaedd94d554cf2ee781742a_37d3496031" tabindex="-1" value=""></div>
    <div class="clear" style="position: relative; top: 8px"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </div>
</form>
</div>

<!--End mc_embed_signup-->
<p>What else is it good for?</p>
<p>The main reason I wrote this piece of library is because one of you reader commented on the <a href="/2020/05/easier-faster-pure-video-esp32-cam-motion-detection/">motion detection post</a> asking if it would be possible to start the video streaming once motion is detected.</p>
<p>Of course it is.</p>
<p>It's just a matter of composing the Eloquent pieces.</p>
<pre><code class="language-cpp">#define CAMERA_MODEL_M5STACK_WIDE
#include &quot;WiFi.h&quot;
#include &quot;EloquentVision.h&quot;
#include &quot;ESP32CameraHTTPVideoStreamingServer.h&quot;

#define SOURCE_WIDTH 320
#define SOURCE_HEIGHT 240
#define BLOCK_SIZE 10
#define BLOCK_DIFF_THRESHOLD 0.2
#define IMAGE_DIFF_THRESHOLD 0.1

using namespace Eloquent::Vision;
using namespace Eloquent::Vision::Camera;
using namespace Eloquent::Vision::ImageProcessing;
using namespace Eloquent::Vision::ImageProcessing::Downscale;

ESP32Camera camera;
HTTPVideoStreamingServer server(81);
MotionDetection&lt; SOURCE_WIDTH, SOURCE_HEIGHT, BLOCK_SIZE&gt; motion(nearest);

/**
 *
 */
void setup() {
    Serial.begin(115200);
    WiFi.softAP(&quot;ESP32&quot;, &quot;12345678&quot;);

    camera.begin(FRAMESIZE_QVGA, PIXFORMAT_JPEG);

    Serial.print(&quot;Camera Ready! Use &#039;http://&quot;);
    Serial.print(WiFi.softAPIP());
    Serial.println(&quot;:81&#039; to stream&quot;);
}

void loop() {
    motion.update(camera.capture()-&gt;buf);

    if (motion.detectRatio() &gt; IMAGE_DIFF_THRESHOLD) {
        Serial.print(&quot;Motion detected&quot;);
        // start the streaming server when motion is detected
        // shutdown after 20 seconds if no one connects
        server.start();
        delay(20000);
        server.stop();
    }

    // probably we don&#039;t need 30 fps, save some power
    delay(300);
}</code></pre>
<p>Does it look good?</p>
<p>Now the rationale behind Eloquent components should be starting to be clear to you: easy to use objects you can compose the way it fits to achieve the result you want.</p>
<p>Would you suggest me more piece of functionality you would like to see wrapped in an Eloquent component?</p>
<hr />
<p>You can find the <a href="https://github.com/eloquentarduino/EloquentVision/blob/master/src/ESP32CameraHTTPVideoStreamingServer.h">class code</a> and the <a href="https://github.com/eloquentarduino/EloquentVision/blob/master/examples/ESP32CameraHTTPVideoStreamingServerExample/ESP32CameraHTTPVideoStreamingServerExample.ino">example sketch</a> on the <a href="https://github.com/eloquentarduino/EloquentVision">Github repo</a>.</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/06/easy-esp32-camera-http-video-streaming-server/">Easy ESP32 camera HTTP video streaming server</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Easy Arduino thermal camera with (ASCII) video streaming</title>
		<link>https://eloquentarduino.github.io/2020/02/easy-arduino-thermal-camera-with-ascii-video-streaming/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Sat, 29 Feb 2020 16:20:15 +0000</pubDate>
				<category><![CDATA[Computer vision]]></category>
		<category><![CDATA[Electronics]]></category>
		<category><![CDATA[Eloquent library]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=956</guid>

					<description><![CDATA[<p>Ever wanted to use your thermal camera with Arduino but found it difficult to go beyond the tutorials code? Let's see the easiest possible way to view your thermal camera streaming without an LCD display! MLX90640 thermal camera For Arduino there are essentially two thermal camera available: the AMG8833 and the MLX90640. The AMG8833 is [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/02/easy-arduino-thermal-camera-with-ascii-video-streaming/">Easy Arduino thermal camera with (ASCII) video streaming</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Ever wanted to use your thermal camera with Arduino but found it difficult to go beyond the tutorials code? Let's see the easiest possible way to view your thermal camera streaming without an LCD display!</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2020/02/thermal-image-rgb-vs-ascii.jpg" alt="Arduino thermal image rgb vs ascii" /></p>
<p><span id="more-956"></span></p>
<h2>MLX90640 thermal camera</h2>
<p>For Arduino there are essentially two thermal camera available: the AMG8833 and the MLX90640.</p>
<p>The AMG8833 is 8x8 and the MLX90640 is 32x24.</p>
<p>They're not cheap, it is true.</p>
<p>But if you have to spend money, I strongly advise you to buy the MLX90640: I have one and it's not that accurate. I can't imagine how low definition would be the AMG8833.</p>
<p>If you want to actually get something meaningful from the camera, the AMG8833 won't give you any good results.</p>
<p>Sure, you can do interpolation: interpolation would give you <em>the impression</em> you have a better definition, but you're just &quot;inventing&quot; values you don't actually have.</p>
<p>For demo projects it could be enough. But for any serious application, spend 20$ more and buy an MLX90640.</p>
<h2>MLX90640 eloquent library</h2>
<p>As you may know if you read <a href="/2019/11/how-to-write-clean-arduino-code/">my previous posts</a>, I strongly believe in &quot;eloquent&quot; code, that is code that's as easy as possible to read.</p>
<p>How many lines do you think you need to read a MLX90640 camera? Well, not that much in fact.</p>
<pre><code class="language-cpp">#include &quot;EloquentMLX90640.h&quot;

using namespace Eloquent::Sensors;

float buffer[768];
MLX90640 camera;

void setup() {
  Serial.begin(115200);

  if (!camera.begin()) {
    Serial.println(&quot;Init error&quot;);
    delay(50000);
  }
}

void loop() {
  camera.read(buffer);
  delay(3000);
}</code></pre>
<p>If you skip the declaration lines, you only need a <code>begin()</code> and <code>read()</code> call.</p>
<p>That's it.</p>
<p>What <code>begin()</code> does is to run all of the boilerplate code I mentioned earlier (checking the connection and initializing the parameters).</p>
<p><code>read()</code> populates the buffer you pass as argument with the temperature readings.</p>
<p>From now on, you're free to handle that array as you may like: this is the most flexible way for the library to handle any use-case. It simply does not pose any restriction.</p>
<p>You can find the camera code <a href="#anchor-camera-code">at the end of the page</a> or <a href="https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/ThermalCameraToAsciiArtExample/EloquentMLX90640.h">on Github</a>.</p>
<h2>Printing as ASCII Art</h2>
<p>Now that you have this data, you may want to actually &quot;view&quot; it. Well, that's not an easy task as one may hope.</p>
<p>You will need an LCD if you want to create a standalone product. If you have one, it'll be the best, it's a really cute project to build.</p>
<p>Here's a video from Adafruit that showcases even a 3D-printed case.</p>
<p><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/ZjQEykbvb5w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<p>If you don't have an LCD, though, it is less practical to access your image.</p>
<p>I did this in the past, and it meant creating a Python script reading the serial port every second and updating a plot.<br />
It works, sure, but it's not the most convenient way to handle it.</p>
<p>This is the reason I thought about ASCII art: it is used to draw images in plain text, so you can view them directly in the serial monitor.</p>
<p>Of course they will not be as accurate or representative as RGB images, but can give you an idea of what you're framing in realtime.</p>
<p>I wrote a class to do this. Once imported in your sketch, it is super easy to get it working.</p>
<pre><code class="language-cpp">#include &quot;EloquentAsciiArt.h&quot;

using namespace Eloquent::ImageProcessing;

float buffer[768];
uint8_t bufferBytes[768];
MLX90640 camera;
// we need to specify width and height of the image
AsciiArt&lt;32, 24&gt; art(bufferBytes);

void loop() {
  camera.read(buffer);

  // convert float image to uint8
  for (size_t i = 0; i &lt; 768; i++) {
    // assumes readings are in the range 0-40 degrees
    // change as per your need
    bufferBytes[i] = map(buffer[i], 0, 40, 0, 255);
  }

  // print to Serial with a border of 2 characters, to distinguish one image from the next
  art.print(&amp;Serial, 2);
  delay(2000);
}</code></pre>
<p>As you can see, you need to create an <code>AsciiArt</code> object, map the image pixels in the range <code>0-255</code> and call the <code>print()</code> method: easy peasy!</p>
<p>You can find the ASCII art generator code <a href="#anchor-ascii-art-code">at the end of the page</a> or <a href="https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/ThermalCameraToAsciiArtExample/EloquentAsciiArt.h">on Github</a>.</p>
<p>Here's the result of the sketch. It's a video of me putting my arms at the top of my head, once at a time, then standing up.</p>
<div class="watchout">Resize the Serial Monitor as only a single frame at a time is visble to have a "video streaming" effect</div>
<div style="width: 342px;" class="wp-video"><!--[if lt IE 9]><script>document.createElement('video');</script><![endif]-->
<video class="wp-video-shortcode" id="video-956-1" width="342" height="636" preload="metadata" controls="controls"><source type="video/mp4" src="https://eloquentarduino.github.io/wp-content/uploads/2020/02/Thermal-ascii-speedup.mp4?_=1" /><a href="https://eloquentarduino.github.io/wp-content/uploads/2020/02/Thermal-ascii-speedup.mp4">https://eloquentarduino.github.io/wp-content/uploads/2020/02/Thermal-ascii-speedup.mp4</a></video></div>
<p>Of course the visual effect won't be as impressive as an RGB image, but you can clearly see my figure moving.</p>
<p>The real bad part is the &quot;glitch&quot; you see between each frame when the scrolling happens: this is something I don't know if it's possible to mitigate.</p>
<hr>
<p>Check the full project code on <a href="https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/ThermalCameraToAsciiArtExample" target="_blank" rel="noopener noreferrer">Github</a></p>
<hr />
<div id="anchor-camera-code"></div>
<pre><code class="language-cpp">#pragma once

#include &quot;Wire.h&quot;
#include &quot;MLX90640_API.h&quot;
#include &quot;MLX90640_I2C_Driver.h&quot;

#ifndef TA_SHIFT
//Default shift for MLX90640 in open air
#define TA_SHIFT 8
#endif

namespace Eloquent {
    namespace Sensors {

        enum class MLX90640Status {
            OK,
            NOT_CONNECTED,
            DUMP_ERROR,
            PARAMETER_ERROR,
            FRAME_ERROR
        };

        class MLX90640 {
        public:
            /**
             *
             * @param address
             */
            MLX90640(uint8_t address = 0x33) :
                _address(address),
                _status(MLX90640Status::OK) {

            }

            /**
             *
             * @return
             */
            bool begin() {
                Wire.begin();
                Wire.setClock(400000);

                return isConnected() &amp;&amp; loadParams();
            }

            /**
             *
             * @return
             */
            bool read(float result[768]) {
                for (byte x = 0 ; x &lt; 2 ; x++) {
                    uint16_t frame[834];
                    int status = MLX90640_GetFrameData(_address, frame);

                    if (status &lt; 0)
                        return fail(MLX90640Status::FRAME_ERROR);

                    float vdd = MLX90640_GetVdd(frame, &amp;_params);
                    float Ta = MLX90640_GetTa(frame, &amp;_params);
                    float tr = Ta - TA_SHIFT;
                    float emissivity = 0.95;

                    MLX90640_CalculateTo(frame, &amp;_params, emissivity, tr, result);
                }
            }

        protected:
            uint8_t _address;
            paramsMLX90640 _params;
            MLX90640Status _status;

            /**
             * Test if device is connected
             * @return
             */
            bool isConnected() {
                Wire.beginTransmission(_address);

                if (Wire.endTransmission() == 0) {
                    return true;
                }

                return fail(MLX90640Status::NOT_CONNECTED);
            }

            /**
             *
             * @return
             */
            bool loadParams() {
                uint16_t ee[832];
                int status = MLX90640_DumpEE(_address, ee);

                if (status != 0)
                    return fail(MLX90640Status::DUMP_ERROR);

                status = MLX90640_ExtractParameters(ee, &amp;_params);

                if (status != 0)
                    return fail(MLX90640Status::PARAMETER_ERROR);

                return true;
            }

            /**
             * Mark a failure
             * @param status
             * @return
             */
            bool fail(MLX90640Status status) {
                _status = status;

                return false;
            }
        };
    }
}</code></pre>
<div id="anchor-ascii-art-code"></div>
<pre><code class="language-cpp">#pragma once

#include &quot;Stream.h&quot;

namespace Eloquent {
    namespace ImageProcessing {

        /**
         *
         * @tparam width
         * @tparam height
         */
        template&lt;size_t width, size_t height&gt;
        class AsciiArt {
        public:
            AsciiArt(const uint8_t *data) {
                _data = data;
            }

            /**
             * Get pixel at given coordinates
             * @param x
             * @param y
             * @return
             */
            uint8_t at(size_t x, size_t y) {
                return _data[y * width + x];
            }

            /**
             * Print as ASCII art picture
             * @param stream
             */
            void print(Stream *stream, uint8_t frameSize = 0) {
                const char glyphs[] = &quot; .,:;xyYX&quot;;
                const uint8_t glyphsCount = 9;

                printAsciiArtHorizontalFrame(stream, frameSize);

                for (size_t y = 0; y &lt; height; y++) {
                    // vertical frame
                    for (uint8_t k = 0; k &lt; frameSize; k++)
                        Serial.print(&#039;|&#039;);

                    for (size_t x = 0; x &lt; width; x++) {
                        const uint8_t glyph = floor(((uint16_t) at(x, y)) * glyphsCount / 256);

                        stream-&gt;print(glyphs[glyph]);
                    }

                    // vertical frame
                    for (uint8_t k = 0; k &lt; frameSize; k++)
                        Serial.print(&#039;|&#039;);

                    stream-&gt;print(&#039;\n&#039;);
                }

                printAsciiArtHorizontalFrame(stream, frameSize);
                stream-&gt;flush();
            }

        protected:
            const uint8_t *_data;

            /**
             *
             * @param stream
             * @param frameSize
             */
            void printAsciiArtHorizontalFrame(Stream *stream, uint8_t frameSize) {
                for (uint8_t i = 0; i &lt; frameSize; i++) {
                    for (size_t j = 0; j &lt; width + 2 * frameSize; j++)
                        stream-&gt;print(&#039;-&#039;);
                    stream-&gt;print(&#039;\n&#039;);
                }
            }
        };
    }
}</code></pre>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2020/02/easy-arduino-thermal-camera-with-ascii-video-streaming/">Easy Arduino thermal camera with (ASCII) video streaming</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		<enclosure url="https://eloquentarduino.github.io/wp-content/uploads/2020/02/Thermal-ascii-speedup.mp4" length="479591" type="video/mp4" />

			</item>
		<item>
		<title>Eloquent pin management: the Pin class</title>
		<link>https://eloquentarduino.github.io/2019/12/arduino-pin-class/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Fri, 06 Dec 2019 16:15:13 +0000</pubDate>
				<category><![CDATA[Eloquent library]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=167</guid>

					<description><![CDATA[<p>Pin is a class for pin manipulation: you can read, write, turnOn, turnOff, toggle and a lot more. Please, stop writing horrible code like digitalWrite(led, HIGH) and start writing led.turnOn() instead. Pin is actually an abstract class, so you won't use it directly, but through its specialized implementations: DigitalIn DigitalOut AnalogIn AnalogOut Import the library [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/arduino-pin-class/">Eloquent pin management: the Pin class</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><code>Pin</code> is a class for pin manipulation: you can read, write, turnOn, turnOff, toggle and a lot more. Please, stop writing horrible code like <code>digitalWrite(led, HIGH)</code> and start writing <code>led.turnOn()</code> instead. </p>
<p><span id="more-167"></span></p>
<p><code>Pin</code> is actually an abstract class, so you won't use it directly, but through its specialized implementations:</p>
<ol>
<li>DigitalIn</li>
<li>DigitalOut</li>
<li>AnalogIn</li>
<li>AnalogOut</li>
</ol>
<h2>Import the library</h2>
<div class="watchout">To follow this tutorial along you need to first <a href="/2019/12/how-to-install-the-eloquent-library/" target="_blank" rel="noopener noreferrer">install the Eloquent library</a></div>
<pre><code class="language-cpp">#import &lt;eIO.h&gt;

using namespace Eloquent::Pin;</code></pre>
<p>If the namespace stuff is new to you, here I'll briefly say that it is used to avoid name collisions among different libraries. This seems to be an alien topic in the Arduino world and I can't really explain why.</p>
<p>99% of the libraries out there deal with this problem in one of two modes:</p>
<ol>
<li>ignoring it altogether, so you have an <code>MPU6050.h</code> library, which elects itself as the only one implementation possible to access the MPU6050 accelerometer in the world</li>
<li>prefixing each library file, so you get the <code>Adafruit_Si7021</code> class</li>
</ol>
<hr /><p><em>The case for Adafruit_Si7021 should not exist in my opinion: use the damn namespaces!</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Farduino-pin-class%2F&#038;text=The%20case%20for%20Adafruit_Si7021%20should%20not%20exist%20in%20my%20opinion%3A%20use%20the%20damn%20namespaces%21&#038;via=EloquentArduino&#038;related=EloquentArduino' target='_blank' rel="noopener noreferrer" >Click To Tweet</a><br /><hr />
<p>With namespaces, it would become:</p>
<pre><code class="language-cpp">using namespace Adafruit;

Si7021 si;</code></pre>
<h2>How to use</h2>
<p>First of all, all the 4 implementations accept a single constructor argument: the pin number.</p>
<pre><code class="language-cpp"> DigitalOut led(BUILTIN_LED);
 DigitalIn pushButton(10);
 AnalogIn potentiometer(A0);
 AnalogOut pwmLed(8);</code></pre>
<p>Then it is good practice to init your pins in the setup.</p>
<pre><code class="language-cpp"> void setup() {
    led.begin();
    pushButton.begin();
    potentiometer.begin();
    pwmLed.begin();
 }</code></pre>
<p>All the 4 classes let you ask for the pin current value via the <code>value()</code> method:</p>
<pre><code class="language-cpp"> void test() {
    // DigitalIn returns the last read value, as 0/1
    digitalIn.value();

    // AnalogIn returns the last read value, in the range [0, 1024]
    analogIn.value();

    // DigitalOut returns the last written value, as 0/1
    digitalOut.value();

    // AnaloglOut returns the last written value, in the range [0, 255]
    analogOut.value();
 }</code></pre>
<p>At this point each class will provide its specialized methods.</p>
<h4>DigitalIn</h4>
<pre><code class="language-cpp">void test() {
    // configure pin as INPUT_PULLUP
    pin.pullup();

    // configure pin as Active Low 
    // that is, pin is ON when digitalRead() is LOW
    pin.activeLow();

    // read and update pin value
    pin.read();

    // test if pin is on (doesn&#039;t read the pin)
    pin.isOn();

    // test if pin is off (doesn&#039;t read the pin)
    pin.isOff();

    // test if pin value changed from last reading
    pin.changed();
}</code></pre>
<h4>DigitalOut</h4>
<pre><code class="language-cpp">void test() {
    // set pin as Active Low
    // that is, turnOn writes LOW
    pin.activeLow();

    // turn pin on
    pin.turnOn();

    // turn pin off
    pin.turnOff();

    // toggle
    pin.toggle();

    // blink N times at intervals of X milliseconds
    pin.blink(N, X);
}</code></pre>
<h4>AnalogIn</h4>
<pre><code class="language-cpp">void test() {
    // read current pin value
    pin.read();

    // get pin previous value
    pin.prev();

    // get difference between current value and previous
    pin.delta();

    // get absolute value of delta()
    pin.absDelta();
}</code></pre>
<h4>AnalogOut</h4>
<pre><code class="language-cpp">void test() {
    // write value X to pin
    pin.write(X);
}</code></pre>
<hr />
<p>If you don't believe a whole class is worthwhile to work with pins, I'll show a few use cases to illustrate my point.</p>
<h4>Use case #1: active low LED</h4>
<p>The ESP8266 has a builtin LED you can control, but it is an <em>active low</em> one: it will turn on when you write <code>LOW</code>. In this case, <code>digitalWrite(BUILTIN_LED, LOW)</code> can be misleading regarding your actual intentions. </p>
<p>It doesn't look intuitive,  it doesn't look <em>eloquent</em>! <code>builtinLed.turnOn()</code> does, however. All you need to get it working correctly is calling <code>builtinLed.activeLow()</code> once in your setup.</p>
<pre><code class="language-cpp">// BEFORE
void loop() {
    // to turn the builtin LED on
    digitalWrite(led, LOW);
}</code></pre>
<pre><code class="language-cpp">// AFTER
DigitalOut buildtinLed;

void setup() {
    builtinLed.activeLow();
}

void loop() {
    // to turn the builtin LED on
    builtinLed.turnOn();
}</code></pre>
<h4>Use case #2: toggle</h4>
<p>If you need to toggle the current state of a digital output, you need an helper variable to keep track of the state and remember to <strong>always</strong> update that variable when you write to the output.<br />
With a class, the state is tightly bound to the instance, so you have a <a href="https://en.wikipedia.org/wiki/Single_source_of_truth">single source of truth</a>: <code>turnOn()</code>, <code>turnOff()</code> and <code>toggle()</code> will take care of updating the inner state accordingly.</p>
<pre><code class="language-cpp">// BEFORE
#define LED 1

bool ledState = true;

loop() {
    digitalWrite(LED, ledState);
    ledState = !ledState
}</code></pre>
<pre><code class="language-cpp">// AFTER
DigitalOut led(1);

void loop() {
    led.toggle();
}</code></pre>
<h4>Use case #3: analog delta</h4>
<p>What if you have an analog input and want to know if its valued changed by at least X from your latest reading? You would need an helper variable again. </p>
<p>Now imagine if you have 5 analog inputs you want to track: you'll end up with 10 variables and of course you have again to <strong>always</strong> keep both in sync.<br />
<code>AnalogIn</code> conveniently provides <code>delta()</code> and <code>absDelta()</code> methods that give you the change from the previous reading and will always be in sync. Awesome!</p>
<pre><code class="language-cpp">// BEFORE
#define INPUT1 A1
#define INPUT2 A2

uint16_t current1, prev1;
uint16_t current2, prev2;

void loop() {
    prev1 = current1;
    current1 = analogRead(INPUT1);
    prev2 = current2;
    current2 = analogRead(INPUT2);

    if (abs(current1 - prev1) &gt; THRESHOLD)
        ...</code></pre>
<pre><code class="language-cpp">// AFTER
AnalogIn input1(A1), input2(A2);

void loop() {
    input1.read();
    input2.read();

    if (input1.absDelta() &gt; THRESHOLD)
        ...
}</code></pre>
<br><p>Did you find this tutorial useful? Was is it easy to follow or did I miss something? Let me know in the comments so I can keep improving the blog.</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/arduino-pin-class/">Eloquent pin management: the Pin class</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Eloquent bounded waiting: the await construct</title>
		<link>https://eloquentarduino.github.io/2019/12/arduino-bounded-waiting/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Thu, 05 Dec 2019 18:50:59 +0000</pubDate>
				<category><![CDATA[Eloquent library]]></category>
		<category><![CDATA[eloquent]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=211</guid>

					<description><![CDATA[<p>Sometimes you may need to wait for a certain condition to become true, but you don't want to wait forever: it may be awaiting for Serial, for the Wifi to connect to a network, or the response from a SoftwareSerial peripheral. The await construct lets you put an upper bound to the time you're willing [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/arduino-bounded-waiting/">Eloquent bounded waiting: the await construct</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Sometimes you may need to wait for a certain condition to become true, but you don't want to wait forever: it may be awaiting for Serial, for the Wifi to connect to a network, or the response from a SoftwareSerial peripheral. The <code>await</code> construct lets you put an upper bound to the time you're willing to wait.</p>
<p><span id="more-211"></span></p>
<p>Most often, you see example code of this kind:</p>
<pre><code class="language-cpp">Serial.print(&quot;Attempting to connect to WiFi&quot;);

while (WiFi.status() != WL_CONNECTED) {
    Serial.print(&quot;.&quot;);
    delay(500);
}</code></pre>
<p>If the connection doesn't succeed (maybe the AP is out of range or is down), you're stuck in an endless wait. A proper way for handling such situations is with a timeout that gets you out of the loop with an error status so you can handle the failure.<br />
<code>await</code> is exactly this: a construct to await for a condition to become true until a timeout expires, returning true or false as a response.</p>
<h3>Definition</h3>
<pre><code class="language-cpp">#define await(condition, timeout) await_with_interval(condition, timeout, 10)
#define await_with_interval(condition, timeout, interval) \
  ([]() { \
    uint32_t start = millis(); \
    while (millis() - start &lt;= timeout) { \
      if (condition) return true; \
      delay(interval); \
    } \
  return false; })()</code></pre>
<h3>How to use</h3>
<p><code>await</code> needs at least two arguments:</p>
<ol>
<li>the condition to await for</li>
<li>the timeout, in milliseconds</li>
</ol>
<pre><code>// these are for greater code readability
#define Millis 
#define Second  *1000
#define Seconds *1000
</code></pre>
<pre><code class="language-cpp">bool wifiConnected = await(WiFi.status() == WL_CONNECTED, 10 Seconds)</code></pre>
<p>The code above will wait 10 seconds for the wifi to connect: on failure, <code>wifiConnected</code> will be false and you can gently fail. </p>
<p>You can use it for any kind of check, like waiting for <code>Serial</code>.</p>
<pre><code class="language-cpp">bool serialReady = await(Serial, 5 Seconds)
bool serialHasCharacters = await(Serial.available(), 5 Seconds)</code></pre>
<p>The default interval between checks is 10 milliseconds: if you need a custom delay interval you can use the more verbose <code>await_with_interval</code>:</p>
<pre><code class="language-cpp">// await WiFi for 10 seconds, check if connected every 500 millis
bool wifiConnected = await_with_interval(WiFi.status() == WL_CONNECTED, 10 Seconds, 500 Millis)</code></pre>
<h3>How it works</h3>
<p>The <code>await</code> macro creates an <a href="http://www.cplusplus.com/articles/2LywvCM9/">inline function</a> that loops until the timeout expires. At every loop it checks if the condition is true: if that's the case, it returns true. The inline function construct is needed to get a return value, so you can assign it to a variable or embed directly inside an <code>if</code> test. The following code sample gives you an idea of what's happening.</p>
<pre><code class="language-cpp">bool wifiConnected = await(WiFi.status() == WL_CONNECTED, 10 Seconds)

// conceptually translates to

bool inline_function() {
    uint32_t start = millis();

    while (millis() - start &lt;= 10000) {
      if (WiFi.status() == WL_CONNECTED)
        return true;

      delay(10);
    }

   return false;
}

bool wifiConnected = inline_function();</code></pre>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/arduino-bounded-waiting/">Eloquent bounded waiting: the await construct</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Eloquent non-blocking code: the Every construct</title>
		<link>https://eloquentarduino.github.io/2019/12/non-blocking-arduino-code/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Thu, 05 Dec 2019 18:42:45 +0000</pubDate>
				<category><![CDATA[Eloquent library]]></category>
		<category><![CDATA[eloquent]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=209</guid>

					<description><![CDATA[<p>The every construct lets you run a piace of code at regular intervals in a fluent way. If you don't need to start, stop, pause your timer, this construct is a valid alternative to more complex timer libraries already available: it only takes a time interval as argument and will execute the code block periodically. [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/non-blocking-arduino-code/">Eloquent non-blocking code: the Every construct</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <code>every</code> construct lets you run a piace of code at regular intervals in a fluent way. If you don't need to start, stop, pause your timer, this construct is a valid alternative to more complex timer libraries already available: it only takes a time interval as argument and will execute the code block periodically.</p>
<p><span id="more-209"></span></p>
<h3>Definition</h3>
<pre><code class="language-cpp">#define every(interval) \
    static uint32_t __every__##interval = millis(); \
    if (millis() - __every__##interval &gt;= interval &amp;&amp; (__every__##interval = millis()))</code></pre>
<h3>How to use</h3>
<pre><code>// these are for greater code readability
#define Millis 
#define Second  *1000
#define Seconds *1000
</code></pre>
<pre><code class="language-cpp">int interval = 1 Second;

void setup() {
    Serial.begin(115200);
}

void loop() {
    every(1000 Millis) {
        Serial.println(&quot;This line is printed every 1 second&quot;);
    }

    every(2000 Millis) {
        Serial.println(&quot;This line is printed every 2 seconds&quot;);
    }

    every(interval) {
        interval += 1 Second;
        Serial.print(&quot;You can have variable intervals too! &quot;);
        Serial.print(&quot;This line will be printed again in &quot;);
        Serial.print(interval / 1000);
        Serial.println(&quot; seconds&quot;);
    }
}</code></pre>
<h3>Caveats</h3>
<p><code>every</code> is just a macro definition and is not a proper timer, so it has some limitations:</p>
<ol>
<li>you can't stop, pause or resume it: once set, it will run forever</li>
<li>its argument must be the suffix of a valid identifier</li>
<li>you can't use several <code>every</code> with the exact same argument: you have to put all the code that needs to happen at the same interval in the same block</li>
</ol>
<h4>Caveat #2</h4>
<p>The macro works by generating a variable named like <code>__every__##argument</code></p>
<pre><code class="language-cpp">every(1) ==&gt; uint32_t __every__1;
every(2) ==&gt; uint32_t __every__2;
every(a_given_interval) ==&gt; uint32_t __every__a_given_interval;
every(an invalid interval) ==&gt; uint32_t __every__an invalid interval; // Syntax error
every(1 Second) ==&gt; uint32_t __every__1 *1000; // Syntax error</code></pre>
<p>So every integer literal and any variable are all valid arguments. Any expression is forbidden.</p>
<h4>Caveat #3</h4>
<p>If you use two <code>every</code> with the exact same argument, two variables with the exact same name will be created and it will rise a compile-time error.</p>
<p>If you can live with this limitations, <code>every</code> only needs the space of an <code>uint32_t</code> to work.</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/non-blocking-arduino-code/">Eloquent non-blocking code: the Every construct</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>How to install the Eloquent library</title>
		<link>https://eloquentarduino.github.io/2019/12/how-to-install-the-eloquent-library/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Thu, 05 Dec 2019 16:18:48 +0000</pubDate>
				<category><![CDATA[Eloquent library]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=554</guid>

					<description><![CDATA[<p>In this short tutorial I'll show you how you can install the Eloquent library to take advange of all the good things it provides to you. It really is super simple, since the Eloquent library is no different from any other library you already installed on your computer, but I'll repeat the steps for clarity. [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/how-to-install-the-eloquent-library/">How to install the Eloquent library</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In this short tutorial I'll show you how you can install the <a href="/2019/11/how-to-write-clean-arduino-code-introducing-the-eloquent-library/">Eloquent library</a> to take advange of all the good things it provides to you.</p>
<p>It really is super simple, since the Eloquent library is no different from any other library you already installed on your computer, but I'll repeat the steps for clarity.</p>
<p><span id="more-554"></span></p>
<h2>1. Download the zip from Github</h2>
<p>The whole library is hosted on Github, so head over to <a href="https://github.com/eloquentarduino/EloquentArduino">the repo</a> and click <em>Clone or download</em> &gt; <em>Download ZIP</em>.</p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Repo.png" alt="Download zip from Github repository" /></p>
<h2>2. Extract the zip to you library directory</h2>
<p>Once downloaded, you should extract the zip into your Arduino libraries folder. The path will vary based on your OS and installation, but I expect you to know where it is.</p>
<h2>3. Strip the -master suffix</h2>
<p>When downloaded from Github, your zip and your folder will be named <code>EloquentArduino-master</code>: rename the folder to just <code>EloquentArduino</code>, without the master suffix.</p>
<h2>4. Done</h2>
<p>If you follwed the steps correctly, the library is ready to be used.</p>
<br><p>Did you find this tutorial useful? Was is it easy to follow or did I miss something? Let me know in the comments so I can keep improving the blog.</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/12/how-to-install-the-eloquent-library/">How to install the Eloquent library</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>How to write clean Arduino code: introducing the Eloquent library</title>
		<link>https://eloquentarduino.github.io/2019/11/how-to-write-clean-arduino-code/</link>
		
		<dc:creator><![CDATA[simone]]></dc:creator>
		<pubDate>Sun, 03 Nov 2019 16:05:46 +0000</pubDate>
				<category><![CDATA[Eloquent library]]></category>
		<category><![CDATA[eloquent]]></category>
		<guid isPermaLink="false">https://eloquentarduino.github.io/?p=164</guid>

					<description><![CDATA[<p>Eloquent Arduino is an attempt to bring sanity and clarity in Arduino projects. The purpose of this library is to create a wide range of constructs to clearly translate your ideas into meaningful code: stop writing spaghetti code only you can undestand, please! I'll show you how. The problem Arduino sells itself as a platform well [&#8230;]</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/11/how-to-write-clean-arduino-code/">How to write clean Arduino code: introducing the Eloquent library</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Eloquent Arduino is an attempt to bring sanity and clarity in Arduino projects. The purpose of this library is to create a wide range of constructs to clearly translate your ideas into meaningful code: <strong>stop writing spaghetti code</strong>  only you can undestand, please! I'll show you how.</p>
<p><span id="more-164"></span></p>
<p><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/11/CleanCode.jpg" alt="from https://www.wlion.com/blog/5-reasons-you-should-be-writing-clean-code/" /></p>
<h2>The problem</h2>
<p>Arduino sells itself as a platform well suited for beginners, and it is for sure; lots of non-tech people are able to bring their ideas to life thanks to this awesome platform.<br />
Nevertheless, I often stumble upon bits of code over the internet that make me question about the quality of the projects people are producing. </p>
<p>Even the Arduino official website is misleading in this sense, in my opinion, since it promotes a code style really straighforward, but suited for toy projects, with little logics and low complexity level.</p>
<p>Here's an example of what I'm talking about, copy-pasted from the <a href="https://www.arduino.cc/en/tutorial/BlinkWithoutDelay">Arduino official site</a> (with comments removed):</p>
<pre><code class="language-cpp">const int ledPin =  LED_BUILTIN;
int ledState = LOW;
unsigned long previousMillis = 0; 
const long interval = 1000; 

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  unsigned long currentMillis = millis();

  if (currentMillis - previousMillis &gt;= interval) {
    previousMillis = currentMillis;

    if (ledState == LOW) {
      ledState = HIGH;
    } else {
      ledState = LOW;
    }

    digitalWrite(ledPin, ledState);
  }
}</code></pre>
<p>Can you tell what this code does <strong>with a minimum mental effort</strong>?<br />
I don't think so (you may have recognized the <em>async pattern</em> and it actually blinks a LED in a non-blocking fashion).</p>
<p><strong>THIS</strong> is the problem: most Arduino code is not clear at first glance, is not <strong>eloquent</strong>. By eloquent I mean code that speaks by itself, without the need for comments.</p>
<hr /><p><em>most Arduino code is not clear at first glance, is not eloquent</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F11%2Fhow-to-write-clean-arduino-code%2F&#038;text=most%20Arduino%20code%20is%20not%20clear%20at%20first%20glance%2C%20is%20not%20eloquent&#038;via=EloquentArduino&#038;related=EloquentArduino' target='_blank' rel="noopener noreferrer" >Click To Tweet</a><br /><hr />
<h2>The solution</h2>
<p>What about the following?</p>
<pre><code class="language-cpp">DigitalOut led(LED_BUILTIN);

void setup() {
    led.begin();
}

void loop() {
    every(1 Second) {
        led.toggle();
    }
}</code></pre>
<p>I swear this is valid code that compiles just fine. Hopefully, it does the exact same thing as above, yet it is far more readable and understandable. </p>
<p>Can you see my point now? Wouldn't it be much easier and reliable to code with the help of a set of such eloquent constructs / interfaces? I strongly believe it is, and this is why I'm writing this library.<br />
Asynchronous programming, pin state managements, animations are bits of code that pop up over and over again in most of the projects, yet every time we start from zero and write the same boilerplate code over and over again.</p>
<hr /><p><em>Boilerplate code is not only tedious, but error-prone. And lengthy. Start writing eloquent code now!</em><br /><a href='https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F11%2Fhow-to-write-clean-arduino-code%2F&#038;text=Boilerplate%20code%20is%20not%20only%20tedious%2C%20but%20error-prone.%20And%20lengthy.%20Start%20writing%20eloquent%20code%20now%21&#038;via=EloquentArduino&#038;related=EloquentArduino' target='_blank' rel="noopener noreferrer" >Click To Tweet</a><br /><hr />
<p>Boilerplate code heavily relies on a fixed structure that could be hard to adapt to your specific case. Longer code means more chances to break something and more code to debug, which can waste lots of your valuable time.</p>
<hr />
<p>I'm starting a series of posts where I'll document some of the classes and constructs the library provides to you. You can find the code on the <a href="https://github.com/eloquentarduino/EloquentArduino">Github repo</a>.</p>
<p>L'articolo <a rel="nofollow" href="https://eloquentarduino.github.io/2019/11/how-to-write-clean-arduino-code/">How to write clean Arduino code: introducing the Eloquent library</a> proviene da <a rel="nofollow" href="http://eloquentarduino.github.io/">Eloquent Arduino Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
