{
    "version": "https://jsonfeed.org/version/1.1",
    "user_comment": "This feed allows you to read the posts from this site in any feed reader that supports the JSON Feed format. To add this feed to your reader, copy the following URL -- https://eloquentarduino.github.io/category/programming/feed/json/ -- and add it your reader.",
    "home_page_url": "https://eloquentarduino.github.io/category/programming/",
    "feed_url": "https://eloquentarduino.github.io/category/programming/feed/json/",
    "language": "en-US",
    "title": "Programming &#8211; Eloquent Arduino Blog",
    "description": "Machine learning on Arduino, programming &amp; electronics",
    "items": [
        {
            "id": "https://eloquentarduino.github.io/?p=1174",
            "url": "https://eloquentarduino.github.io/2020/06/arduino-dimensionality-reduction-pca-for-machine-learning-projects/",
            "title": "Arduino dimensionality reduction (PCA) for Machine Learning projects",
            "content_html": "<p>When working with <strong>Machine Learning projects</strong> on microcontrollers and embedded devices the dimension of features can become a limiting factor due to the lack of RAM: <strong>dimensionality reduction</strong> (eg. PCA) will help you shrink your models and even achieve higher prediction accuracy.</p>\n<p><a href=\"https://setosa.io/ev/principal-component-analysis\"><img src=\"https://setosa.io/ev/principal-component-analysis/fb-thumb.png\" alt=\"PCA application example\" /></a></p>\n<p><span id=\"more-1174\"></span></p>\n<h2>Why dimensionality reduction on Arduino microcontrollers?</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Dimensionality_reduction\">Dimensionality reduction</a> is a tecnique you see often in Machine Learning projects. By stripping away &quot;unimportant&quot; or redundant information, it generally helps speeding up the training process and achieving higher classification performances.</p>\n<p>Since we now know we can run Machine Learning on Arduino boards and embedded microcontrollers, it can become a key tool at our disposal to squeeze out the most out of our boards.</p>\n<p>In the specific case of resource-constrained devices as old Arduino boards (the UNO for example, with only 2 kb of RAM), it can become a decisive turn in unlocking even more application scenarios where the high dimensionality of the input features would not allow any model to fit.</p>\n<p>Let's take the <a href=\"/2019/12/how-to-do-gesture-identification-on-arduino/\">Gesture classification project</a> as an example: among the different classifiers we trained, only one fitted on the Arduino UNO, since most of them required too much flash memory due to the high dimension of features (90) and support vectors (25 to 61).</p>\n<p>In this post I will resume that example and see if dimensionality reduction can help reduce this gap.</p>\n<p>If you are working on a project with many features, let me know in the comments so I can create a detailed list of real world examples.</p>\n<h2>How to export PCA (Principal Component Analysis) to plain C</h2>\n<p>Among the many algorithms available for dimensionality reduction, I decided to start with <a href=\"https://en.wikipedia.org/wiki/Principal_component_analysis\">PCA (Principal Component Analysis)</a> because it's one of the most widespread. In the next weeks I will probably work on porting other alternatives.</p>\n<p>If you never used my Python package <a href=\"https://github.com/eloquentarduino/micromlgen\">micromlgen</a> I first invite you to read <a href=\"/2019/11/you-can-run-machine-learning-on-arduino/\">the introduction post</a> to get familiar with it.</p>\n<p>Always remember to install the latest version, since I publish frequent updates.</p>\n<pre><code class=\"language-bash\">pip install --upgrade micromlgen</code></pre>\n<p>Now it is pretty straight-forward to convert a sklearn PCA transformer to plain C: you use the magic method <code>port</code>. In addition to converting SVM/RVM classifiers, it is now able to export PCA too.</p>\n<pre><code class=\"language-python\">from sklearn.decomposition import PCA\nfrom sklearn.datasets import load_iris\nfrom micromlgen import port\n\nif __name__ == &#039;__main__&#039;:\n    X = load_iris().data\n    pca = PCA(n_components=2, whiten=False).fit(X)\n\n    print(port(pca))</code></pre>\n<h2>How to deploy PCA to Arduino</h2>\n<p>To use the exported code, we first have to include it in our sketch. Save the contents to a file (I named it <code>pca.h</code>) in the same folder of your <code>.ino</code> project and include it.</p>\n<pre><code class=\"language-cpp\">#include &quot;pca.h&quot;\n\n// this was trained on the IRIS dataset, with 2 principal components\nEloquent::ML::Port::PCA pca;</code></pre>\n<p>The <code>pca</code> object is now able to take an array of size N as input and return an array of size K as output, with K &lt; N usually.</p>\n<pre><code class=\"language-cpp\">void setup() {\n    float x_input[4] = {5.1, 3.5, 1.4, 0.2};\n    float x_output[2];\n\n    pca.transform(x_input, x_output);\n}</code></pre>\n<p>That's it: now you can run your classifier on <code>x_output</code>.</p>\n<pre><code class=\"language-cpp\">#include &quot;pca.h&quot;\n#include &quot;svm.h&quot;\n\nEloquent::ML::Port::PCA pca;\nEloquent::ML::Port::SVM clf;\n\nvoid setup() {\n    float x_input[4] = {5.1, 3.5, 1.4, 0.2};\n    float x_output[2];\n    int y_pred;\n\n    pca.transform(x_input, x_output);\n\n    y_pred = clf.predict(x_output);\n}</code></pre>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2>A real world example</h2>\n<p>As I anticipated, let's take a look at how PCA dimensionality reduction can help in fitting classifiers that would otherwise be too large to fit on our microcontrollers.</p>\n<p>This is the exact table from the <a href=\"/2019/12/how-to-do-gesture-identification-on-arduino/\">Gesture classification project</a>.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">Kernel</th>\n<th style=\"text-align: center;\">C</th>\n<th style=\"text-align: center;\">Gamma</th>\n<th style=\"text-align: center;\">Degree</th>\n<th style=\"text-align: center;\">Vectors</th>\n<th style=\"text-align: center;\">Flash size</th>\n<th style=\"text-align: center;\">RAM (b)</th>\n<th style=\"text-align: center;\">Avg accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">RBF</td>\n<td style=\"text-align: center;\">10</td>\n<td style=\"text-align: center;\">0.001</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">37</td>\n<td style=\"text-align: center;\">53 Kb</td>\n<td style=\"text-align: center;\">1228</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Poly</strong></td>\n<td style=\"text-align: center;\"><strong>100</strong></td>\n<td style=\"text-align: center;\"><strong>0.001</strong></td>\n<td style=\"text-align: center;\"><strong>2</strong></td>\n<td style=\"text-align: center;\"><strong>12</strong></td>\n<td style=\"text-align: center;\"><strong>25 Kb</strong></td>\n<td style=\"text-align: center;\"><strong>1228</strong></td>\n<td style=\"text-align: center;\"><strong>99%</strong></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Poly</td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: center;\">0.001</td>\n<td style=\"text-align: center;\">3</td>\n<td style=\"text-align: center;\">25</td>\n<td style=\"text-align: center;\">40 Kb</td>\n<td style=\"text-align: center;\">1228</td>\n<td style=\"text-align: center;\">97%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">Linear</td>\n<td style=\"text-align: center;\">50</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">1</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: center;\">55 Kb</td>\n<td style=\"text-align: center;\">1228</td>\n<td style=\"text-align: center;\">95%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">RBF</td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: center;\">0.01</td>\n<td style=\"text-align: center;\">-</td>\n<td style=\"text-align: center;\">61</td>\n<td style=\"text-align: center;\">80 Kb</td>\n<td style=\"text-align: center;\">1228</td>\n<td style=\"text-align: center;\">95%</td>\n</tr>\n</tbody>\n</table>\n<p>The dataset has 90 features (30 samples x 3 axes) and achieves 99% accuracy. </p>\n<p>Let's pick the <code>poly</code> kernel with degree <code>2</code> and see how much we can decrease the number of components while still achieving a good accuracy.</p>\n<table>\n<thead>\n<tr>\n<th>PCA components</th>\n<th style=\"text-align: center;\">Accuracy</th>\n<th style=\"text-align: center;\">Support vectors</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>90</td>\n<td style=\"text-align: center;\">99%</td>\n<td style=\"text-align: center;\">31</td>\n</tr>\n<tr>\n<td>50</td>\n<td style=\"text-align: center;\">99%</td>\n<td style=\"text-align: center;\">31</td>\n</tr>\n<tr>\n<td>40</td>\n<td style=\"text-align: center;\">99%</td>\n<td style=\"text-align: center;\">31</td>\n</tr>\n<tr>\n<td>30</td>\n<td style=\"text-align: center;\">90%</td>\n<td style=\"text-align: center;\">30</td>\n</tr>\n<tr>\n<td>20</td>\n<td style=\"text-align: center;\">90%</td>\n<td style=\"text-align: center;\">28</td>\n</tr>\n<tr>\n<td>15</td>\n<td style=\"text-align: center;\">90%</td>\n<td style=\"text-align: center;\">24</td>\n</tr>\n<tr>\n<td><strong>10</strong></td>\n<td style=\"text-align: center;\"><strong>99%</strong></td>\n<td style=\"text-align: center;\"><strong>18</strong></td>\n</tr>\n<tr>\n<td>5</td>\n<td style=\"text-align: center;\">76%</td>\n<td style=\"text-align: center;\">28</td>\n</tr>\n</tbody>\n</table>\n<p>We clearly see a couple of things:</p>\n<ol>\n<li>we still achieve 99% accuracy even with only 40 out of 90 principal components</li>\n<li>we get a satisfactory 90% accuracy even <strong>with only 15 components</strong></li>\n<li>(this is a bit unexpected) it looks like there's a sweet spot at 10 components where the accuracy skyrockets to 99% again. <em>This could be just a contingency of this particular dataset, don't expect to replicate this results on your own dataset</em></li>\n</ol>\n<p>What do these numbers mean to you? It means your board has to do many less computations to give you a prediction and will probably be able to host a more complex model.</p>\n<p>Let's check out the figures with <code>n_components = 10</code> compared with the ones without PCA.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">Kernel</th>\n<th style=\"text-align: center;\">PCA support vectors</th>\n<th style=\"text-align: center;\">PCA flash size</th>\n<th style=\"text-align: center;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">RBF C=10</td>\n<td style=\"text-align: center;\">46 (+24%)</td>\n<td style=\"text-align: center;\">32 Kb (-40%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">RBF C=100</td>\n<td style=\"text-align: center;\">28 (-54%)</td>\n<td style=\"text-align: center;\">32 Kb (-60%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Poly 2</strong></td>\n<td style=\"text-align: center;\">13 (-48%)</td>\n<td style=\"text-align: center;\">28 Kb (+12%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Poly 3</strong></td>\n<td style=\"text-align: center;\">24 (-4%)</td>\n<td style=\"text-align: center;\">32 Kb (-20%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><strong>Linear</strong></td>\n<td style=\"text-align: center;\">18 (-64%)</td>\n<td style=\"text-align: center;\">29 Kb (-47%)</td>\n<td style=\"text-align: center;\">99%</td>\n</tr>\n</tbody>\n</table>\n<p>A couple notes:</p>\n<ol>\n<li>accuracy increased (on stayed the same) for all kernels</li>\n<li>with one exception, flash size decreased in the range 20 - 50%</li>\n<li>now we can fit 3 classifiers on our Arduino UNO instead of only one</li>\n</ol>\n<p>I will probably spend some more time investingating the usefulness of PCA for Arduino Machine Learning projects, but for now that's it: it's a good starting point in my opinion.</p>\n<hr />\n<p>There's a little example sketch on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PCAExample/PCAExample.ino\">Github</a> that applies PCA to the IRIS dataset.</p>\n<p>Tell me what you think may be a clever application of dimensionality reduction in the world of microcontrollers and see if we can build something great together.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/06/arduino-dimensionality-reduction-pca-for-machine-learning-projects/\">Arduino dimensionality reduction (PCA) for Machine Learning projects</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "When working with Machine Learning projects on microcontrollers and embedded devices the dimension of features can become a limiting factor due to the lack of RAM: dimensionality reduction (eg. PCA) will help you shrink your models and even achieve higher prediction accuracy.\n\n\nWhy dimensionality reduction on Arduino microcontrollers?\nDimensionality reduction is a tecnique you see often in Machine Learning projects. By stripping away &quot;unimportant&quot; or redundant information, it generally helps speeding up the training process and achieving higher classification performances.\nSince we now know we can run Machine Learning on Arduino boards and embedded microcontrollers, it can become a key tool at our disposal to squeeze out the most out of our boards.\nIn the specific case of resource-constrained devices as old Arduino boards (the UNO for example, with only 2 kb of RAM), it can become a decisive turn in unlocking even more application scenarios where the high dimensionality of the input features would not allow any model to fit.\nLet's take the Gesture classification project as an example: among the different classifiers we trained, only one fitted on the Arduino UNO, since most of them required too much flash memory due to the high dimension of features (90) and support vectors (25 to 61).\nIn this post I will resume that example and see if dimensionality reduction can help reduce this gap.\nIf you are working on a project with many features, let me know in the comments so I can create a detailed list of real world examples.\nHow to export PCA (Principal Component Analysis) to plain C\nAmong the many algorithms available for dimensionality reduction, I decided to start with PCA (Principal Component Analysis) because it's one of the most widespread. In the next weeks I will probably work on porting other alternatives.\nIf you never used my Python package micromlgen I first invite you to read the introduction post to get familiar with it.\nAlways remember to install the latest version, since I publish frequent updates.\npip install --upgrade micromlgen\nNow it is pretty straight-forward to convert a sklearn PCA transformer to plain C: you use the magic method port. In addition to converting SVM/RVM classifiers, it is now able to export PCA too.\nfrom sklearn.decomposition import PCA\nfrom sklearn.datasets import load_iris\nfrom micromlgen import port\n\nif __name__ == &#039;__main__&#039;:\n    X = load_iris().data\n    pca = PCA(n_components=2, whiten=False).fit(X)\n\n    print(port(pca))\nHow to deploy PCA to Arduino\nTo use the exported code, we first have to include it in our sketch. Save the contents to a file (I named it pca.h) in the same folder of your .ino project and include it.\n#include &quot;pca.h&quot;\n\n// this was trained on the IRIS dataset, with 2 principal components\nEloquent::ML::Port::PCA pca;\nThe pca object is now able to take an array of size N as input and return an array of size K as output, with K &lt; N usually.\nvoid setup() {\n    float x_input[4] = {5.1, 3.5, 1.4, 0.2};\n    float x_output[2];\n\n    pca.transform(x_input, x_output);\n}\nThat's it: now you can run your classifier on x_output.\n#include &quot;pca.h&quot;\n#include &quot;svm.h&quot;\n\nEloquent::ML::Port::PCA pca;\nEloquent::ML::Port::SVM clf;\n\nvoid setup() {\n    float x_input[4] = {5.1, 3.5, 1.4, 0.2};\n    float x_output[2];\n    int y_pred;\n\n    pca.transform(x_input, x_output);\n\n    y_pred = clf.predict(x_output);\n}\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nA real world example\nAs I anticipated, let's take a look at how PCA dimensionality reduction can help in fitting classifiers that would otherwise be too large to fit on our microcontrollers.\nThis is the exact table from the Gesture classification project.\n\n\n\nKernel\nC\nGamma\nDegree\nVectors\nFlash size\nRAM (b)\nAvg accuracy\n\n\n\n\nRBF\n10\n0.001\n-\n37\n53 Kb\n1228\n99%\n\n\nPoly\n100\n0.001\n2\n12\n25 Kb\n1228\n99%\n\n\nPoly\n100\n0.001\n3\n25\n40 Kb\n1228\n97%\n\n\nLinear\n50\n-\n1\n40\n55 Kb\n1228\n95%\n\n\nRBF\n100\n0.01\n-\n61\n80 Kb\n1228\n95%\n\n\n\nThe dataset has 90 features (30 samples x 3 axes) and achieves 99% accuracy. \nLet's pick the poly kernel with degree 2 and see how much we can decrease the number of components while still achieving a good accuracy.\n\n\n\nPCA components\nAccuracy\nSupport vectors\n\n\n\n\n90\n99%\n31\n\n\n50\n99%\n31\n\n\n40\n99%\n31\n\n\n30\n90%\n30\n\n\n20\n90%\n28\n\n\n15\n90%\n24\n\n\n10\n99%\n18\n\n\n5\n76%\n28\n\n\n\nWe clearly see a couple of things:\n\nwe still achieve 99% accuracy even with only 40 out of 90 principal components\nwe get a satisfactory 90% accuracy even with only 15 components\n(this is a bit unexpected) it looks like there's a sweet spot at 10 components where the accuracy skyrockets to 99% again. This could be just a contingency of this particular dataset, don't expect to replicate this results on your own dataset\n\nWhat do these numbers mean to you? It means your board has to do many less computations to give you a prediction and will probably be able to host a more complex model.\nLet's check out the figures with n_components = 10 compared with the ones without PCA.\n\n\n\nKernel\nPCA support vectors\nPCA flash size\nAccuracy\n\n\n\n\nRBF C=10\n46 (+24%)\n32 Kb (-40%)\n99%\n\n\nRBF C=100\n28 (-54%)\n32 Kb (-60%)\n99%\n\n\nPoly 2\n13 (-48%)\n28 Kb (+12%)\n99%\n\n\nPoly 3\n24 (-4%)\n32 Kb (-20%)\n99%\n\n\nLinear\n18 (-64%)\n29 Kb (-47%)\n99%\n\n\n\nA couple notes:\n\naccuracy increased (on stayed the same) for all kernels\nwith one exception, flash size decreased in the range 20 - 50%\nnow we can fit 3 classifiers on our Arduino UNO instead of only one\n\nI will probably spend some more time investingating the usefulness of PCA for Arduino Machine Learning projects, but for now that's it: it's a good starting point in my opinion.\n\nThere's a little example sketch on Github that applies PCA to the IRIS dataset.\nTell me what you think may be a clever application of dimensionality reduction in the world of microcontrollers and see if we can build something great together.\nL'articolo Arduino dimensionality reduction (PCA) for Machine Learning projects proviene da Eloquent Arduino Blog.",
            "date_published": "2020-06-07T09:24:20+02:00",
            "date_modified": "2020-06-07T11:26:25+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "microml",
                "pca",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1156",
            "url": "https://eloquentarduino.github.io/2020/05/anomaly-detection-on-your-arduino-microcontroller-via-one-class-svm/",
            "title": "Anomaly detection on your Arduino microcontroller via One Class SVM",
            "content_html": "<p><a href=\"/tag/svm/\">Support Vector Machines</a> are very often used for classification tasks: but you may not know that they're so flexible they can be used for <a href=\"https://scikit-learn.org/stable/modules/outlier_detection.html\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>anomaly detection and novelty detection</strong></a>. Thanks to the <a href=\"https://github.com/eloquentarduino/micromlgen\">micromlgen</a> package, you can run One Class SVM on your Arduino microcontorller.</p>\n<p><img src=\"https://scikit-learn.org/stable/_images/sphx_glr_plot_oneclass_001.png\" alt=\"Novelty detection from sklearn documentation\" title=\"Novelty detection from sklearn documentation\" /><br />\n<span id=\"more-1156\"></span></p>\n<h2>What is anomaly / novelty detection useful for?</h2>\n<h3>Detect noise or anomalies</h3>\n<p>As the name implies, anomaly detection can be used to monitor a stream of data and alert you when something unexpected happens.<br />\nThink of an Industrial IoT setup where you have a bunch of sensors monitoring the working state of a production plant: you want to know as soon as possible if something bad is gonna happen.</p>\n<p>In this case, anomaly detection tells you if your machinery is acting in a different way from the normal state so you can take action.</p>\n<h3>Ignore irrelevant data</h3>\n<p><em>(This application was suggested from two of my readers)</em><br />\nSay you're developing a super simple word classification project: you want to distinguish door bell from fire alarm (as per one of the two readers).<br />\nSo you train your SVM classifier and use <a href=\"https://github.com/eloquentarduino/micromlgen\">micromlgen</a> to run it on your Arduino microcontroller.</p>\n<p>It works well, but we have a problem: you live in a noisy environment with many sounds, so not all of them will either be door bells or fire alarms. Since your classifier is binary, it <em>has to classify all of the sounds</em> as either A or B.</p>\n<p>The solution will be <strong>novelty detection</strong>: before running the binary SVM, you run the <strong>OneClassSVM</strong> to filter known sounds (bell and alarm) from unknown ones (eg. dog barking).<br />\nIf OneClassSVM predicts the sound as a novelty, you discard it since it's of no interest for you. If it predicts the sound as known, you run the binary SVM.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2>How to run anomaly / novelty detection on Arduino microcontroller via OneClassSVM</h2>\n<p>Porting a <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.svm.OneClassSVM.html\">OneClassSVM</a> from Python to plain C++ is as easy as a single command in the <strong>micromlgen</strong> package:</p>\n<pre><code class=\"language-python\">from sklearn.svm import OneClassSVM\nfrom micromlgen import port\n\nclf = OneClassSVM(kernel=&quot;rbf&quot;, nu=0.5, gamma=0.1)\nclf.fit(X, y)\nprint(port(clf))</code></pre>\n<div class=\"watchout\">\nYou will need micromlgen version 1.0.2 to port OneClassSVM. If you have an outdated version, please run <code>pip install --upgrade micromlgen</code>\n</div>\n<p>If you read <a href=\"/tag/svm/\">my previous posts</a> about <strong>micromlgen</strong> and SVM the above snippet should be familiar: with the latest release, <code>port</code> is able to export either SVC, LinearSVC, OneClassSVC and <a href=\"/2020/02/even-smaller-machine-learning-models-for-your-mcu/\">RVC (Relevant Vector Machines)</a> to object oriented C++.</p>\n<p>Now you can embed the generated code in your Arduino sketch.</p>\n<pre><code class=\"language-cpp\">#include &quot;OneClassSVM.h&quot;\n\nEloquent::ML::Port::OneClassSVM clf;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(2000);\n\n  for (int i = 0; i &lt; DATASET_SIZE; i++)\n    clf.predict(X[i]);\n}\n\nvoid loop() {}</code></pre>\n<hr />\n<p>I created an example sketch from a synthetic dataset for anomaly detection (copied from a <a href=\"https://scikit-learn.org/stable/auto_examples/svm/plot_oneclass.html#sphx-glr-auto-examples-svm-plot-oneclass-py\">scikit-learn example</a>) you can run to get a feel of how it performs.</p>\n<p>Go checkout the <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/OneClassSVMExample/OneClassSVMExample.ino\">Github repo</a></p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/05/anomaly-detection-on-your-arduino-microcontroller-via-one-class-svm/\">Anomaly detection on your Arduino microcontroller via One Class SVM</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Support Vector Machines are very often used for classification tasks: but you may not know that they're so flexible they can be used for anomaly detection and novelty detection. Thanks to the micromlgen package, you can run One Class SVM on your Arduino microcontorller.\n\n\nWhat is anomaly / novelty detection useful for?\nDetect noise or anomalies\nAs the name implies, anomaly detection can be used to monitor a stream of data and alert you when something unexpected happens.\nThink of an Industrial IoT setup where you have a bunch of sensors monitoring the working state of a production plant: you want to know as soon as possible if something bad is gonna happen.\nIn this case, anomaly detection tells you if your machinery is acting in a different way from the normal state so you can take action.\nIgnore irrelevant data\n(This application was suggested from two of my readers)\nSay you're developing a super simple word classification project: you want to distinguish door bell from fire alarm (as per one of the two readers).\nSo you train your SVM classifier and use micromlgen to run it on your Arduino microcontroller.\nIt works well, but we have a problem: you live in a noisy environment with many sounds, so not all of them will either be door bells or fire alarms. Since your classifier is binary, it has to classify all of the sounds as either A or B.\nThe solution will be novelty detection: before running the binary SVM, you run the OneClassSVM to filter known sounds (bell and alarm) from unknown ones (eg. dog barking).\nIf OneClassSVM predicts the sound as a novelty, you discard it since it's of no interest for you. If it predicts the sound as known, you run the binary SVM.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nHow to run anomaly / novelty detection on Arduino microcontroller via OneClassSVM\nPorting a OneClassSVM from Python to plain C++ is as easy as a single command in the micromlgen package:\nfrom sklearn.svm import OneClassSVM\nfrom micromlgen import port\n\nclf = OneClassSVM(kernel=&quot;rbf&quot;, nu=0.5, gamma=0.1)\nclf.fit(X, y)\nprint(port(clf))\n\nYou will need micromlgen version 1.0.2 to port OneClassSVM. If you have an outdated version, please run pip install --upgrade micromlgen\n\nIf you read my previous posts about micromlgen and SVM the above snippet should be familiar: with the latest release, port is able to export either SVC, LinearSVC, OneClassSVC and RVC (Relevant Vector Machines) to object oriented C++.\nNow you can embed the generated code in your Arduino sketch.\n#include &quot;OneClassSVM.h&quot;\n\nEloquent::ML::Port::OneClassSVM clf;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(2000);\n\n  for (int i = 0; i &lt; DATASET_SIZE; i++)\n    clf.predict(X[i]);\n}\n\nvoid loop() {}\n\nI created an example sketch from a synthetic dataset for anomaly detection (copied from a scikit-learn example) you can run to get a feel of how it performs.\nGo checkout the Github repo\nL'articolo Anomaly detection on your Arduino microcontroller via One Class SVM proviene da Eloquent Arduino Blog.",
            "date_published": "2020-05-31T18:44:36+02:00",
            "date_modified": "2020-05-31T19:44:50+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1110",
            "url": "https://eloquentarduino.github.io/2020/05/easier-faster-pure-video-esp32-cam-motion-detection/",
            "title": "Easier, faster pure video ESP32 cam motion detection",
            "content_html": "<p>If you liked my post about <a href=\"/2020/01/motion-detection-with-esp32-cam-only-arduino-version/\">ESP32 cam motion detection</a>, you'll love this updated version: it's easier to use and blazing fast!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/Faster-motion-detection.gif\" alt=\"Faster motion detection\" /></p>\n<p><span id=\"more-1110\"></span></p>\n<p>The post about <strong>pure video ESP32 cam motion detection</strong> without an external PIR is my most successful post at the moment. Many of you are interested about this topic.</p>\n<p>One of my readers, though, pointed out my implementation was quite slow and he only achieved bare 5 fps in his project. So he asked for a better alternative.</p>\n<p>Since the post was of great interest for many people, I took the time to revisit the code and make improvements.</p>\n<p>I came up with a 100% re-writing that is both easier to use and faster. Actually, it is <strong>blazing fast!</strong>.</p>\n<p>Let's see how it works.</p>\n<p><div class=\"toc\"><h6>Table of contents</h6><ol><li><a href=\"#tocdownsampling\">Downsampling</a><ol><li><a href=\"#tocnearest-neighbor\">Nearest neighbor</a><li><a href=\"#tocfull-block-average\">Full block average</a><li><a href=\"#toccore-block-average\">Core block average</a><li><a href=\"#toccross-block-average\">Cross block average</a><li><a href=\"#tocdiagonal-block-average\">Diagonal block average</a><li><a href=\"#tocimplement-your-own\">Implement your own</a></li></ol><li><a href=\"#tocbenchmarks\">Benchmarks</a><li><a href=\"#tocmotion-detection\">Motion detection</a><li><a href=\"#tocfull-code\">Full code</a></ol></div></p>\n<h2 id=\"tocdownsampling\">Downsampling</h2>\n<p>In the original post I introduced the idea of downsampling the image from the camera for a faster and more robust motion detection. I wrote the code in the main sketch to keep it self-contained.</p>\n<p>Looking back now it was a poor choice, since it cluttered the project and distracted from the main purpose, which is motion detection.</p>\n<p>Moreover, I thought that scanning the image buffer in sequential order would be the fastest approach.</p>\n<p>It turns out I was wrong.</p>\n<p>This time I scan the image buffer following the blocks that will compose the resulting image and the results are... much faster.</p>\n<p>Also, I decided to inject some more efficiency that will further speedup the computation: using different strategies for downsampling.</p>\n<p>The idea of downsampling is that you have to &quot;collapse&quot; a block of NxN from the original image to just one pixel of the resulting image.</p>\n<p>Now, there are a variety of ways you can accomplish this. The first two I present here are the most obvious, the other two are of my &quot;invention&quot;: nothing fancy nor new, but they're fast and serve the purpose well.</p>\n<h3 id=\"tocnearest-neighbor\">Nearest neighbor</h3>\n<p>You can just pick the center of the NxN block and use its value for the output.<br />\nOf course it is fast (possibly the fastest approach), but wouldn't be very accurate. One pixel out of NxN wouldn't be representative of the overall region and will heavily suffer from noise.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/Nearest-diagram.png\" alt=\"Nearest diagram\" /></p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/nn.jpg\" alt=\"Nearest neighbor block averaging\" /></p>\n<h3 id=\"tocfull-block-average\">Full block average</h3>\n<p>This is the most intuitive alternative: use the average of all the pixels in the block as the ouput value. This is arguabily the &quot;proper&quot; way to do it, since you're using all the pixels in the source image to compute the new one.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/Full-diagram.png\" alt=\"Full diagram\" /><br />\n<img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/full.jpg\" alt=\"Full block averaging\" /></p>\n<h3 id=\"toccore-block-average\">Core block average</h3>\n<p>As a faster alternative, I thought that averaging only the &quot;core&quot; (the most internal part) of the block would have been a good-enough solution. It has no theoretical proof that this yields true, but our task here is to create a smaller <em>representation</em> of the original image, not producing an accurate smaller version.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/Core-diagram.png\" alt=\"Core diagram\" /><br />\n<img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/core.jpg\" alt=\"Core block averaging\" /></p>\n<p><em>I'll stress this point: the only reason we do downsampling is to compare two sequential frame and detect if they differ above a certain threshold. This downsampling doesn't have to mimic the actual image: it can transform the source in any fancy way, as long as it stays consistent and captures the variations over time.</em></p>\n<h3 id=\"toccross-block-average\">Cross block average</h3>\n<p>This time we consider all the pixels along the vertical and horizontal central axes. The idea is that you will capture a good portion of the variation along both the axis, given quite accurate results.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/Cross-diagram.png\" alt=\"Cross diagram\" /><br />\n<img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/cross.jpg\" alt=\"Cross block averaging\" /></p>\n<h3 id=\"tocdiagonal-block-average\">Diagonal block average</h3>\n<p>This alternative too came to my mind from nowhere, really. I just think it is a good alternative to capture all the block's variation, probably even better than vertical and horizontal directions.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/Diagonal-diagram.png\" alt=\"Diagonal diagram\" /><br />\n<img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/05/diagonal.jpg\" alt=\"Diagonal block averaging\" /></p>\n<h3 id=\"tocimplement-your-own\">Implement your own</h3>\n<p>Not satisfied from the methods above? No problem, you can still implement your own.</p>\n<p>The ones presented above are just some algorithms that came to my mind: I'm not telling you they're the best.</p>\n<p>They worked for me, that's it.</p>\n<p>If you think you found a better solution, I encourage you implement it and even share it with me and the other readers, so we can all make progress on this together.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2 id=\"tocbenchmarks\">Benchmarks</h2>\n<p>So, at the very beginning I said this new implementation is blazingly fast. </p>\n<p>How much fast?</p>\n<p>As fast as it can be, arguably.</p>\n<p>I mean, so fast it won't alter your fps.</p>\n<p>Look at the results I got on my M5Stack camera.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th style=\"text-align: center;\">Time to execute (micros)</th>\n<th style=\"text-align: right;\">FPS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>None</td>\n<td style=\"text-align: center;\">0</td>\n<td style=\"text-align: right;\">25</td>\n</tr>\n<tr>\n<td>Nearest neighbor</td>\n<td style=\"text-align: center;\">160</td>\n<td style=\"text-align: right;\">25</td>\n</tr>\n<tr>\n<td>Cross block</td>\n<td style=\"text-align: center;\">700</td>\n<td style=\"text-align: right;\">25</td>\n</tr>\n<tr>\n<td>Core block</td>\n<td style=\"text-align: center;\">800</td>\n<td style=\"text-align: right;\">25</td>\n</tr>\n<tr>\n<td>Diagonal block</td>\n<td style=\"text-align: center;\">950</td>\n<td style=\"text-align: right;\">25</td>\n</tr>\n<tr>\n<td>Full block</td>\n<td style=\"text-align: center;\">4900</td>\n<td style=\"text-align: right;\">12</td>\n</tr>\n</tbody>\n</table>\n<p>As you can see, only the full block creates a delay in the process (quite a bit of delay even): the other  methods  won't slow down your program in any noticeable way.</p>\n<p>If you test Nearest neighbor and it works for you, then you'll be extremely light on computation resources with only <strong>160 microseconds</strong> of delay.</p>\n<p>This is what I mean by <em>blazing fast</em>.</p>\n<h2 id=\"tocmotion-detection\">Motion detection</h2>\n<p>The motion detection part hasn't changed, so I point you to <a href=\"/2020/01/motion-detection-with-esp32-cam-only-arduino-version#tocblocks-difference-threshold\">the original post</a> to read more about the Block difference threshold and the Image difference threshold.</p>\n<h2 id=\"tocfull-code\">Full code</h2>\n<pre><code class=\"language-cpp\">#define CAMERA_MODEL_M5STACK_WIDE\n#include &quot;EloquentVision.h&quot;\n\n#define FRAME_SIZE FRAMESIZE_QVGA\n#define SOURCE_WIDTH 320\n#define SOURCE_HEIGHT 240\n#define BLOCK_SIZE 10\n#define DEST_WIDTH (SOURCE_WIDTH / BLOCK_SIZE)\n#define DEST_HEIGHT (SOURCE_HEIGHT / BLOCK_SIZE)\n#define BLOCK_DIFF_THRESHOLD 0.2\n#define IMAGE_DIFF_THRESHOLD 0.1\n#define DEBUG 0\n\nusing namespace Eloquent::Vision;\n\nESP32Camera camera;\nuint8_t prevFrame[DEST_WIDTH * DEST_HEIGHT] = { 0 };\nuint8_t currentFrame[DEST_WIDTH * DEST_HEIGHT] = { 0 };\n\n// function prototypes\nbool motionDetect();\nvoid updateFrame();\n\n/**\n *\n */\nvoid setup() {\n    Serial.begin(115200);\n    camera.begin(FRAME_SIZE, PIXFORMAT_GRAYSCALE);\n}\n\n/**\n *\n */\nvoid loop() {\n    /**\n     * Algorithm:\n     *  1. grab frame\n     *  2. compare with previous to detect motion\n     *  3. update previous frame\n     */\n\n    time_t start = millis();\n    camera_fb_t *frame = camera.capture();\n\n    downscaleImage(frame-&gt;buf, currentFrame, nearest, SOURCE_WIDTH, SOURCE_HEIGHT, BLOCK_SIZE);\n\n    if (motionDetect()) {\n        Serial.print(&quot;Motion detected @ &quot;);\n        Serial.print(floor(1000.0f / (millis() - start)));\n        Serial.println(&quot; FPS&quot;);\n    }\n\n    updateFrame();\n}\n\n/**\n * Compute the number of different blocks\n * If there are enough, then motion happened\n */\nbool motionDetect() {\n    uint16_t changes = 0;\n    const uint16_t blocks = DEST_WIDTH * DEST_HEIGHT;\n\n    for (int y = 0; y &lt; DEST_HEIGHT; y++) {\n        for (int x = 0; x &lt; DEST_WIDTH; x++) {\n            float current = currentFrame[y * DEST_WIDTH + x];\n            float prev = prevFrame[y * DEST_WIDTH + x];\n            float delta = abs(current - prev) / prev;\n\n            if (delta &gt;= BLOCK_DIFF_THRESHOLD)\n                changes += 1;\n        }\n    }\n\n    return (1.0 * changes / blocks) &gt; IMAGE_DIFF_THRESHOLD;\n}\n\n/**\n * Copy current frame to previous\n */\nvoid updateFrame() {\n    memcpy(prevFrame, currentFrame, DEST_WIDTH * DEST_HEIGHT);\n}</code></pre>\n<hr />\n<p>Check the full project code on <a href=\"https://github.com/eloquentarduino/EloquentVision/blob/master/examples/FasterMotionDetection/FasterMotionDetection.ino\">Github</a> and remember to star!</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/05/easier-faster-pure-video-esp32-cam-motion-detection/\">Easier, faster pure video ESP32 cam motion detection</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "If you liked my post about ESP32 cam motion detection, you'll love this updated version: it's easier to use and blazing fast!\n\n\nThe post about pure video ESP32 cam motion detection without an external PIR is my most successful post at the moment. Many of you are interested about this topic.\nOne of my readers, though, pointed out my implementation was quite slow and he only achieved bare 5 fps in his project. So he asked for a better alternative.\nSince the post was of great interest for many people, I took the time to revisit the code and make improvements.\nI came up with a 100% re-writing that is both easier to use and faster. Actually, it is blazing fast!.\nLet's see how it works.\nTable of contentsDownsamplingNearest neighborFull block averageCore block averageCross block averageDiagonal block averageImplement your ownBenchmarksMotion detectionFull code\nDownsampling\nIn the original post I introduced the idea of downsampling the image from the camera for a faster and more robust motion detection. I wrote the code in the main sketch to keep it self-contained.\nLooking back now it was a poor choice, since it cluttered the project and distracted from the main purpose, which is motion detection.\nMoreover, I thought that scanning the image buffer in sequential order would be the fastest approach.\nIt turns out I was wrong.\nThis time I scan the image buffer following the blocks that will compose the resulting image and the results are... much faster.\nAlso, I decided to inject some more efficiency that will further speedup the computation: using different strategies for downsampling.\nThe idea of downsampling is that you have to &quot;collapse&quot; a block of NxN from the original image to just one pixel of the resulting image.\nNow, there are a variety of ways you can accomplish this. The first two I present here are the most obvious, the other two are of my &quot;invention&quot;: nothing fancy nor new, but they're fast and serve the purpose well.\nNearest neighbor\nYou can just pick the center of the NxN block and use its value for the output.\nOf course it is fast (possibly the fastest approach), but wouldn't be very accurate. One pixel out of NxN wouldn't be representative of the overall region and will heavily suffer from noise.\n\n\nFull block average\nThis is the most intuitive alternative: use the average of all the pixels in the block as the ouput value. This is arguabily the &quot;proper&quot; way to do it, since you're using all the pixels in the source image to compute the new one.\n\n\nCore block average\nAs a faster alternative, I thought that averaging only the &quot;core&quot; (the most internal part) of the block would have been a good-enough solution. It has no theoretical proof that this yields true, but our task here is to create a smaller representation of the original image, not producing an accurate smaller version.\n\n\nI'll stress this point: the only reason we do downsampling is to compare two sequential frame and detect if they differ above a certain threshold. This downsampling doesn't have to mimic the actual image: it can transform the source in any fancy way, as long as it stays consistent and captures the variations over time.\nCross block average\nThis time we consider all the pixels along the vertical and horizontal central axes. The idea is that you will capture a good portion of the variation along both the axis, given quite accurate results.\n\n\nDiagonal block average\nThis alternative too came to my mind from nowhere, really. I just think it is a good alternative to capture all the block's variation, probably even better than vertical and horizontal directions.\n\n\nImplement your own\nNot satisfied from the methods above? No problem, you can still implement your own.\nThe ones presented above are just some algorithms that came to my mind: I'm not telling you they're the best.\nThey worked for me, that's it.\nIf you think you found a better solution, I encourage you implement it and even share it with me and the other readers, so we can all make progress on this together.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nBenchmarks\nSo, at the very beginning I said this new implementation is blazingly fast. \nHow much fast?\nAs fast as it can be, arguably.\nI mean, so fast it won't alter your fps.\nLook at the results I got on my M5Stack camera.\n\n\n\nAlgorithm\nTime to execute (micros)\nFPS\n\n\n\n\nNone\n0\n25\n\n\nNearest neighbor\n160\n25\n\n\nCross block\n700\n25\n\n\nCore block\n800\n25\n\n\nDiagonal block\n950\n25\n\n\nFull block\n4900\n12\n\n\n\nAs you can see, only the full block creates a delay in the process (quite a bit of delay even): the other  methods  won't slow down your program in any noticeable way.\nIf you test Nearest neighbor and it works for you, then you'll be extremely light on computation resources with only 160 microseconds of delay.\nThis is what I mean by blazing fast.\nMotion detection\nThe motion detection part hasn't changed, so I point you to the original post to read more about the Block difference threshold and the Image difference threshold.\nFull code\n#define CAMERA_MODEL_M5STACK_WIDE\n#include &quot;EloquentVision.h&quot;\n\n#define FRAME_SIZE FRAMESIZE_QVGA\n#define SOURCE_WIDTH 320\n#define SOURCE_HEIGHT 240\n#define BLOCK_SIZE 10\n#define DEST_WIDTH (SOURCE_WIDTH / BLOCK_SIZE)\n#define DEST_HEIGHT (SOURCE_HEIGHT / BLOCK_SIZE)\n#define BLOCK_DIFF_THRESHOLD 0.2\n#define IMAGE_DIFF_THRESHOLD 0.1\n#define DEBUG 0\n\nusing namespace Eloquent::Vision;\n\nESP32Camera camera;\nuint8_t prevFrame[DEST_WIDTH * DEST_HEIGHT] = { 0 };\nuint8_t currentFrame[DEST_WIDTH * DEST_HEIGHT] = { 0 };\n\n// function prototypes\nbool motionDetect();\nvoid updateFrame();\n\n/**\n *\n */\nvoid setup() {\n    Serial.begin(115200);\n    camera.begin(FRAME_SIZE, PIXFORMAT_GRAYSCALE);\n}\n\n/**\n *\n */\nvoid loop() {\n    /**\n     * Algorithm:\n     *  1. grab frame\n     *  2. compare with previous to detect motion\n     *  3. update previous frame\n     */\n\n    time_t start = millis();\n    camera_fb_t *frame = camera.capture();\n\n    downscaleImage(frame-&gt;buf, currentFrame, nearest, SOURCE_WIDTH, SOURCE_HEIGHT, BLOCK_SIZE);\n\n    if (motionDetect()) {\n        Serial.print(&quot;Motion detected @ &quot;);\n        Serial.print(floor(1000.0f / (millis() - start)));\n        Serial.println(&quot; FPS&quot;);\n    }\n\n    updateFrame();\n}\n\n/**\n * Compute the number of different blocks\n * If there are enough, then motion happened\n */\nbool motionDetect() {\n    uint16_t changes = 0;\n    const uint16_t blocks = DEST_WIDTH * DEST_HEIGHT;\n\n    for (int y = 0; y &lt; DEST_HEIGHT; y++) {\n        for (int x = 0; x &lt; DEST_WIDTH; x++) {\n            float current = currentFrame[y * DEST_WIDTH + x];\n            float prev = prevFrame[y * DEST_WIDTH + x];\n            float delta = abs(current - prev) / prev;\n\n            if (delta &gt;= BLOCK_DIFF_THRESHOLD)\n                changes += 1;\n        }\n    }\n\n    return (1.0 * changes / blocks) &gt; IMAGE_DIFF_THRESHOLD;\n}\n\n/**\n * Copy current frame to previous\n */\nvoid updateFrame() {\n    memcpy(prevFrame, currentFrame, DEST_WIDTH * DEST_HEIGHT);\n}\n\nCheck the full project code on Github and remember to star!\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nL'articolo Easier, faster pure video ESP32 cam motion detection proviene da Eloquent Arduino Blog.",
            "date_published": "2020-05-10T21:26:08+02:00",
            "date_modified": "2020-05-13T21:19:35+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "camera",
                "esp32",
                "Computer vision"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1079",
            "url": "https://eloquentarduino.github.io/2020/04/incremental-multiclass-classification-on-microcontrollers-one-vs-one/",
            "title": "Incremental multiclass classification on microcontrollers: One vs One",
            "content_html": "<p>In earlier posts I showed you can run incremental binary classification on your microcontroller with Stochastic Gradient Descent or Passive-Aggressive classifier. Now it is time to upgrade your toolbelt with a new item: One-vs-One multiclass classifier.</p>\n<p><span id=\"more-1079\"></span></p>\n<h2>One vs One</h2>\n<p>Many classifiers are, by nature, binary: they can only distinguish the positive class from the negative one. Many of real-world problems, however, are multiclass: you have 3 or more possible outcomes to distinguish from.</p>\n<p>There are a couple of ways to achieve this:</p>\n<ol>\n<li><strong>One vs All</strong>: if your classifier is able to output a confidence score of its prediction, for N classes you train N classifiers, each able to recognize a single class. During inference, you pick the &quot;most confident&quot; one.</li>\n<li><strong>One vs One</strong>: for N classes, you train N * (N-1) / 2 classifiers, one for each couple of classes. During inference, each classifier makes a prediction and you pick the class with the highest number of votes.</li>\n</ol>\n<p>Since SGD and Passive-Aggressive don't output a confidence score, I implemented the One vs One algorithm to tackle the multiclass classification problem on microcontrollers.</p>\n<p>Actually, One vs One is not a new type of classifier: it is really a &quot;coordinator&quot; class that sorts which samples go to which classifier. You can still choose your own classifier type to use.</p>\n<p>As SGD and Passive-Aggressive, OneVsOne implements the classifier interface, so you will use the well known <code>fitOne</code> and <code>predict</code> methods.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2>Example code</h2>\n<pre><code class=\"language-cpp\">// Esp32 has some problems with min/max\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n// you will actually need only one of SGD or PassiveAggressive\n#include &quot;EloquentSGD.h&quot;\n#include &quot;EloquentPassiveAggressive.h&quot;\n#include &quot;EloquentOneVsOne.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n// this file defines NUM_FEATURES, NUM_CLASSES, TRAIN_SAMPLES and TEST_SAMPLES\n#include &quot;dataset.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n}\n\nvoid loop() {\n  AccuracyScorer scorer;\n  // OneVsOne needs the actual classifier class, the number of features and the number of classes\n  OneVsOne&lt;SGD&lt;FEATURES_DIM&gt;, FEATURES_DIM, NUM_CLASSES&gt; clf;\n\n  // clf.set() propagates the configuration to the actual classifiers\n  // if a parameter does not exists on the classifier, it does nothing\n  // in this example, alpha and momentum refer to SGD, C to Passive-Aggressive\n  clf.set(&quot;alpha&quot;, 1);\n  clf.set(&quot;momentum&quot;, 0.7);\n  clf.set(&quot;C&quot;, 0.1);\n\n  // fit\n  // I noticed that repeating the training a few times over the same dataset increases performance  to a certain extent: if you re-train it too much, performance will decay\n  for (unsigned int i = 0; i &lt; TRAIN_SAMPLES * 5; i++) {\n      clf.fitOne(X_train[i % TRAIN_SAMPLES], y_train[i % TRAIN_SAMPLES]);\n  }\n\n  // predict\n  for (int i = 0; i &lt; TEST_SAMPLES; i++) {\n      int y_true = y_test[i];\n      int y_pred = clf.predict(X_test[i]);\n\n      Serial.print(&quot;Predicted &quot;);\n      Serial.print(y_pred);\n      Serial.print(&quot; vs &quot;);\n      Serial.println(y_true);\n      scorer.scoreOne(y_true, y_pred);\n  }\n\n  Serial.print(&quot;Accuracy = &quot;);\n  Serial.print(scorer.accuracy() * 100);\n  Serial.print(&quot; out of &quot;);\n  Serial.print(scorer.support());\n  Serial.println(&quot; samples&quot;);\n  delay(30000);\n}</code></pre>\n<p>If you refer to the previous posts on <a href=\"/2020/04/stochastic-gradient-descent-on-your-microcontroller/\">SGD</a> and <a href=\"/2020/04/passive-aggressive-classifier-for-embedded-devices/\">Passive-Aggressive</a>, you'll notice that you would be able to replace one with the other and your code will change by <strong>1 single line only</strong>. This let's you experiment to find the best configuration for your project without hassle.</p>\n<h2>Accuracy</h2>\n<p>Well, accuracy vary.</p>\n<p>In my tests, I couldn't get predictable accuracy on all datasets. I couldn't even get acceptable accuracy on the Iris dataset (60% max). But I got 90% accuracy on the Digits dataset from scikit-learn with 6 classes.</p>\n<p>You have to experiment. Try Passive-Aggressive with many <code>C</code> values. If it doesn't work, try SGD with varying <code>momentum</code> and <code>alpha</code>. Try to repeat the training over the dataset 5, 10 times.</p>\n<p>In a next post I'll report my benchmarks so you can see what works for you and what not.<br />\nThis is an emerging field for me, so I will need time to master it.</p>\n<hr />\n<p>As always, you can find the examle on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/OvOExample/OvOExample.ino\">Github</a> with a the dataset to experiment with.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/04/incremental-multiclass-classification-on-microcontrollers-one-vs-one/\">Incremental multiclass classification on microcontrollers: One vs One</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "In earlier posts I showed you can run incremental binary classification on your microcontroller with Stochastic Gradient Descent or Passive-Aggressive classifier. Now it is time to upgrade your toolbelt with a new item: One-vs-One multiclass classifier.\n\nOne vs One\nMany classifiers are, by nature, binary: they can only distinguish the positive class from the negative one. Many of real-world problems, however, are multiclass: you have 3 or more possible outcomes to distinguish from.\nThere are a couple of ways to achieve this:\n\nOne vs All: if your classifier is able to output a confidence score of its prediction, for N classes you train N classifiers, each able to recognize a single class. During inference, you pick the &quot;most confident&quot; one.\nOne vs One: for N classes, you train N * (N-1) / 2 classifiers, one for each couple of classes. During inference, each classifier makes a prediction and you pick the class with the highest number of votes.\n\nSince SGD and Passive-Aggressive don't output a confidence score, I implemented the One vs One algorithm to tackle the multiclass classification problem on microcontrollers.\nActually, One vs One is not a new type of classifier: it is really a &quot;coordinator&quot; class that sorts which samples go to which classifier. You can still choose your own classifier type to use.\nAs SGD and Passive-Aggressive, OneVsOne implements the classifier interface, so you will use the well known fitOne and predict methods.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nExample code\n// Esp32 has some problems with min/max\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n// you will actually need only one of SGD or PassiveAggressive\n#include &quot;EloquentSGD.h&quot;\n#include &quot;EloquentPassiveAggressive.h&quot;\n#include &quot;EloquentOneVsOne.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n// this file defines NUM_FEATURES, NUM_CLASSES, TRAIN_SAMPLES and TEST_SAMPLES\n#include &quot;dataset.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n}\n\nvoid loop() {\n  AccuracyScorer scorer;\n  // OneVsOne needs the actual classifier class, the number of features and the number of classes\n  OneVsOne&lt;SGD&lt;FEATURES_DIM&gt;, FEATURES_DIM, NUM_CLASSES&gt; clf;\n\n  // clf.set() propagates the configuration to the actual classifiers\n  // if a parameter does not exists on the classifier, it does nothing\n  // in this example, alpha and momentum refer to SGD, C to Passive-Aggressive\n  clf.set(&quot;alpha&quot;, 1);\n  clf.set(&quot;momentum&quot;, 0.7);\n  clf.set(&quot;C&quot;, 0.1);\n\n  // fit\n  // I noticed that repeating the training a few times over the same dataset increases performance  to a certain extent: if you re-train it too much, performance will decay\n  for (unsigned int i = 0; i &lt; TRAIN_SAMPLES * 5; i++) {\n      clf.fitOne(X_train[i % TRAIN_SAMPLES], y_train[i % TRAIN_SAMPLES]);\n  }\n\n  // predict\n  for (int i = 0; i &lt; TEST_SAMPLES; i++) {\n      int y_true = y_test[i];\n      int y_pred = clf.predict(X_test[i]);\n\n      Serial.print(&quot;Predicted &quot;);\n      Serial.print(y_pred);\n      Serial.print(&quot; vs &quot;);\n      Serial.println(y_true);\n      scorer.scoreOne(y_true, y_pred);\n  }\n\n  Serial.print(&quot;Accuracy = &quot;);\n  Serial.print(scorer.accuracy() * 100);\n  Serial.print(&quot; out of &quot;);\n  Serial.print(scorer.support());\n  Serial.println(&quot; samples&quot;);\n  delay(30000);\n}\nIf you refer to the previous posts on SGD and Passive-Aggressive, you'll notice that you would be able to replace one with the other and your code will change by 1 single line only. This let's you experiment to find the best configuration for your project without hassle.\nAccuracy\nWell, accuracy vary.\nIn my tests, I couldn't get predictable accuracy on all datasets. I couldn't even get acceptable accuracy on the Iris dataset (60% max). But I got 90% accuracy on the Digits dataset from scikit-learn with 6 classes.\nYou have to experiment. Try Passive-Aggressive with many C values. If it doesn't work, try SGD with varying momentum and alpha. Try to repeat the training over the dataset 5, 10 times.\nIn a next post I'll report my benchmarks so you can see what works for you and what not.\nThis is an emerging field for me, so I will need time to master it.\n\nAs always, you can find the examle on Github with a the dataset to experiment with.\nL'articolo Incremental multiclass classification on microcontrollers: One vs One proviene da Eloquent Arduino Blog.",
            "date_published": "2020-04-26T10:01:14+02:00",
            "date_modified": "2020-04-26T11:52:29+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "incremental-learning",
                "microml",
                "ml",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1062",
            "url": "https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/",
            "title": "Stochastic Gradient Descent on your microcontroller",
            "content_html": "<p>Stochastic gradient descent is a well know algorithm to train classifiers in an incremental fashion: that is, as training samples become available. This saves you critical memory on tiny devices while still achieving <strong>top performance</strong>! Now you can use it on your microcontroller with ease.</p>\n<p><span id=\"more-1062\"></span></p>\n<h2>A brief recap on Stochastic Gradient Descent</h2>\n<p>If you ever worked with Machine learning, you surely know about <a href=\"https://en.wikipedia.org/wiki/Gradient_descent\">Gradient descent</a>: it is an iterative algorithm to optimize a loss function. </p>\n<p>It is much general-purpose, in the sense that it is not bound to a particular application, but it has been heavily used in Neural networks in the recent years.</p>\n<p>Yet, it can be used as a classifier on its own if you set its loss function as the classification error.</p>\n<p><img src=\"https://mccormickml.com/assets/GradientDescent/GradientDescentOfMSETable.png\" alt=\"Update rule of Gradient descent\" /></p>\n<p>This is the core update rule of Gradient descent: quite simple.</p>\n<p>As you see, there's a summation in the formula: this means we need to cycle through the entire training set to compute the update to the weights.</p>\n<p>In case of large datasets, this can be slow or not possible at all.</p>\n<p>And requires a lot of memory.</p>\n<p>And we don't have memory on microcontrollers.</p>\n<p>So we need <a href=\"https://en.wikipedia.org/wiki/Stochastic_gradient_descent\">Stochastic gradient descent</a>.</p>\n<p>Stochastic gradient descent has the same exact update rule, but it is applied on the single training sample.</p>\n<p>Imagine the summation goes from 1 to 1, instead of m.</p>\n<p>That's it.</p>\n<div class=\"heateor_sss_sharing_container heateor_sss_horizontal_sharing\" ss-offset=\"0\" heateor-sss-data-href='https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/'><ul class=\"heateor_sss_sharing_ul\"><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" alt=\"Facebook\" Title=\"Facebook\" class=\"heateorSssSharing heateorSssFacebookBackground\" onclick='heateorSssPopup(\"https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Feloquent.blog%2F2020%2F04%2Fstochastic-gradient-descent-on-your-microcontroller%2F\")'><ss style=\"display:block;border-radius:999px;\" class=\"heateorSssSharingSvg heateorSssFacebookSvg\"></ss></i></li><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" alt=\"Twitter\" Title=\"Twitter\" class=\"heateorSssSharing heateorSssTwitterBackground\" onclick='heateorSssPopup(\"http://twitter.com/intent/tweet?via=ArduinoEloquent&text=Stochastic%20Gradient%20Descent%20on%20your%20microcontroller&url=http%3A%2F%2Feloquent.blog%2F2020%2F04%2Fstochastic-gradient-descent-on-your-microcontroller%2F\")'><ss style=\"display:block;border-radius:999px;\" class=\"heateorSssSharingSvg heateorSssTwitterSvg\"></ss></i></li><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" alt=\"Linkedin\" Title=\"Linkedin\" class=\"heateorSssSharing heateorSssLinkedinBackground\" onclick='heateorSssPopup(\"http://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Feloquent.blog%2F2020%2F04%2Fstochastic-gradient-descent-on-your-microcontroller%2F&title=Stochastic%20Gradient%20Descent%20on%20your%20microcontroller\")'><ss style=\"display:block;border-radius:999px;\" class=\"heateorSssSharingSvg heateorSssLinkedinSvg\"></ss></i></li><li class=\"heateorSssSharingRound\"><i style=\"width:35px;height:35px;border-radius:999px;\" title=\"More\" alt=\"More\" class=\"heateorSssSharing heateorSssMoreBackground\" onclick=\"heateorSssMoreSharingPopup(this, 'https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/', 'Stochastic%20Gradient%20Descent%20on%20your%20microcontroller', '' )\" ><ss style=\"display:block\" class=\"heateorSssSharingSvg heateorSssMoreSvg\"></ss></i></li></ul><div class=\"heateorSssClear\"></div></div>\n<h2>How to use</h2>\n<p>The pattern of use is similar to that of the <a href=\"/2020/04/passive-aggressive-classifier-for-embedded-devices/\">Passive Aggressive classifier</a>: you have the <code>fitOne</code> and <code>predict</code> methods.</p>\n<p>First of all, <a href=\"https://github.com/eloquentarduino/EloquentMicroML\">download the library from Github</a>.</p>\n<pre><code class=\"language-c\">#include &lt;EloquentSGD.h&gt;\n#include &lt;EloquentAccuracyScorer.h&gt;\n#include &quot;iris.h&quot;\n\n#define VERBOSE\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n    Serial.begin(115200);\n    delay(3000);\n}\n\nvoid loop() {\n    int trainSamples;\n    int retrainingCycles;\n    SGD&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    // ....\n\n    // train\n    for (uint16_t cycle = 0; cycle &lt; retrainingCycles; cycle++)\n        for (uint16_t i = 0; i &lt; trainSamples; i++)\n            clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i];\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}</code></pre>\n<p>In this case we're working with known datasets, so we cycle through them for the training, but if you're learning &quot;on-line&quot;, from samples generated over time, it will work exactly the same.</p>\n<h2>A bit of momentum</h2>\n<p>Stochastic gradient descent works quite well out of the box in most cases.</p>\n<p>Sometimes, however, its updates can start &quot;oscillating&quot;.</p>\n<p><img src=\"https://media.springernature.com/original/springer-static/image/chp%3A10.1007%2F978-1-4842-4470-8_33/MediaObjects/463852_1_En_33_Fig1_HTML.jpg\" alt=\"SGD with and without momentum\" /></p>\n<p>To solve this problem, it <a href=\"https://doi.org/10.1038%2F323533a0\">has been proposed</a> the <strong>momentum</strong> technique, which can both speed up learning and increase the accuracy.</p>\n<p>In my personal tests, I was able to achieve up to +5% in accuracy on the majority of datasets.</p>\n<p>To use it, you only need to set a <em>decay factor</em> between 0 and 1.</p>\n<pre><code class=\"language-c\">SGD clf;\n\nclf.momentum(0.5);</code></pre>\n<h2>Run on your own</h2>\n<p>On <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/SGDExample/SGDExample.ino\">Github</a> you can find the full example with some benchmark datasets to try on your own.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<p>The example is interactive an will ask you how many samples to use for the training and how many times to cycle through them.</p>\n<p>This is something you should consider: if you have a training set and can store it somehow (in memory or on Flash for example), re-presenting the same samples to the SGD classifier could (and probably will) increase its performance if done correctly.</p>\n<p>This happens because the algorithm needs some time to converge and if it doesn't receive enough samples it won't learn properly.</p>\n<p>Of course, if you re-use the same samples over and over again, you're likely to overfit.</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/04/stochastic-gradient-descent-on-your-microcontroller/\">Stochastic Gradient Descent on your microcontroller</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Stochastic gradient descent is a well know algorithm to train classifiers in an incremental fashion: that is, as training samples become available. This saves you critical memory on tiny devices while still achieving top performance! Now you can use it on your microcontroller with ease.\n\nA brief recap on Stochastic Gradient Descent\nIf you ever worked with Machine learning, you surely know about Gradient descent: it is an iterative algorithm to optimize a loss function. \nIt is much general-purpose, in the sense that it is not bound to a particular application, but it has been heavily used in Neural networks in the recent years.\nYet, it can be used as a classifier on its own if you set its loss function as the classification error.\n\nThis is the core update rule of Gradient descent: quite simple.\nAs you see, there's a summation in the formula: this means we need to cycle through the entire training set to compute the update to the weights.\nIn case of large datasets, this can be slow or not possible at all.\nAnd requires a lot of memory.\nAnd we don't have memory on microcontrollers.\nSo we need Stochastic gradient descent.\nStochastic gradient descent has the same exact update rule, but it is applied on the single training sample.\nImagine the summation goes from 1 to 1, instead of m.\nThat's it.\n\nHow to use\nThe pattern of use is similar to that of the Passive Aggressive classifier: you have the fitOne and predict methods.\nFirst of all, download the library from Github.\n#include &lt;EloquentSGD.h&gt;\n#include &lt;EloquentAccuracyScorer.h&gt;\n#include &quot;iris.h&quot;\n\n#define VERBOSE\n\nusing namespace Eloquent::ML;\n\nvoid setup() {\n    Serial.begin(115200);\n    delay(3000);\n}\n\nvoid loop() {\n    int trainSamples;\n    int retrainingCycles;\n    SGD&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    // ....\n\n    // train\n    for (uint16_t cycle = 0; cycle &lt; retrainingCycles; cycle++)\n        for (uint16_t i = 0; i &lt; trainSamples; i++)\n            clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i];\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}\nIn this case we're working with known datasets, so we cycle through them for the training, but if you're learning &quot;on-line&quot;, from samples generated over time, it will work exactly the same.\nA bit of momentum\nStochastic gradient descent works quite well out of the box in most cases.\nSometimes, however, its updates can start &quot;oscillating&quot;.\n\nTo solve this problem, it has been proposed the momentum technique, which can both speed up learning and increase the accuracy.\nIn my personal tests, I was able to achieve up to +5% in accuracy on the majority of datasets.\nTo use it, you only need to set a decay factor between 0 and 1.\nSGD clf;\n\nclf.momentum(0.5);\nRun on your own\nOn Github you can find the full example with some benchmark datasets to try on your own.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nThe example is interactive an will ask you how many samples to use for the training and how many times to cycle through them.\nThis is something you should consider: if you have a training set and can store it somehow (in memory or on Flash for example), re-presenting the same samples to the SGD classifier could (and probably will) increase its performance if done correctly.\nThis happens because the algorithm needs some time to converge and if it doesn't receive enough samples it won't learn properly.\nOf course, if you re-use the same samples over and over again, you're likely to overfit.\nL'articolo Stochastic Gradient Descent on your microcontroller proviene da Eloquent Arduino Blog.",
            "date_published": "2020-04-10T19:43:45+02:00",
            "date_modified": "2020-04-12T19:31:52+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "microml",
                "online-learning",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1050",
            "url": "https://eloquentarduino.github.io/2020/04/passive-aggressive-classifier-for-embedded-devices/",
            "title": "Passive-aggressive classifier for embedded devices",
            "content_html": "<p>When working with memory constrained devices you may not able to keep all the training data in memory: passive-aggressive classifiers may help solve your memory problems.</p>\n<p><span id=\"more-1050\"></span></p>\n<h2>Batch learning</h2>\n<p>A couple weeks ago I started exploring the possibility to train a machine learning classifier directly on a microcontroller. Since I like SVM, <a href=\"/2020/03/so-you-want-to-train-an-ml-classifier-directly-on-an-arduino-board\">I ported the simplified SVM SMO (Sequential Minimal Optimization) algorithm</a> to plain C, ready to be deployed to embedded devices.</p>\n<p>Now, that kind of algorithm works in the so-called &quot;batch-mode&quot;: it needs all the training data to be available in memory to learn.</p>\n<p>This may be a limiting factor on resource-constrained devices, since it poses an upper bound to the number of samples you can train on. And when working with high-dimensional datasets, the number of samples could be not enough to achieve good accuracy.</p>\n<h2>Enter incremental learning</h2>\n<p>To solve this limitation, you need a totally different kind of learning algorithms: you need incremental (a.k.a online a.k.a out of core) learning.</p>\n<p>Incremental learning works by inspecting one training sample at a time, instead of all at once.</p>\n<p>The clear advantage is that you have a tiny memory footprint. And this is a <strong>huge</strong> advantage.</p>\n<p>The clear disadvantage is that you don't have the &quot;big picture&quot; of your data, so:</p>\n<ul>\n<li>the end result will probably be affected by the order of presentation of the samples</li>\n<li>you may not be able to achieve top accuracy</li>\n</ul>\n<h2>Passive-aggressive classifier</h2>\n<p>Passive-aggressive classification is one of the available incremental learning algorithms and it is very simple to implement, since it has a closed-form update rule.</p>\n<p>Please refer to this <a href=\"https://www.bonaccorso.eu/2017/10/06/ml-algorithms-addendum-passive-aggressive-algorithms/\">short explanation on Passive-aggressive classifiers</a> for a nice description with images.</p>\n<p>The core concept is that the classifier adjusts it weight vector for each mis-classified training sample it receives, trying to get it correct.</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/04/passive-aggressive-classifier.png\" alt=\"Passive aggressive classifier\" /></p>\n<h2>Benchmarks</h2>\n<p>I run a couple benchmark on my Esp32 to assess both accuracy and training time.</p>\n<p>First of all: <strong>it is fast!</strong>. When I say it is fast I mean it takes ~1ms to train on 400 samples x 30 features each.</p>\n<p>Talking about accuracy instead... Uhm...</p>\n<p>Accuracy vary. <strong>Greatly</strong>. </p>\n<p>You can achieve 100% on some datasets. </p>\n<p>And 40% on others. But on those same datasets you can achieve &gt;85% if training on a different number of samples. Or in a different order.</p>\n<p>I guess this is the tradeoff for such a simple and space-efficient algorithm.</p>\n<p>I report my results in the following table. It is not meant to be an exhaustive benchmark of the classifier, since those number will vary based on the order of presentation, but still you can get an idea of what it is able to achieve.</p>\n<table>\n<thead>\n<tr>\n<th>Dataset size</th>\n<th style=\"text-align: center;\">Train samples</th>\n<th style=\"text-align: right;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BREAST CANCER</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>567 samples</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">62</td>\n</tr>\n<tr>\n<td>30 features</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">37</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">63</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: right;\">39</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">150</td>\n<td style=\"text-align: right;\">38</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">200</td>\n<td style=\"text-align: right;\">64</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">250</td>\n<td style=\"text-align: right;\">61</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">300</td>\n<td style=\"text-align: right;\">69</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">350</td>\n<td style=\"text-align: right;\">73</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">400</td>\n<td style=\"text-align: right;\">85</td>\n</tr>\n<tr>\n<td>IRIS</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>100 samples</td>\n<td style=\"text-align: center;\">10</td>\n<td style=\"text-align: right;\">50</td>\n</tr>\n<tr>\n<td>4 features</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">51</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">80</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td>DIGITS</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>358 samples</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">98</td>\n</tr>\n<tr>\n<td>64 features</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">98</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">99</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">150</td>\n<td style=\"text-align: right;\">100</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">200</td>\n<td style=\"text-align: right;\">99</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">250</td>\n<td style=\"text-align: right;\">98</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">300</td>\n<td style=\"text-align: right;\">95</td>\n</tr>\n<tr>\n<td>CLEVELAND HEART DISEASE</td>\n<td style=\"text-align: center;\"></td>\n<td style=\"text-align: right;\"></td>\n</tr>\n<tr>\n<td>212 samples</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: right;\">76</td>\n</tr>\n<tr>\n<td>13 features</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: right;\">24</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: right;\">77</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">100</td>\n<td style=\"text-align: right;\">19</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">120</td>\n<td style=\"text-align: right;\">82</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">140</td>\n<td style=\"text-align: right;\">78</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align: center;\">180</td>\n<td style=\"text-align: right;\">88</td>\n</tr>\n</tbody>\n</table>\n<h2>Time to code</h2>\n<p>Here I'll report an extract of the example code you can find on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PassiveAggressiveExample/PassiveAggressiveExample.ino\">Github</a> for this classifier.</p>\n<pre><code class=\"language-c\">#include &quot;EloquentPassiveAggressiveClassifier.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n#include &quot;iris.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid loop() {\n    int trainSamples;\n    PassiveAggressiveClassifier&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    trainSamples = readSerialNumber(&quot;How many samples will you use as training?&quot;, DATASET_SIZE - 2);\n\n    if (trainSamples == 0)\n        return;\n\n    clf.setC(1);\n\n    // train\n    for (uint16_t i = 0; i &lt; trainSamples; i++)\n        clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i] &gt; 0 ? 1 : -1;\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}</code></pre>\n<hr />\n<p>On the <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/PassiveAggressiveExample/PassiveAggressiveExample.ino\">project page</a> you will find the code to reproduce these numbers.</p>\n<hr />\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/04/passive-aggressive-classifier-for-embedded-devices/\">Passive-aggressive classifier for embedded devices</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "When working with memory constrained devices you may not able to keep all the training data in memory: passive-aggressive classifiers may help solve your memory problems.\n\nBatch learning\nA couple weeks ago I started exploring the possibility to train a machine learning classifier directly on a microcontroller. Since I like SVM, I ported the simplified SVM SMO (Sequential Minimal Optimization) algorithm to plain C, ready to be deployed to embedded devices.\nNow, that kind of algorithm works in the so-called &quot;batch-mode&quot;: it needs all the training data to be available in memory to learn.\nThis may be a limiting factor on resource-constrained devices, since it poses an upper bound to the number of samples you can train on. And when working with high-dimensional datasets, the number of samples could be not enough to achieve good accuracy.\nEnter incremental learning\nTo solve this limitation, you need a totally different kind of learning algorithms: you need incremental (a.k.a online a.k.a out of core) learning.\nIncremental learning works by inspecting one training sample at a time, instead of all at once.\nThe clear advantage is that you have a tiny memory footprint. And this is a huge advantage.\nThe clear disadvantage is that you don't have the &quot;big picture&quot; of your data, so:\n\nthe end result will probably be affected by the order of presentation of the samples\nyou may not be able to achieve top accuracy\n\nPassive-aggressive classifier\nPassive-aggressive classification is one of the available incremental learning algorithms and it is very simple to implement, since it has a closed-form update rule.\nPlease refer to this short explanation on Passive-aggressive classifiers for a nice description with images.\nThe core concept is that the classifier adjusts it weight vector for each mis-classified training sample it receives, trying to get it correct.\n\nBenchmarks\nI run a couple benchmark on my Esp32 to assess both accuracy and training time.\nFirst of all: it is fast!. When I say it is fast I mean it takes ~1ms to train on 400 samples x 30 features each.\nTalking about accuracy instead... Uhm...\nAccuracy vary. Greatly. \nYou can achieve 100% on some datasets. \nAnd 40% on others. But on those same datasets you can achieve &gt;85% if training on a different number of samples. Or in a different order.\nI guess this is the tradeoff for such a simple and space-efficient algorithm.\nI report my results in the following table. It is not meant to be an exhaustive benchmark of the classifier, since those number will vary based on the order of presentation, but still you can get an idea of what it is able to achieve.\n\n\n\nDataset size\nTrain samples\nAccuracy\n\n\n\n\nBREAST CANCER\n\n\n\n\n567 samples\n20\n62\n\n\n30 features\n40\n37\n\n\n\n60\n63\n\n\n\n100\n39\n\n\n\n150\n38\n\n\n\n200\n64\n\n\n\n250\n61\n\n\n\n300\n69\n\n\n\n350\n73\n\n\n\n400\n85\n\n\nIRIS\n\n\n\n\n100 samples\n10\n50\n\n\n4 features\n20\n51\n\n\n\n40\n100\n\n\n\n60\n100\n\n\n\n80\n100\n\n\nDIGITS\n\n\n\n\n358 samples\n20\n98\n\n\n64 features\n40\n98\n\n\n\n60\n99\n\n\n\n100\n100\n\n\n\n150\n100\n\n\n\n200\n99\n\n\n\n250\n98\n\n\n\n300\n95\n\n\nCLEVELAND HEART DISEASE\n\n\n\n\n212 samples\n20\n76\n\n\n13 features\n40\n24\n\n\n\n60\n77\n\n\n\n100\n19\n\n\n\n120\n82\n\n\n\n140\n78\n\n\n\n180\n88\n\n\n\nTime to code\nHere I'll report an extract of the example code you can find on Github for this classifier.\n#include &quot;EloquentPassiveAggressiveClassifier.h&quot;\n#include &quot;EloquentAccuracyScorer.h&quot;\n#include &quot;iris.h&quot;\n\nusing namespace Eloquent::ML;\n\nvoid loop() {\n    int trainSamples;\n    PassiveAggressiveClassifier&lt;FEATURES_DIM&gt; clf;\n    AccuracyScorer scorer;\n\n    trainSamples = readSerialNumber(&quot;How many samples will you use as training?&quot;, DATASET_SIZE - 2);\n\n    if (trainSamples == 0)\n        return;\n\n    clf.setC(1);\n\n    // train\n    for (uint16_t i = 0; i &lt; trainSamples; i++)\n        clf.fitOne(X[i], y[i]);\n\n    // predict\n    for (uint16_t i = trainSamples; i &lt; DATASET_SIZE; i++) {\n        int predicted = clf.predict(X[i]);\n        int actual = y[i] &gt; 0 ? 1 : -1;\n\n        scorer.scoreOne(actual, predicted);\n    }\n\n    Serial.print(&quot;Accuracy: &quot;);\n    Serial.print(round(100 * scorer.accuracy()));\n    Serial.print(&quot;% out of &quot;);\n    Serial.print(scorer.support());\n    Serial.println(&quot; predictions&quot;);\n}\n\nOn the project page you will find the code to reproduce these numbers.\n\nL'articolo Passive-aggressive classifier for embedded devices proviene da Eloquent Arduino Blog.",
            "date_published": "2020-04-05T19:04:10+02:00",
            "date_modified": "2020-05-01T10:34:15+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "microml",
                "online-learning",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=988",
            "url": "https://eloquentarduino.github.io/2020/03/how-to-train-a-color-classification-machine-learning-classifier-directly-on-your-arduino-board/",
            "title": "How to train a color classification Machine learning classifier directly on your Arduino board",
            "content_html": "<p>In the <a href=\"/2020/03/so-you-want-to-train-an-ml-classifier-directly-on-an-arduino-board\">previous post</a> we learnt it is possible to train a Machine learning classifier directly on a microcontroller. In this post we'll look into how to do it to classify colors.</p>\n<p><span id=\"more-988\"></span></p>\n<p>This will be an hands-on guide, so let's walk throughout each step you need to complete to run the example. </p>\n<p>I setup this very example as a basis for your future projects, so you can easily swap the color classification task for any other one you could think of.</p>\n<h2>Definitions</h2>\n<pre><code class=\"language-c\">#ifdef ESP32\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n#define abs(x) ((x) &gt; 0 ? (x) : -(x))\n#endif\n\n#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;RGB.h&quot;\n\n#define MAX_TRAINING_SAMPLES 20\n#define FEATURES_DIM 3\n\nusing namespace Eloquent::ML;\n\nint numSamples;\nRGB rgb(2, 3, 4);\nfloat X_train[MAX_TRAINING_SAMPLES][FEATURES_DIM];\nint y_train[MAX_TRAINING_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);</code></pre>\n<p>When training a classifier on your microcontroller there are some things that are mandatory:</p>\n<ol>\n<li><code>#include &lt;EloquentSVMSMO.h&gt;</code>: this is the library that implements the SVM learning algorithm</li>\n<li><code>X_train</code>: this is a matrix where each row represents a training sample. You will need to keep this data always with you, since it's required also during the inference</li>\n<li><code>y_train</code>: this array contains, for each training sample, the class it belongs to: 1 or -1</li>\n<li><code>linearKernel</code>: this is the kernel function for the SVM classifier (you can read more <a href=\"#\">here</a>). You can pass your own kernel other than linear (for example <code>poly</code> or <code>rbf</code>)</li>\n</ol>\n<p>In this specific example, we're using the <code>RGB</code> class to handle the TCS3200 sensor reading, but this will change based on the dataset you want to train on. Also, since our features are going to be the R, G and B components of a color, <code>FEATURES_DIM</code> is set to 3.</p>\n<h2>Setup</h2>\n<pre><code class=\"language-c\">void setup() {\n    Serial.begin(115200);\n    rgb.begin();\n\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}</code></pre>\n<p>The setup does not contain any logic really. You can use this part to configure the parameters of the classifier:</p>\n<ul>\n<li><code>C</code>: &quot;The C parameter tells the SVM optimization how much you want to avoid misclassifying each training example. For large values of C, the optimization will choose a smaller-margin hyperplane if that hyperplane does a better job of getting all the training points classified correctly. Conversely, a very small value of C will cause the optimizer to look for a larger-margin separating hyperplane, even if that hyperplane misclassifies more points&quot; (quoted from <a href=\"https://stats.stackexchange.com/questions/31066/what-is-the-influence-of-c-in-svms-with-linear-kernel\">stackexchange</a>)</li>\n<li><code>tol</code>: &quot;The tol parameter is a setting for the SVM's tolerance in optimization. Recall that <code>yi(xi.w+b)-1 &gt;= 0</code>. For an SVM to be valid, all values must be greater than or equal to 0, and at least one value on each side needs to be &quot;equal&quot; to 0, which will be your support vectors. Since it is highly unlikely that you will actually get values equal perfectly to 0, you set tolerance to allow a bit of wiggle room.&quot; (quoted from <a href=\"https://pythonprogramming.net/support-vector-machine-parameters-machine-learning-tutorial/\">pythonprogramming</a>)</li>\n<li><code>maxIter</code>: set an upper bound to the number of iterations the algorithm can take to converge</li>\n<li><code>passes</code>: max # of times to iterate over \u03b1\u2019s without changing</li>\n<li><code>alphaTol</code>: alfpha coefficients determine which samples from the training set are to be considered support vectors and so be included during the inference procedure. This value discards support vectors with an alpha too small to be noticeable.</li>\n</ul>\n<h2>Fit</h2>\n<pre><code class=\"language-c\">else if (command == &quot;fit&quot;) {\n        Serial.print(&quot;How many samples will you record? &quot;);\n        numSamples = readSerialNumber();\n\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(i + 1);\n            Serial.print(&quot;/&quot;);\n            Serial.print(numSamples);\n            Serial.println(&quot; Which class does the sample belongs to, 1 or -1?&quot;);\n            y_train[i] = readSerialNumber() &gt; 0 ? 1 : -1;\n            getFeatures(X_train[i]);\n        }\n\n        Serial.print(&quot;Start training... &quot;);\n        classifier.fit(X_train, y_train, numSamples);\n        Serial.println(&quot;Done&quot;);\n    }</code></pre>\n<p>This is the core of the project. Here we are loading the samples to train our classifier &quot;live&quot; on the board.</p>\n<p>Since this is an interactive demo, the program prompts us to define how many samples we'll load and, one by one, which class they belong to.</p>\n<p>Now there are a few important things to keep in mind:</p>\n<ul>\n<li><code>numSamples</code>: sadly, C has no easy way to know the size of an array, so we have to be explicit about it. To train the classifier, it is mandatory that you do know I many samples you're passing to it</li>\n<li><code>getFeatures()</code> is the function that reads the training sample. It is actually a &quot;proxy&quot; to your own custom logic: in this example it reads the TCS3200, in your project it could read an accelerometer or the like.</li>\n<li><code>fit()</code>: this is where the magic happens. With this single line of code you're training the SVM on the training data; when the functions ends, the classifier will have updated its internal state with the coefficients it needs to classify new samples</li>\n</ul>\n<h2>Predict</h2>\n<p>ColorClassificationTrainingExample.ino</p>\n<pre><code class=\"language-c\">else if (command == &quot;predict&quot;) {\n        int label;\n        float x[FEATURES_DIM];\n\n        getFeatures(x);\n        Serial.print(&quot;Predicted label is &quot;);\n        Serial.println(classifier.predict(X_train, x));\n    }</code></pre>\n<p>Now that our classifier has been trained, we can finally make use of it to classify new samples.</p>\n<p>As easy as it can be, you just call its <code>predict</code> method.</p>\n<div class=\"infobox\">As you can see, the <code>predict</code> method requires the <code>X_train</code> matrix other than the new sample vector</div>\n<p>And that's it: you can now complete your Machine learning task on your microcontroller from start to end, without the need of a PC.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<hr />\n<p>Check the full project code on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/ColorClassificationTrainingExample/ColorClassificationTrainingExample.ino\">Github</a></p>\n<hr />\n<h2>Full example</h2>\n<p>ColorClassificationTrainingExample.ino</p>\n<pre><code class=\"language-c\">#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;RGB.h&quot;\n\n#define MAX_TRAINING_SAMPLES 20\n#define FEATURES_DIM 3\n\nusing namespace Eloquent::ML;\n\nint numSamples;\nRGB rgb(2, 3, 4);\nfloat X_train[MAX_TRAINING_SAMPLES][FEATURES_DIM];\nint y_train[MAX_TRAINING_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);\n\nvoid setup() {\n    Serial.begin(115200);\n    rgb.begin();\n\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}\n\nvoid loop() {\n    if (!Serial.available()) {\n        delay(100);\n        return;\n    }\n\n    String command = Serial.readStringUntil(&#039;\\n&#039;);\n\n    if (command == &quot;help&quot;) {\n        Serial.println(&quot;Available commands:&quot;);\n        Serial.println(&quot;\\tfit: train the classifier on a new set of samples&quot;);\n        Serial.println(&quot;\\tpredict: classify a new sample&quot;);\n        Serial.println(&quot;\\tinspect: print X_train and y_train&quot;);\n    }\n    else if (command == &quot;fit&quot;) {\n        Serial.print(&quot;How many samples will you record? &quot;);\n        numSamples = readSerialNumber();\n\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(i + 1);\n            Serial.print(&quot;/&quot;);\n            Serial.print(numSamples);\n            Serial.println(&quot; Which class does the sample belongs to, 1 or -1?&quot;);\n            y_train[i] = readSerialNumber() &gt; 0 ? 1 : -1;\n            getFeatures(X_train[i]);\n        }\n\n        Serial.print(&quot;Start training... &quot;);\n        classifier.fit(X_train, y_train, numSamples);\n        Serial.println(&quot;Done&quot;);\n    }\n    else if (command == &quot;predict&quot;) {\n        int label;\n        float x[FEATURES_DIM];\n\n        getFeatures(x);\n        Serial.print(&quot;Predicted label is &quot;);\n        Serial.println(classifier.predict(X_train, x));\n    }\n    else if (command == &quot;inspect&quot;) {\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(&quot;[&quot;);\n            Serial.print(y_train[i]);\n            Serial.print(&quot;] &quot;);\n\n            for (int j = 0; j &lt; FEATURES_DIM; j++) {\n                Serial.print(X_train[i][j]);\n                Serial.print(&quot;, &quot;);\n            }\n\n            Serial.println();\n        }\n    }\n}\n\n/**\n *\n * @return\n */\nint readSerialNumber() {\n    while (!Serial.available()) delay(1);\n\n    return Serial.readStringUntil(&#039;\\n&#039;).toInt();\n}\n\n/**\n * Get features for new sample\n * @param x\n */\nvoid getFeatures(float x[FEATURES_DIM]) {\n    rgb.read(x);\n\n    for (int i = 0; i &lt; FEATURES_DIM; i++) {\n        Serial.print(x[i]);\n        Serial.print(&quot;, &quot;);\n    }\n\n    Serial.println();\n}</code></pre>\n<p>RGB.h</p>\n<pre><code class=\"language-c\">#pragma once\n\n/**\n * Wrapper for RGB color sensor\n */\nclass RGB {\n    public:\n        RGB(uint8_t s2, uint8_t s3, uint8_t out) :\n            _s2(s2),\n            _s3(s3),\n            _out(out) {\n\n        }\n\n        /**\n         *\n         */\n        void begin() {\n            pinMode(_s2, OUTPUT);\n            pinMode(_s3, OUTPUT);\n            pinMode(_out, INPUT);\n        }\n\n        /**\n         *\n         * @param x\n         */\n        void read(float x[3]) {\n            x[0] = readComponent(LOW, LOW);\n            x[1] = readComponent(HIGH, HIGH);\n            x[2] = readComponent(LOW, HIGH);\n        }\n\n    protected:\n        uint8_t _s2;\n        uint8_t _s3;\n        uint8_t _out;\n\n        /**\n         *\n         * @param s2\n         * @param s3\n         * @return\n         */\n        int readComponent(bool s2, bool s3) {\n            delay(10);\n            digitalWrite(_s2, s2);\n            digitalWrite(_s3, s3);\n\n            return pulseIn(_out, LOW);\n        }\n};</code></pre>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/03/how-to-train-a-color-classification-machine-learning-classifier-directly-on-your-arduino-board/\">How to train a color classification Machine learning classifier directly on your Arduino board</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "In the previous post we learnt it is possible to train a Machine learning classifier directly on a microcontroller. In this post we'll look into how to do it to classify colors.\n\nThis will be an hands-on guide, so let's walk throughout each step you need to complete to run the example. \nI setup this very example as a basis for your future projects, so you can easily swap the color classification task for any other one you could think of.\nDefinitions\n#ifdef ESP32\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n#define abs(x) ((x) &gt; 0 ? (x) : -(x))\n#endif\n\n#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;RGB.h&quot;\n\n#define MAX_TRAINING_SAMPLES 20\n#define FEATURES_DIM 3\n\nusing namespace Eloquent::ML;\n\nint numSamples;\nRGB rgb(2, 3, 4);\nfloat X_train[MAX_TRAINING_SAMPLES][FEATURES_DIM];\nint y_train[MAX_TRAINING_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);\nWhen training a classifier on your microcontroller there are some things that are mandatory:\n\n#include &lt;EloquentSVMSMO.h&gt;: this is the library that implements the SVM learning algorithm\nX_train: this is a matrix where each row represents a training sample. You will need to keep this data always with you, since it's required also during the inference\ny_train: this array contains, for each training sample, the class it belongs to: 1 or -1\nlinearKernel: this is the kernel function for the SVM classifier (you can read more here). You can pass your own kernel other than linear (for example poly or rbf)\n\nIn this specific example, we're using the RGB class to handle the TCS3200 sensor reading, but this will change based on the dataset you want to train on. Also, since our features are going to be the R, G and B components of a color, FEATURES_DIM is set to 3.\nSetup\nvoid setup() {\n    Serial.begin(115200);\n    rgb.begin();\n\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}\nThe setup does not contain any logic really. You can use this part to configure the parameters of the classifier:\n\nC: &quot;The C parameter tells the SVM optimization how much you want to avoid misclassifying each training example. For large values of C, the optimization will choose a smaller-margin hyperplane if that hyperplane does a better job of getting all the training points classified correctly. Conversely, a very small value of C will cause the optimizer to look for a larger-margin separating hyperplane, even if that hyperplane misclassifies more points&quot; (quoted from stackexchange)\ntol: &quot;The tol parameter is a setting for the SVM's tolerance in optimization. Recall that yi(xi.w+b)-1 &gt;= 0. For an SVM to be valid, all values must be greater than or equal to 0, and at least one value on each side needs to be &quot;equal&quot; to 0, which will be your support vectors. Since it is highly unlikely that you will actually get values equal perfectly to 0, you set tolerance to allow a bit of wiggle room.&quot; (quoted from pythonprogramming)\nmaxIter: set an upper bound to the number of iterations the algorithm can take to converge\npasses: max # of times to iterate over \u03b1\u2019s without changing\nalphaTol: alfpha coefficients determine which samples from the training set are to be considered support vectors and so be included during the inference procedure. This value discards support vectors with an alpha too small to be noticeable.\n\nFit\nelse if (command == &quot;fit&quot;) {\n        Serial.print(&quot;How many samples will you record? &quot;);\n        numSamples = readSerialNumber();\n\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(i + 1);\n            Serial.print(&quot;/&quot;);\n            Serial.print(numSamples);\n            Serial.println(&quot; Which class does the sample belongs to, 1 or -1?&quot;);\n            y_train[i] = readSerialNumber() &gt; 0 ? 1 : -1;\n            getFeatures(X_train[i]);\n        }\n\n        Serial.print(&quot;Start training... &quot;);\n        classifier.fit(X_train, y_train, numSamples);\n        Serial.println(&quot;Done&quot;);\n    }\nThis is the core of the project. Here we are loading the samples to train our classifier &quot;live&quot; on the board.\nSince this is an interactive demo, the program prompts us to define how many samples we'll load and, one by one, which class they belong to.\nNow there are a few important things to keep in mind:\n\nnumSamples: sadly, C has no easy way to know the size of an array, so we have to be explicit about it. To train the classifier, it is mandatory that you do know I many samples you're passing to it\ngetFeatures() is the function that reads the training sample. It is actually a &quot;proxy&quot; to your own custom logic: in this example it reads the TCS3200, in your project it could read an accelerometer or the like.\nfit(): this is where the magic happens. With this single line of code you're training the SVM on the training data; when the functions ends, the classifier will have updated its internal state with the coefficients it needs to classify new samples\n\nPredict\nColorClassificationTrainingExample.ino\nelse if (command == &quot;predict&quot;) {\n        int label;\n        float x[FEATURES_DIM];\n\n        getFeatures(x);\n        Serial.print(&quot;Predicted label is &quot;);\n        Serial.println(classifier.predict(X_train, x));\n    }\nNow that our classifier has been trained, we can finally make use of it to classify new samples.\nAs easy as it can be, you just call its predict method.\nAs you can see, the predict method requires the X_train matrix other than the new sample vector\nAnd that's it: you can now complete your Machine learning task on your microcontroller from start to end, without the need of a PC.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n\nCheck the full project code on Github\n\nFull example\nColorClassificationTrainingExample.ino\n#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;RGB.h&quot;\n\n#define MAX_TRAINING_SAMPLES 20\n#define FEATURES_DIM 3\n\nusing namespace Eloquent::ML;\n\nint numSamples;\nRGB rgb(2, 3, 4);\nfloat X_train[MAX_TRAINING_SAMPLES][FEATURES_DIM];\nint y_train[MAX_TRAINING_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);\n\nvoid setup() {\n    Serial.begin(115200);\n    rgb.begin();\n\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}\n\nvoid loop() {\n    if (!Serial.available()) {\n        delay(100);\n        return;\n    }\n\n    String command = Serial.readStringUntil(&#039;\\n&#039;);\n\n    if (command == &quot;help&quot;) {\n        Serial.println(&quot;Available commands:&quot;);\n        Serial.println(&quot;\\tfit: train the classifier on a new set of samples&quot;);\n        Serial.println(&quot;\\tpredict: classify a new sample&quot;);\n        Serial.println(&quot;\\tinspect: print X_train and y_train&quot;);\n    }\n    else if (command == &quot;fit&quot;) {\n        Serial.print(&quot;How many samples will you record? &quot;);\n        numSamples = readSerialNumber();\n\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(i + 1);\n            Serial.print(&quot;/&quot;);\n            Serial.print(numSamples);\n            Serial.println(&quot; Which class does the sample belongs to, 1 or -1?&quot;);\n            y_train[i] = readSerialNumber() &gt; 0 ? 1 : -1;\n            getFeatures(X_train[i]);\n        }\n\n        Serial.print(&quot;Start training... &quot;);\n        classifier.fit(X_train, y_train, numSamples);\n        Serial.println(&quot;Done&quot;);\n    }\n    else if (command == &quot;predict&quot;) {\n        int label;\n        float x[FEATURES_DIM];\n\n        getFeatures(x);\n        Serial.print(&quot;Predicted label is &quot;);\n        Serial.println(classifier.predict(X_train, x));\n    }\n    else if (command == &quot;inspect&quot;) {\n        for (int i = 0; i &lt; numSamples; i++) {\n            Serial.print(&quot;[&quot;);\n            Serial.print(y_train[i]);\n            Serial.print(&quot;] &quot;);\n\n            for (int j = 0; j &lt; FEATURES_DIM; j++) {\n                Serial.print(X_train[i][j]);\n                Serial.print(&quot;, &quot;);\n            }\n\n            Serial.println();\n        }\n    }\n}\n\n/**\n *\n * @return\n */\nint readSerialNumber() {\n    while (!Serial.available()) delay(1);\n\n    return Serial.readStringUntil(&#039;\\n&#039;).toInt();\n}\n\n/**\n * Get features for new sample\n * @param x\n */\nvoid getFeatures(float x[FEATURES_DIM]) {\n    rgb.read(x);\n\n    for (int i = 0; i &lt; FEATURES_DIM; i++) {\n        Serial.print(x[i]);\n        Serial.print(&quot;, &quot;);\n    }\n\n    Serial.println();\n}\nRGB.h\n#pragma once\n\n/**\n * Wrapper for RGB color sensor\n */\nclass RGB {\n    public:\n        RGB(uint8_t s2, uint8_t s3, uint8_t out) :\n            _s2(s2),\n            _s3(s3),\n            _out(out) {\n\n        }\n\n        /**\n         *\n         */\n        void begin() {\n            pinMode(_s2, OUTPUT);\n            pinMode(_s3, OUTPUT);\n            pinMode(_out, INPUT);\n        }\n\n        /**\n         *\n         * @param x\n         */\n        void read(float x[3]) {\n            x[0] = readComponent(LOW, LOW);\n            x[1] = readComponent(HIGH, HIGH);\n            x[2] = readComponent(LOW, HIGH);\n        }\n\n    protected:\n        uint8_t _s2;\n        uint8_t _s3;\n        uint8_t _out;\n\n        /**\n         *\n         * @param s2\n         * @param s3\n         * @return\n         */\n        int readComponent(bool s2, bool s3) {\n            delay(10);\n            digitalWrite(_s2, s2);\n            digitalWrite(_s3, s3);\n\n            return pulseIn(_out, LOW);\n        }\n};\nL'articolo How to train a color classification Machine learning classifier directly on your Arduino board proviene da Eloquent Arduino Blog.",
            "date_published": "2020-03-28T20:02:53+01:00",
            "date_modified": "2020-04-05T19:01:49+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "microml",
                "Arduino Machine learning",
                "Programming"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=1008",
            "url": "https://eloquentarduino.github.io/2020/03/how-to-train-a-iris-classification-machine-learning-classifier-directly-on-your-arduino-board/",
            "title": "How to train a IRIS classification Machine learning classifier directly on your Arduino board",
            "content_html": "<p>In this hands-on guide about <a href=\"/2020/03/so-you-want-to-train-an-ml-classifier-directly-on-an-arduino-board\">on-board SVM training</a> we're going to see a classifier in action, training it on the Iris dataset and evaluating its performance.</p>\n<p><span id=\"more-1008\"></span></p>\n<h2>What we'll make</h2>\n<p>In this demo project we're going to take a know dataset (<a href=\"https://en.wikipedia.org/wiki/Iris_flower_data_set\">iris flowers</a>) and interactively train an SVM classifier on it, adjusting the number of samples to see the effects on both training time, inference time and accuracy.</p>\n<h2>Definitions</h2>\n<pre><code class=\"language-c\">#ifdef ESP32\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n#define abs(x) ((x) &gt; 0 ? (x) : -(x))\n#endif\n\n#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;iris.h&quot;\n\n#define TOTAL_SAMPLES (POSITIVE_SAMPLES + NEGATIVE_SAMPLES)\n\nusing namespace Eloquent::ML;\n\nfloat X_train[TOTAL_SAMPLES][FEATURES_DIM];\nfloat X_test[TOTAL_SAMPLES][FEATURES_DIM];\nint y_train[TOTAL_SAMPLES];\nint y_test[TOTAL_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);</code></pre>\n<p>First of all we need to include a couple files, namely <code>EloquentSVMSMO.h</code> for the SVM classifier and <code>iris.h</code> for the dataset.</p>\n<p><code>iris.h</code> defines a couple constants:</p>\n<ul>\n<li><code>FEATURES_DIM</code>: the number of features each sample has (4 in this case)</li>\n<li><code>POSITIVE_SAMPLES</code>: the number of samples that belong to the positive class (50)</li>\n<li><code>NEGATIVE_SAMPLES</code>: the number of samples that belong to the negative class (50)</li>\n</ul>\n<p>The we declare the array that hold the data: <code>X_train</code> and <code>y_train</code> for the training process, <code>X_test</code> and <code>y_test</code> for the inference process.</p>\n<h2>Setup</h2>\n<pre><code class=\"language-c\">void setup() {\n    Serial.begin(115200);\n    delay(5000);\n\n    // configure classifier\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}</code></pre>\n<p>Here we just set a few parameters for the classifier. You could actually skip this step in this demo, since the defaults will work well. Those lines are there so you know you can tweak them, if needed.</p>\n<p>Please refer to the <a href=\"/2020/03/how-to-train-a-color-classification-machine-learning-classifier-directly-on-your-arduino-board\">demo for color classification</a> for an explanation of each parameter.</p>\n<h2>Interactivity</h2>\n<pre><code class=\"language-c\">void loop() {\n    int positiveSamples = readSerialNumber(&quot;How many positive samples will you use for training? &quot;, POSITIVE_SAMPLES);\n\n    if (positiveSamples &gt; POSITIVE_SAMPLES - 1) {\n        Serial.println(&quot;Too many positive samples entered. All but one will be used instead&quot;);\n        positiveSamples = POSITIVE_SAMPLES - 1;\n    }\n\n    int negativeSamples = readSerialNumber(&quot;How many negative samples will you use for training? &quot;, NEGATIVE_SAMPLES);\n\n    if (negativeSamples &gt; NEGATIVE_SAMPLES - 1) {\n        Serial.println(&quot;Too many negative samples entered. All but one will be used instead&quot;);\n        negativeSamples = NEGATIVE_SAMPLES - 1;\n    }\n\n    loadDataset(positiveSamples, negativeSamples);\n\n    // ...\n}\n\n/**\n * Ask the user to enter a numeric value\n */\nint readSerialNumber(String prompt, int maxAllowed) {\n    Serial.print(prompt);\n    Serial.print(&quot; (&quot;);\n    Serial.print(maxAllowed);\n    Serial.print(&quot; max) &quot;);\n\n    while (!Serial.available()) delay(1);\n\n    int n = Serial.readStringUntil(&#039;\\n&#039;).toInt();\n\n    Serial.println(n);\n\n    return n;\n}\n\n/**\n * Divide training and test data\n */\nvoid loadDataset(int positiveSamples, int negativeSamples) {\n    int positiveTestSamples = POSITIVE_SAMPLES - positiveSamples;\n\n    for (int i = 0; i &lt; positiveSamples; i++) {\n        memcpy(X_train[i], X_positive[i], FEATURES_DIM);\n        y_train[i] = 1;\n    }\n\n    for (int i = 0; i &lt; negativeSamples; i++) {\n        memcpy(X_train[i + positiveSamples], X_negative[i], FEATURES_DIM);\n        y_train[i + positiveSamples] = -1;\n    }\n\n    for (int i = 0; i &lt; positiveTestSamples; i++) {\n        memcpy(X_test[i], X_positive[i + positiveSamples], FEATURES_DIM);\n        y_test[i] = 1;\n    }\n\n    for (int i = 0; i &lt; NEGATIVE_SAMPLES - negativeSamples; i++) {\n        memcpy(X_test[i + positiveTestSamples], X_negative[i + negativeSamples], FEATURES_DIM);\n        y_test[i + positiveTestSamples] = -1;\n    }\n}</code></pre>\n<p>The code above is a preliminary step where you're asked to enter how many samples you will use for training of both positive and negative classes.</p>\n<p>This way you can have multiple run of benchmarking without the need to re-compile and re-upload the sketch.</p>\n<p>It also shows that the training process can be &quot;dynamic&quot;, in the sense that you can tweak it at runtime as per your need.</p>\n<h2>Training</h2>\n<pre><code class=\"language-c\">time_t start = millis();\nclassifier.fit(X_train, y_train, positiveSamples + negativeSamples);\nSerial.print(&quot;It took &quot;);\nSerial.print(millis() - start);\nSerial.print(&quot;ms to train on &quot;);\nSerial.print(positiveSamples + negativeSamples);\nSerial.println(&quot; samples&quot;);</code></pre>\n<p>Training is actually a one line operation. Here we'll also logging how much time it takes to train.</p>\n<h3>Predicting</h3>\n<pre><code class=\"language-c\">void loop() {\n    // ...\n\n    int tp = 0;\n    int tn = 0;\n    int fp = 0;\n    int fn = 0;\n\n    start = millis();\n\n    for (int i = 0; i &lt; TOTAL_SAMPLES - positiveSamples - negativeSamples; i++) {\n        int y_pred = classifier.predict(X_train, X_test[i]);\n        int y_true = y_test[i];\n\n        if (y_pred == y_true &amp;&amp; y_pred ==  1) tp += 1;\n        if (y_pred == y_true &amp;&amp; y_pred == -1) tn += 1;\n        if (y_pred != y_true &amp;&amp; y_pred ==  1) fp += 1;\n        if (y_pred != y_true &amp;&amp; y_pred == -1) fn += 1;\n    }\n\n    Serial.print(&quot;It took &quot;);\n    Serial.print(millis() - start);\n    Serial.print(&quot;ms to test on &quot;);\n    Serial.print(TOTAL_SAMPLES - positiveSamples - negativeSamples);\n    Serial.println(&quot; samples&quot;);\n\n    printConfusionMatrix(tp, tn, fp, fn);\n}\n\n/**\n * Dump confusion matrix to Serial monitor\n */\nvoid printConfusionMatrix(int tp, int tn, int fp, int fn) {\n    Serial.print(&quot;Overall accuracy &quot;);\n    Serial.print(100.0 * (tp + tn) / (tp + tn + fp + fn));\n    Serial.println(&quot;%&quot;);\n    Serial.println(&quot;Confusion matrix&quot;);\n    Serial.print(&quot;          | Predicted 1 | Predicted -1 |\\n&quot;);\n    Serial.print(&quot;----------------------------------------\\n&quot;);\n    Serial.print(&quot;Actual  1 |      &quot;);\n    Serial.print(tp);\n    Serial.print(&quot;     |      &quot;);\n    Serial.print(fn);\n    Serial.print(&quot;       |\\n&quot;);\n    Serial.print(&quot;----------------------------------------\\n&quot;);\n    Serial.print(&quot;Actual -1 |      &quot;);\n    Serial.print(fp);\n    Serial.print(&quot;      |      &quot;);\n    Serial.print(tn);\n    Serial.print(&quot;       |\\n&quot;);\n    Serial.print(&quot;----------------------------------------\\n\\n\\n&quot;);\n}</code></pre>\n<p>Finally we can run the classification on our test set and get the overall accuracy.</p>\n<p>We also print the <a href=\"https://en.wikipedia.org/wiki/Confusion_matrix\">confusion matrix</a> to double-check each class accuracy.</p>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<hr />\n<p>Check the full project code on <a href=\"https://github.com/eloquentarduino/EloquentMicroML/blob/master/examples/IrisClassificationTrainingExample/IrisClassificationTrainingExample.ino\">Github</a> where you'll also find another dataset to test, which is characterized by a number of features much higher (30 instead of 4).</p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/03/how-to-train-a-iris-classification-machine-learning-classifier-directly-on-your-arduino-board/\">How to train a IRIS classification Machine learning classifier directly on your Arduino board</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "In this hands-on guide about on-board SVM training we're going to see a classifier in action, training it on the Iris dataset and evaluating its performance.\n\nWhat we'll make\nIn this demo project we're going to take a know dataset (iris flowers) and interactively train an SVM classifier on it, adjusting the number of samples to see the effects on both training time, inference time and accuracy.\nDefinitions\n#ifdef ESP32\n#define min(a, b) (a) &lt; (b) ? (a) : (b)\n#define max(a, b) (a) &gt; (b) ? (a) : (b)\n#define abs(x) ((x) &gt; 0 ? (x) : -(x))\n#endif\n\n#include &lt;EloquentSVMSMO.h&gt;\n#include &quot;iris.h&quot;\n\n#define TOTAL_SAMPLES (POSITIVE_SAMPLES + NEGATIVE_SAMPLES)\n\nusing namespace Eloquent::ML;\n\nfloat X_train[TOTAL_SAMPLES][FEATURES_DIM];\nfloat X_test[TOTAL_SAMPLES][FEATURES_DIM];\nint y_train[TOTAL_SAMPLES];\nint y_test[TOTAL_SAMPLES];\nSVMSMO&lt;FEATURES_DIM&gt; classifier(linearKernel);\nFirst of all we need to include a couple files, namely EloquentSVMSMO.h for the SVM classifier and iris.h for the dataset.\niris.h defines a couple constants:\n\nFEATURES_DIM: the number of features each sample has (4 in this case)\nPOSITIVE_SAMPLES: the number of samples that belong to the positive class (50)\nNEGATIVE_SAMPLES: the number of samples that belong to the negative class (50)\n\nThe we declare the array that hold the data: X_train and y_train for the training process, X_test and y_test for the inference process.\nSetup\nvoid setup() {\n    Serial.begin(115200);\n    delay(5000);\n\n    // configure classifier\n    classifier.setC(5);\n    classifier.setTol(1e-5);\n    classifier.setMaxIter(10000);\n}\nHere we just set a few parameters for the classifier. You could actually skip this step in this demo, since the defaults will work well. Those lines are there so you know you can tweak them, if needed.\nPlease refer to the demo for color classification for an explanation of each parameter.\nInteractivity\nvoid loop() {\n    int positiveSamples = readSerialNumber(&quot;How many positive samples will you use for training? &quot;, POSITIVE_SAMPLES);\n\n    if (positiveSamples &gt; POSITIVE_SAMPLES - 1) {\n        Serial.println(&quot;Too many positive samples entered. All but one will be used instead&quot;);\n        positiveSamples = POSITIVE_SAMPLES - 1;\n    }\n\n    int negativeSamples = readSerialNumber(&quot;How many negative samples will you use for training? &quot;, NEGATIVE_SAMPLES);\n\n    if (negativeSamples &gt; NEGATIVE_SAMPLES - 1) {\n        Serial.println(&quot;Too many negative samples entered. All but one will be used instead&quot;);\n        negativeSamples = NEGATIVE_SAMPLES - 1;\n    }\n\n    loadDataset(positiveSamples, negativeSamples);\n\n    // ...\n}\n\n/**\n * Ask the user to enter a numeric value\n */\nint readSerialNumber(String prompt, int maxAllowed) {\n    Serial.print(prompt);\n    Serial.print(&quot; (&quot;);\n    Serial.print(maxAllowed);\n    Serial.print(&quot; max) &quot;);\n\n    while (!Serial.available()) delay(1);\n\n    int n = Serial.readStringUntil(&#039;\\n&#039;).toInt();\n\n    Serial.println(n);\n\n    return n;\n}\n\n/**\n * Divide training and test data\n */\nvoid loadDataset(int positiveSamples, int negativeSamples) {\n    int positiveTestSamples = POSITIVE_SAMPLES - positiveSamples;\n\n    for (int i = 0; i &lt; positiveSamples; i++) {\n        memcpy(X_train[i], X_positive[i], FEATURES_DIM);\n        y_train[i] = 1;\n    }\n\n    for (int i = 0; i &lt; negativeSamples; i++) {\n        memcpy(X_train[i + positiveSamples], X_negative[i], FEATURES_DIM);\n        y_train[i + positiveSamples] = -1;\n    }\n\n    for (int i = 0; i &lt; positiveTestSamples; i++) {\n        memcpy(X_test[i], X_positive[i + positiveSamples], FEATURES_DIM);\n        y_test[i] = 1;\n    }\n\n    for (int i = 0; i &lt; NEGATIVE_SAMPLES - negativeSamples; i++) {\n        memcpy(X_test[i + positiveTestSamples], X_negative[i + negativeSamples], FEATURES_DIM);\n        y_test[i + positiveTestSamples] = -1;\n    }\n}\nThe code above is a preliminary step where you're asked to enter how many samples you will use for training of both positive and negative classes.\nThis way you can have multiple run of benchmarking without the need to re-compile and re-upload the sketch.\nIt also shows that the training process can be &quot;dynamic&quot;, in the sense that you can tweak it at runtime as per your need.\nTraining\ntime_t start = millis();\nclassifier.fit(X_train, y_train, positiveSamples + negativeSamples);\nSerial.print(&quot;It took &quot;);\nSerial.print(millis() - start);\nSerial.print(&quot;ms to train on &quot;);\nSerial.print(positiveSamples + negativeSamples);\nSerial.println(&quot; samples&quot;);\nTraining is actually a one line operation. Here we'll also logging how much time it takes to train.\nPredicting\nvoid loop() {\n    // ...\n\n    int tp = 0;\n    int tn = 0;\n    int fp = 0;\n    int fn = 0;\n\n    start = millis();\n\n    for (int i = 0; i &lt; TOTAL_SAMPLES - positiveSamples - negativeSamples; i++) {\n        int y_pred = classifier.predict(X_train, X_test[i]);\n        int y_true = y_test[i];\n\n        if (y_pred == y_true &amp;&amp; y_pred ==  1) tp += 1;\n        if (y_pred == y_true &amp;&amp; y_pred == -1) tn += 1;\n        if (y_pred != y_true &amp;&amp; y_pred ==  1) fp += 1;\n        if (y_pred != y_true &amp;&amp; y_pred == -1) fn += 1;\n    }\n\n    Serial.print(&quot;It took &quot;);\n    Serial.print(millis() - start);\n    Serial.print(&quot;ms to test on &quot;);\n    Serial.print(TOTAL_SAMPLES - positiveSamples - negativeSamples);\n    Serial.println(&quot; samples&quot;);\n\n    printConfusionMatrix(tp, tn, fp, fn);\n}\n\n/**\n * Dump confusion matrix to Serial monitor\n */\nvoid printConfusionMatrix(int tp, int tn, int fp, int fn) {\n    Serial.print(&quot;Overall accuracy &quot;);\n    Serial.print(100.0 * (tp + tn) / (tp + tn + fp + fn));\n    Serial.println(&quot;%&quot;);\n    Serial.println(&quot;Confusion matrix&quot;);\n    Serial.print(&quot;          | Predicted 1 | Predicted -1 |\\n&quot;);\n    Serial.print(&quot;----------------------------------------\\n&quot;);\n    Serial.print(&quot;Actual  1 |      &quot;);\n    Serial.print(tp);\n    Serial.print(&quot;     |      &quot;);\n    Serial.print(fn);\n    Serial.print(&quot;       |\\n&quot;);\n    Serial.print(&quot;----------------------------------------\\n&quot;);\n    Serial.print(&quot;Actual -1 |      &quot;);\n    Serial.print(fp);\n    Serial.print(&quot;      |      &quot;);\n    Serial.print(tn);\n    Serial.print(&quot;       |\\n&quot;);\n    Serial.print(&quot;----------------------------------------\\n\\n\\n&quot;);\n}\nFinally we can run the classification on our test set and get the overall accuracy.\nWe also print the confusion matrix to double-check each class accuracy.\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\n\nCheck the full project code on Github where you'll also find another dataset to test, which is characterized by a number of features much higher (30 instead of 4).\nL'articolo How to train a IRIS classification Machine learning classifier directly on your Arduino board proviene da Eloquent Arduino Blog.",
            "date_published": "2020-03-28T19:02:09+01:00",
            "date_modified": "2020-04-05T19:02:20+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "microml",
                "svm",
                "Arduino Machine learning"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=982",
            "url": "https://eloquentarduino.github.io/2020/03/so-you-want-to-train-an-ml-classifier-directly-on-an-arduino-board/",
            "title": "So you want to train an ML classifier directly on an Arduino board?",
            "content_html": "<p>As of now, we know it is possible to run Machine learning inference on tiny microcontrollers thanks to <a href=\"https://www.tensorflow.org/lite/microcontrollers\">Tensorflow for Micro</a> and my very own library <a href=\"https://github.com/eloquentarduino/micromlgen\">MicroML</a>. What if you could <strong>train</strong> a classifier directly on the microcontroller, too?</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/03/Onboard-IRIS-dataset-training-time.png\" alt=\"Onboard IRIS dataset training time\" /></p>\n<p><span id=\"more-982\"></span></p>\n<p>When I first started this journey in the world of Machine learning on microcontrollers, one fact was set in stone for me: you train your classifier once and for all on a PC, then deploy it to your microcontroller.</p>\n<p>As simple as this.</p>\n<p>Training is a heavy process, requires lots of computations and memory. You just want a machine as powerful as possible to carry out this task as fast as possible.</p>\n<p>Moreover, it is a one-time task: once your classifier has been trained, it needs not to be updated anymore.</p>\n<p>And this yield true until now.</p>\n<p>Until my reader <a href=\"https://github.com/joaocarvalhoopen\">Joao Carvalho</a>, in the comments on the post about <a href=\"/2020/02/even-smaller-machine-learning-models-for-your-mcu/\">an alternative to SVM which produces much smaller models</a> that I strongly invite you to read, challenged me with this idea of running the SVM training directly on the microcontroller. </p>\n<p>In the past I replied <em>&quot;No way&quot;</em> to people asking about this topic on forums, but Joao was so kind to link me a <a href=\"https://github.com/karpathy/svmjs/blob/master/lib/svm.js\">Javascript implementation</a> of the <a href=\"https://github.com/karpathy/svmjs/blob/master/test/smo.pdf\">simplified SVM SMO (Sequential Minimal Optimization) algorithm</a>.</p>\n<p>At a first glance it looked quite easy to port from Javascript to C, so I gave it a try.</p>\n<p>And in fact it only took me 30 minutes to get it working on my PC.</p>\n<p>Then I deployed it to my ESP32 and... <strong>it worked</strong>!</p>\n<p>My first try was with 10 samples from the the IRIS dataset: it only took almost no time to train.</p>\n<p>But I know SVM training and inferencing time grows rapidly with the number of training samples.</p>\n<p>Execution time will be the most limiting factor for this kind of task, so I created a benchmarking setup to evaluate the performance of the algorithm on different dataset sizes and features dimensions.<br />\nThe results are summarized in the following table and plots.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center;\">Features size</th>\n<th style=\"text-align: center;\">Training size</th>\n<th style=\"text-align: center;\">Training time (ms)</th>\n<th style=\"text-align: center;\">Unit inference time (ms)</th>\n<th style=\"text-align: center;\">Accuracy</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center;\">4</td>\n<td style=\"text-align: center;\">10</td>\n<td style=\"text-align: center;\">0</td>\n<td style=\"text-align: center;\">0,011</td>\n<td style=\"text-align: center;\">80</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">4</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: center;\">4</td>\n<td style=\"text-align: center;\">0,013</td>\n<td style=\"text-align: center;\">85</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">4</td>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">11</td>\n<td style=\"text-align: center;\">0,014</td>\n<td style=\"text-align: center;\">90</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">4</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: center;\">38</td>\n<td style=\"text-align: center;\">0,017</td>\n<td style=\"text-align: center;\">91</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">4</td>\n<td style=\"text-align: center;\">50</td>\n<td style=\"text-align: center;\">47</td>\n<td style=\"text-align: center;\">0,020</td>\n<td style=\"text-align: center;\">86</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">4</td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: center;\">80</td>\n<td style=\"text-align: center;\">0,025</td>\n<td style=\"text-align: center;\">87</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">10</td>\n<td style=\"text-align: center;\">22</td>\n<td style=\"text-align: center;\">0,014</td>\n<td style=\"text-align: center;\">71</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">20</td>\n<td style=\"text-align: center;\">1000</td>\n<td style=\"text-align: center;\">0,017</td>\n<td style=\"text-align: center;\">61</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">3500</td>\n<td style=\"text-align: center;\">0,020</td>\n<td style=\"text-align: center;\">66</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">40</td>\n<td style=\"text-align: center;\">20000</td>\n<td style=\"text-align: center;\">0,025</td>\n<td style=\"text-align: center;\">85</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">50</td>\n<td style=\"text-align: center;\">32800</td>\n<td style=\"text-align: center;\">0,033</td>\n<td style=\"text-align: center;\">83</td>\n</tr>\n<tr>\n<td style=\"text-align: center;\">30</td>\n<td style=\"text-align: center;\">60</td>\n<td style=\"text-align: center;\">71400</td>\n<td style=\"text-align: center;\">0,050</td>\n<td style=\"text-align: center;\">80</td>\n</tr>\n</tbody>\n</table>\n<p><small>* all benchmark are obtained on an ESP32 board</small><br />\n<small>** the inference took actually sometimes less than 1ms to run for all the test samples, so it was rounded to 1ms and divided by the number of samples</small></p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/03/Onboard-IRIS-dataset-training-time.png\" alt=\"Onboard IRIS dataset training time. Features dim = 4\" /></p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/03/Onboard-Breast-cancer-dataset-training-time.png\" alt=\"Onboard Breast cancer dataset training time. Features dim = 30\" /></p>\n<p>We can see from the table that for the Iris dataset, which has 4-dimensional features, the training process is quite fast: 80ms to train on 60 samples.</p>\n<p>Things become much different when training on the Breast cancer dataset, with its 30 features per sample. Now we're talking abouts <em>seconds</em> to train and even minutes when increasing the number of samples to 60.</p>\n<p>Fortunately the inference time stays almost flat, so you will have real-time predictions.</p>\n<div class=\"watchout\">I run the Iris benchmark on a Seeedstudio Xiao M0 board (32bit 48MHz processor), too. It took 7s to train on 60 samples vs 80ms it took on the ESP32. It is clear some boards are better than others for this task</div>\n<!-- Begin Mailchimp Signup Form -->\r\n<div id=\"mc_embed_signup\">\r\n<form action=\"https://github.us4.list-manage.com/subscribe/post?u=f0eaedd94d554cf2ee781742a&id=37d3496031\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\r\n    <div id=\"mc_embed_signup_scroll\">\r\n\t<h2 style=\"margin: 0; text-align: center\">Finding this content useful?</h2>\r\n<div class=\"mc-field-group\">\r\n\t<input type=\"email\" value=\"\" name=\"EMAIL\" class=\"required email\" id=\"mce-EMAIL\" placeholder=\"join the monthly newsletter\">\r\n</div>\r\n\t<div id=\"mce-responses\" class=\"clear\">\r\n\t\t<div class=\"response\" id=\"mce-error-response\" style=\"display:none\"></div>\r\n\t\t<div class=\"response\" id=\"mce-success-response\" style=\"display:none\"></div>\r\n\t</div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\r\n    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_f0eaedd94d554cf2ee781742a_37d3496031\" tabindex=\"-1\" value=\"\"></div>\r\n    <div class=\"clear\" style=\"position: relative; top: 8px\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\r\n    </div>\r\n</form>\r\n</div>\r\n\r\n<!--End mc_embed_signup-->\n<h2>Downsides</h2>\n<p>Of course there're downsides: it's not a perfect world.</p>\n<h3>Convergence</h3>\n<div class=\"watchout\">\nAs <a href=\"http://cs229.stanford.edu/materials/smo.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">the paper</a> reported: \"there is one thing to note, <b>the algorithm (the simplified version) is not guaranteed to converge\".</b>\n</div>\n<p>I actually don't know, in practice, what this means. But it sounds like a bad thing.</p>\n<h3>Binary classification only</h3>\n<p>As of now this algorithm can only do binary classification.</p>\n<p>I hope to implement multi-class classification in the future with the one-vs-all approach, but I don't really know if it would be too inefficient for a microcontroller to run.</p>\n<h3>Declining accuracy</h3>\n<p>If you look at the benchmark table above, also, you'll notice the accuracy does not always increase linearly with the training samples size. It seems it reaches an optimum and then starts decreasing.</p>\n<p>If you're going to deploy your device in an autonomous scenario, you'll need to monitor your accucary every time you re-train it, or your results are going to go poor.</p>\n<p>You should keep track of the optimum you achieved and roll-back to its training set when you register a declining accuracy.</p>\n<h3>Memory</h3>\n<p>You will need to keep all your training set in memory for the classifier to both learn and predict. This means RAM will be a limiting factor and we know RAM is an expensive resource on microcontrollers.</p>\n<p>You will have to find a good enough compromise between the number of features, the number of samples and the accuracy.</p>\n<h2>Time to get your hands on</h2>\n<p>I created a sample project for you to <a href=\"/2020/03/how-to-train-a-color-classification-machine-learning-classifier-directly-on-your-arduino-board\">train a color classifier</a> with a super simple setup: you will only need a TCS3200 (color sensor) to follow along.</p>\n<p>Dont' have a TCS3200? No problem, you can <a href=\"/2020/03/how-to-train-a-iris-classification-machine-learning-classifier-directly-on-your-arduino-board\">train a classifier on the IRIS dataset</a></p>\n<p>If you've read so far, please consider letting me know in the comments some useful applications you can think about this new tool. It's a brand new topic for me and I'll appreciate any of your suggestion.</p>\n<hr />\n<p>Check the project repo on <a href=\"https://github.com/eloquentarduino/EloquentMicroML\">Github</a></p>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/03/so-you-want-to-train-an-ml-classifier-directly-on-an-arduino-board/\">So you want to train an ML classifier directly on an Arduino board?</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "As of now, we know it is possible to run Machine learning inference on tiny microcontrollers thanks to Tensorflow for Micro and my very own library MicroML. What if you could train a classifier directly on the microcontroller, too?\n\n\nWhen I first started this journey in the world of Machine learning on microcontrollers, one fact was set in stone for me: you train your classifier once and for all on a PC, then deploy it to your microcontroller.\nAs simple as this.\nTraining is a heavy process, requires lots of computations and memory. You just want a machine as powerful as possible to carry out this task as fast as possible.\nMoreover, it is a one-time task: once your classifier has been trained, it needs not to be updated anymore.\nAnd this yield true until now.\nUntil my reader Joao Carvalho, in the comments on the post about an alternative to SVM which produces much smaller models that I strongly invite you to read, challenged me with this idea of running the SVM training directly on the microcontroller. \nIn the past I replied &quot;No way&quot; to people asking about this topic on forums, but Joao was so kind to link me a Javascript implementation of the simplified SVM SMO (Sequential Minimal Optimization) algorithm.\nAt a first glance it looked quite easy to port from Javascript to C, so I gave it a try.\nAnd in fact it only took me 30 minutes to get it working on my PC.\nThen I deployed it to my ESP32 and... it worked!\nMy first try was with 10 samples from the the IRIS dataset: it only took almost no time to train.\nBut I know SVM training and inferencing time grows rapidly with the number of training samples.\nExecution time will be the most limiting factor for this kind of task, so I created a benchmarking setup to evaluate the performance of the algorithm on different dataset sizes and features dimensions.\nThe results are summarized in the following table and plots.\n\n\n\nFeatures size\nTraining size\nTraining time (ms)\nUnit inference time (ms)\nAccuracy\n\n\n\n\n4\n10\n0\n0,011\n80\n\n\n4\n20\n4\n0,013\n85\n\n\n4\n30\n11\n0,014\n90\n\n\n4\n40\n38\n0,017\n91\n\n\n4\n50\n47\n0,020\n86\n\n\n4\n60\n80\n0,025\n87\n\n\n30\n10\n22\n0,014\n71\n\n\n30\n20\n1000\n0,017\n61\n\n\n30\n30\n3500\n0,020\n66\n\n\n30\n40\n20000\n0,025\n85\n\n\n30\n50\n32800\n0,033\n83\n\n\n30\n60\n71400\n0,050\n80\n\n\n\n* all benchmark are obtained on an ESP32 board\n** the inference took actually sometimes less than 1ms to run for all the test samples, so it was rounded to 1ms and divided by the number of samples\n\n\nWe can see from the table that for the Iris dataset, which has 4-dimensional features, the training process is quite fast: 80ms to train on 60 samples.\nThings become much different when training on the Breast cancer dataset, with its 30 features per sample. Now we're talking abouts seconds to train and even minutes when increasing the number of samples to 60.\nFortunately the inference time stays almost flat, so you will have real-time predictions.\nI run the Iris benchmark on a Seeedstudio Xiao M0 board (32bit 48MHz processor), too. It took 7s to train on 60 samples vs 80ms it took on the ESP32. It is clear some boards are better than others for this task\n\r\n\r\n\r\n    \r\n\tFinding this content useful?\r\n\r\n\t\r\n\r\n\t\r\n\t\t\r\n\t\t\r\n\t    \r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\nDownsides\nOf course there're downsides: it's not a perfect world.\nConvergence\n\nAs the paper reported: \"there is one thing to note, the algorithm (the simplified version) is not guaranteed to converge\".\n\nI actually don't know, in practice, what this means. But it sounds like a bad thing.\nBinary classification only\nAs of now this algorithm can only do binary classification.\nI hope to implement multi-class classification in the future with the one-vs-all approach, but I don't really know if it would be too inefficient for a microcontroller to run.\nDeclining accuracy\nIf you look at the benchmark table above, also, you'll notice the accuracy does not always increase linearly with the training samples size. It seems it reaches an optimum and then starts decreasing.\nIf you're going to deploy your device in an autonomous scenario, you'll need to monitor your accucary every time you re-train it, or your results are going to go poor.\nYou should keep track of the optimum you achieved and roll-back to its training set when you register a declining accuracy.\nMemory\nYou will need to keep all your training set in memory for the classifier to both learn and predict. This means RAM will be a limiting factor and we know RAM is an expensive resource on microcontrollers.\nYou will have to find a good enough compromise between the number of features, the number of samples and the accuracy.\nTime to get your hands on\nI created a sample project for you to train a color classifier with a super simple setup: you will only need a TCS3200 (color sensor) to follow along.\nDont' have a TCS3200? No problem, you can train a classifier on the IRIS dataset\nIf you've read so far, please consider letting me know in the comments some useful applications you can think about this new tool. It's a brand new topic for me and I'll appreciate any of your suggestion.\n\nCheck the project repo on Github\nL'articolo So you want to train an ML classifier directly on an Arduino board? proviene da Eloquent Arduino Blog.",
            "date_published": "2020-03-28T18:03:35+01:00",
            "date_modified": "2020-05-01T11:06:05+02:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "microml",
                "Arduino Machine learning",
                "Programming"
            ]
        },
        {
            "id": "https://eloquentarduino.github.io/?p=956",
            "url": "https://eloquentarduino.github.io/2020/02/easy-arduino-thermal-camera-with-ascii-video-streaming/",
            "title": "Easy Arduino thermal camera with (ASCII) video streaming",
            "content_html": "<p>Ever wanted to use your thermal camera with Arduino but found it difficult to go beyond the tutorials code? Let's see the easiest possible way to view your thermal camera streaming without an LCD display!</p>\n<p><img src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/02/thermal-image-rgb-vs-ascii.jpg\" alt=\"Arduino thermal image rgb vs ascii\" /></p>\n<p><span id=\"more-956\"></span></p>\n<h2>MLX90640 thermal camera</h2>\n<p>For Arduino there are essentially two thermal camera available: the AMG8833 and the MLX90640.</p>\n<p>The AMG8833 is 8x8 and the MLX90640 is 32x24.</p>\n<p>They're not cheap, it is true.</p>\n<p>But if you have to spend money, I strongly advise you to buy the MLX90640: I have one and it's not that accurate. I can't imagine how low definition would be the AMG8833.</p>\n<p>If you want to actually get something meaningful from the camera, the AMG8833 won't give you any good results.</p>\n<p>Sure, you can do interpolation: interpolation would give you <em>the impression</em> you have a better definition, but you're just &quot;inventing&quot; values you don't actually have.</p>\n<p>For demo projects it could be enough. But for any serious application, spend 20$ more and buy an MLX90640.</p>\n<h2>MLX90640 eloquent library</h2>\n<p>As you may know if you read <a href=\"/2019/11/how-to-write-clean-arduino-code/\">my previous posts</a>, I strongly believe in &quot;eloquent&quot; code, that is code that's as easy as possible to read.</p>\n<p>How many lines do you think you need to read a MLX90640 camera? Well, not that much in fact.</p>\n<pre><code class=\"language-cpp\">#include &quot;EloquentMLX90640.h&quot;\n\nusing namespace Eloquent::Sensors;\n\nfloat buffer[768];\nMLX90640 camera;\n\nvoid setup() {\n  Serial.begin(115200);\n\n  if (!camera.begin()) {\n    Serial.println(&quot;Init error&quot;);\n    delay(50000);\n  }\n}\n\nvoid loop() {\n  camera.read(buffer);\n  delay(3000);\n}</code></pre>\n<p>If you skip the declaration lines, you only need a <code>begin()</code> and <code>read()</code> call.</p>\n<p>That's it.</p>\n<p>What <code>begin()</code> does is to run all of the boilerplate code I mentioned earlier (checking the connection and initializing the parameters).</p>\n<p><code>read()</code> populates the buffer you pass as argument with the temperature readings.</p>\n<p>From now on, you're free to handle that array as you may like: this is the most flexible way for the library to handle any use-case. It simply does not pose any restriction.</p>\n<p>You can find the camera code <a href=\"#anchor-camera-code\">at the end of the page</a> or <a href=\"https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/ThermalCameraToAsciiArtExample/EloquentMLX90640.h\">on Github</a>.</p>\n<h2>Printing as ASCII Art</h2>\n<p>Now that you have this data, you may want to actually &quot;view&quot; it. Well, that's not an easy task as one may hope.</p>\n<p>You will need an LCD if you want to create a standalone product. If you have one, it'll be the best, it's a really cute project to build.</p>\n<p>Here's a video from Adafruit that showcases even a 3D-printed case.</p>\n<p><iframe width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/ZjQEykbvb5w\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></p>\n<p>If you don't have an LCD, though, it is less practical to access your image.</p>\n<p>I did this in the past, and it meant creating a Python script reading the serial port every second and updating a plot.<br />\nIt works, sure, but it's not the most convenient way to handle it.</p>\n<p>This is the reason I thought about ASCII art: it is used to draw images in plain text, so you can view them directly in the serial monitor.</p>\n<p>Of course they will not be as accurate or representative as RGB images, but can give you an idea of what you're framing in realtime.</p>\n<p>I wrote a class to do this. Once imported in your sketch, it is super easy to get it working.</p>\n<pre><code class=\"language-cpp\">#include &quot;EloquentAsciiArt.h&quot;\n\nusing namespace Eloquent::ImageProcessing;\n\nfloat buffer[768];\nuint8_t bufferBytes[768];\nMLX90640 camera;\n// we need to specify width and height of the image\nAsciiArt&lt;32, 24&gt; art(bufferBytes);\n\nvoid loop() {\n  camera.read(buffer);\n\n  // convert float image to uint8\n  for (size_t i = 0; i &lt; 768; i++) {\n    // assumes readings are in the range 0-40 degrees\n    // change as per your need\n    bufferBytes[i] = map(buffer[i], 0, 40, 0, 255);\n  }\n\n  // print to Serial with a border of 2 characters, to distinguish one image from the next\n  art.print(&amp;Serial, 2);\n  delay(2000);\n}</code></pre>\n<p>As you can see, you need to create an <code>AsciiArt</code> object, map the image pixels in the range <code>0-255</code> and call the <code>print()</code> method: easy peasy!</p>\n<p>You can find the ASCII art generator code <a href=\"#anchor-ascii-art-code\">at the end of the page</a> or <a href=\"https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/ThermalCameraToAsciiArtExample/EloquentAsciiArt.h\">on Github</a>.</p>\n<p>Here's the result of the sketch. It's a video of me putting my arms at the top of my head, once at a time, then standing up.</p>\n<div class=\"watchout\">Resize the Serial Monitor as only a single frame at a time is visble to have a \"video streaming\" effect</div>\n<div style=\"width: 342px;\" class=\"wp-video\"><!--[if lt IE 9]><script>document.createElement('video');</script><![endif]-->\n<video class=\"wp-video-shortcode\" id=\"video-956-1\" width=\"342\" height=\"636\" preload=\"metadata\" controls=\"controls\"><source type=\"video/mp4\" src=\"https://eloquentarduino.github.io/wp-content/uploads/2020/02/Thermal-ascii-speedup.mp4?_=1\" /><a href=\"https://eloquentarduino.github.io/wp-content/uploads/2020/02/Thermal-ascii-speedup.mp4\">https://eloquentarduino.github.io/wp-content/uploads/2020/02/Thermal-ascii-speedup.mp4</a></video></div>\n<p>Of course the visual effect won't be as impressive as an RGB image, but you can clearly see my figure moving.</p>\n<p>The real bad part is the &quot;glitch&quot; you see between each frame when the scrolling happens: this is something I don't know if it's possible to mitigate.</p>\n<hr>\r\n<p>Check the full project code on <a href=\"https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/ThermalCameraToAsciiArtExample\" target=\"_blank\" rel=\"noopener noreferrer\">Github</a></p>\n<hr />\n<div id=\"anchor-camera-code\"></div>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include &quot;Wire.h&quot;\n#include &quot;MLX90640_API.h&quot;\n#include &quot;MLX90640_I2C_Driver.h&quot;\n\n#ifndef TA_SHIFT\n//Default shift for MLX90640 in open air\n#define TA_SHIFT 8\n#endif\n\nnamespace Eloquent {\n    namespace Sensors {\n\n        enum class MLX90640Status {\n            OK,\n            NOT_CONNECTED,\n            DUMP_ERROR,\n            PARAMETER_ERROR,\n            FRAME_ERROR\n        };\n\n        class MLX90640 {\n        public:\n            /**\n             *\n             * @param address\n             */\n            MLX90640(uint8_t address = 0x33) :\n                _address(address),\n                _status(MLX90640Status::OK) {\n\n            }\n\n            /**\n             *\n             * @return\n             */\n            bool begin() {\n                Wire.begin();\n                Wire.setClock(400000);\n\n                return isConnected() &amp;&amp; loadParams();\n            }\n\n            /**\n             *\n             * @return\n             */\n            bool read(float result[768]) {\n                for (byte x = 0 ; x &lt; 2 ; x++) {\n                    uint16_t frame[834];\n                    int status = MLX90640_GetFrameData(_address, frame);\n\n                    if (status &lt; 0)\n                        return fail(MLX90640Status::FRAME_ERROR);\n\n                    float vdd = MLX90640_GetVdd(frame, &amp;_params);\n                    float Ta = MLX90640_GetTa(frame, &amp;_params);\n                    float tr = Ta - TA_SHIFT;\n                    float emissivity = 0.95;\n\n                    MLX90640_CalculateTo(frame, &amp;_params, emissivity, tr, result);\n                }\n            }\n\n        protected:\n            uint8_t _address;\n            paramsMLX90640 _params;\n            MLX90640Status _status;\n\n            /**\n             * Test if device is connected\n             * @return\n             */\n            bool isConnected() {\n                Wire.beginTransmission(_address);\n\n                if (Wire.endTransmission() == 0) {\n                    return true;\n                }\n\n                return fail(MLX90640Status::NOT_CONNECTED);\n            }\n\n            /**\n             *\n             * @return\n             */\n            bool loadParams() {\n                uint16_t ee[832];\n                int status = MLX90640_DumpEE(_address, ee);\n\n                if (status != 0)\n                    return fail(MLX90640Status::DUMP_ERROR);\n\n                status = MLX90640_ExtractParameters(ee, &amp;_params);\n\n                if (status != 0)\n                    return fail(MLX90640Status::PARAMETER_ERROR);\n\n                return true;\n            }\n\n            /**\n             * Mark a failure\n             * @param status\n             * @return\n             */\n            bool fail(MLX90640Status status) {\n                _status = status;\n\n                return false;\n            }\n        };\n    }\n}</code></pre>\n<div id=\"anchor-ascii-art-code\"></div>\n<pre><code class=\"language-cpp\">#pragma once\n\n#include &quot;Stream.h&quot;\n\nnamespace Eloquent {\n    namespace ImageProcessing {\n\n        /**\n         *\n         * @tparam width\n         * @tparam height\n         */\n        template&lt;size_t width, size_t height&gt;\n        class AsciiArt {\n        public:\n            AsciiArt(const uint8_t *data) {\n                _data = data;\n            }\n\n            /**\n             * Get pixel at given coordinates\n             * @param x\n             * @param y\n             * @return\n             */\n            uint8_t at(size_t x, size_t y) {\n                return _data[y * width + x];\n            }\n\n            /**\n             * Print as ASCII art picture\n             * @param stream\n             */\n            void print(Stream *stream, uint8_t frameSize = 0) {\n                const char glyphs[] = &quot; .,:;xyYX&quot;;\n                const uint8_t glyphsCount = 9;\n\n                printAsciiArtHorizontalFrame(stream, frameSize);\n\n                for (size_t y = 0; y &lt; height; y++) {\n                    // vertical frame\n                    for (uint8_t k = 0; k &lt; frameSize; k++)\n                        Serial.print(&#039;|&#039;);\n\n                    for (size_t x = 0; x &lt; width; x++) {\n                        const uint8_t glyph = floor(((uint16_t) at(x, y)) * glyphsCount / 256);\n\n                        stream-&gt;print(glyphs[glyph]);\n                    }\n\n                    // vertical frame\n                    for (uint8_t k = 0; k &lt; frameSize; k++)\n                        Serial.print(&#039;|&#039;);\n\n                    stream-&gt;print(&#039;\\n&#039;);\n                }\n\n                printAsciiArtHorizontalFrame(stream, frameSize);\n                stream-&gt;flush();\n            }\n\n        protected:\n            const uint8_t *_data;\n\n            /**\n             *\n             * @param stream\n             * @param frameSize\n             */\n            void printAsciiArtHorizontalFrame(Stream *stream, uint8_t frameSize) {\n                for (uint8_t i = 0; i &lt; frameSize; i++) {\n                    for (size_t j = 0; j &lt; width + 2 * frameSize; j++)\n                        stream-&gt;print(&#039;-&#039;);\n                    stream-&gt;print(&#039;\\n&#039;);\n                }\n            }\n        };\n    }\n}</code></pre>\n<p>L'articolo <a rel=\"nofollow\" href=\"https://eloquentarduino.github.io/2020/02/easy-arduino-thermal-camera-with-ascii-video-streaming/\">Easy Arduino thermal camera with (ASCII) video streaming</a> proviene da <a rel=\"nofollow\" href=\"http://eloquentarduino.github.io/\">Eloquent Arduino Blog</a>.</p>\n",
            "content_text": "Ever wanted to use your thermal camera with Arduino but found it difficult to go beyond the tutorials code? Let's see the easiest possible way to view your thermal camera streaming without an LCD display!\n\n\nMLX90640 thermal camera\nFor Arduino there are essentially two thermal camera available: the AMG8833 and the MLX90640.\nThe AMG8833 is 8x8 and the MLX90640 is 32x24.\nThey're not cheap, it is true.\nBut if you have to spend money, I strongly advise you to buy the MLX90640: I have one and it's not that accurate. I can't imagine how low definition would be the AMG8833.\nIf you want to actually get something meaningful from the camera, the AMG8833 won't give you any good results.\nSure, you can do interpolation: interpolation would give you the impression you have a better definition, but you're just &quot;inventing&quot; values you don't actually have.\nFor demo projects it could be enough. But for any serious application, spend 20$ more and buy an MLX90640.\nMLX90640 eloquent library\nAs you may know if you read my previous posts, I strongly believe in &quot;eloquent&quot; code, that is code that's as easy as possible to read.\nHow many lines do you think you need to read a MLX90640 camera? Well, not that much in fact.\n#include &quot;EloquentMLX90640.h&quot;\n\nusing namespace Eloquent::Sensors;\n\nfloat buffer[768];\nMLX90640 camera;\n\nvoid setup() {\n  Serial.begin(115200);\n\n  if (!camera.begin()) {\n    Serial.println(&quot;Init error&quot;);\n    delay(50000);\n  }\n}\n\nvoid loop() {\n  camera.read(buffer);\n  delay(3000);\n}\nIf you skip the declaration lines, you only need a begin() and read() call.\nThat's it.\nWhat begin() does is to run all of the boilerplate code I mentioned earlier (checking the connection and initializing the parameters).\nread() populates the buffer you pass as argument with the temperature readings.\nFrom now on, you're free to handle that array as you may like: this is the most flexible way for the library to handle any use-case. It simply does not pose any restriction.\nYou can find the camera code at the end of the page or on Github.\nPrinting as ASCII Art\nNow that you have this data, you may want to actually &quot;view&quot; it. Well, that's not an easy task as one may hope.\nYou will need an LCD if you want to create a standalone product. If you have one, it'll be the best, it's a really cute project to build.\nHere's a video from Adafruit that showcases even a 3D-printed case.\n\nIf you don't have an LCD, though, it is less practical to access your image.\nI did this in the past, and it meant creating a Python script reading the serial port every second and updating a plot.\nIt works, sure, but it's not the most convenient way to handle it.\nThis is the reason I thought about ASCII art: it is used to draw images in plain text, so you can view them directly in the serial monitor.\nOf course they will not be as accurate or representative as RGB images, but can give you an idea of what you're framing in realtime.\nI wrote a class to do this. Once imported in your sketch, it is super easy to get it working.\n#include &quot;EloquentAsciiArt.h&quot;\n\nusing namespace Eloquent::ImageProcessing;\n\nfloat buffer[768];\nuint8_t bufferBytes[768];\nMLX90640 camera;\n// we need to specify width and height of the image\nAsciiArt&lt;32, 24&gt; art(bufferBytes);\n\nvoid loop() {\n  camera.read(buffer);\n\n  // convert float image to uint8\n  for (size_t i = 0; i &lt; 768; i++) {\n    // assumes readings are in the range 0-40 degrees\n    // change as per your need\n    bufferBytes[i] = map(buffer[i], 0, 40, 0, 255);\n  }\n\n  // print to Serial with a border of 2 characters, to distinguish one image from the next\n  art.print(&amp;Serial, 2);\n  delay(2000);\n}\nAs you can see, you need to create an AsciiArt object, map the image pixels in the range 0-255 and call the print() method: easy peasy!\nYou can find the ASCII art generator code at the end of the page or on Github.\nHere's the result of the sketch. It's a video of me putting my arms at the top of my head, once at a time, then standing up.\nResize the Serial Monitor as only a single frame at a time is visble to have a \"video streaming\" effect\n\nhttps://eloquentarduino.github.io/wp-content/uploads/2020/02/Thermal-ascii-speedup.mp4\nOf course the visual effect won't be as impressive as an RGB image, but you can clearly see my figure moving.\nThe real bad part is the &quot;glitch&quot; you see between each frame when the scrolling happens: this is something I don't know if it's possible to mitigate.\n\r\nCheck the full project code on Github\n\n\n#pragma once\n\n#include &quot;Wire.h&quot;\n#include &quot;MLX90640_API.h&quot;\n#include &quot;MLX90640_I2C_Driver.h&quot;\n\n#ifndef TA_SHIFT\n//Default shift for MLX90640 in open air\n#define TA_SHIFT 8\n#endif\n\nnamespace Eloquent {\n    namespace Sensors {\n\n        enum class MLX90640Status {\n            OK,\n            NOT_CONNECTED,\n            DUMP_ERROR,\n            PARAMETER_ERROR,\n            FRAME_ERROR\n        };\n\n        class MLX90640 {\n        public:\n            /**\n             *\n             * @param address\n             */\n            MLX90640(uint8_t address = 0x33) :\n                _address(address),\n                _status(MLX90640Status::OK) {\n\n            }\n\n            /**\n             *\n             * @return\n             */\n            bool begin() {\n                Wire.begin();\n                Wire.setClock(400000);\n\n                return isConnected() &amp;&amp; loadParams();\n            }\n\n            /**\n             *\n             * @return\n             */\n            bool read(float result[768]) {\n                for (byte x = 0 ; x &lt; 2 ; x++) {\n                    uint16_t frame[834];\n                    int status = MLX90640_GetFrameData(_address, frame);\n\n                    if (status &lt; 0)\n                        return fail(MLX90640Status::FRAME_ERROR);\n\n                    float vdd = MLX90640_GetVdd(frame, &amp;_params);\n                    float Ta = MLX90640_GetTa(frame, &amp;_params);\n                    float tr = Ta - TA_SHIFT;\n                    float emissivity = 0.95;\n\n                    MLX90640_CalculateTo(frame, &amp;_params, emissivity, tr, result);\n                }\n            }\n\n        protected:\n            uint8_t _address;\n            paramsMLX90640 _params;\n            MLX90640Status _status;\n\n            /**\n             * Test if device is connected\n             * @return\n             */\n            bool isConnected() {\n                Wire.beginTransmission(_address);\n\n                if (Wire.endTransmission() == 0) {\n                    return true;\n                }\n\n                return fail(MLX90640Status::NOT_CONNECTED);\n            }\n\n            /**\n             *\n             * @return\n             */\n            bool loadParams() {\n                uint16_t ee[832];\n                int status = MLX90640_DumpEE(_address, ee);\n\n                if (status != 0)\n                    return fail(MLX90640Status::DUMP_ERROR);\n\n                status = MLX90640_ExtractParameters(ee, &amp;_params);\n\n                if (status != 0)\n                    return fail(MLX90640Status::PARAMETER_ERROR);\n\n                return true;\n            }\n\n            /**\n             * Mark a failure\n             * @param status\n             * @return\n             */\n            bool fail(MLX90640Status status) {\n                _status = status;\n\n                return false;\n            }\n        };\n    }\n}\n\n#pragma once\n\n#include &quot;Stream.h&quot;\n\nnamespace Eloquent {\n    namespace ImageProcessing {\n\n        /**\n         *\n         * @tparam width\n         * @tparam height\n         */\n        template&lt;size_t width, size_t height&gt;\n        class AsciiArt {\n        public:\n            AsciiArt(const uint8_t *data) {\n                _data = data;\n            }\n\n            /**\n             * Get pixel at given coordinates\n             * @param x\n             * @param y\n             * @return\n             */\n            uint8_t at(size_t x, size_t y) {\n                return _data[y * width + x];\n            }\n\n            /**\n             * Print as ASCII art picture\n             * @param stream\n             */\n            void print(Stream *stream, uint8_t frameSize = 0) {\n                const char glyphs[] = &quot; .,:;xyYX&quot;;\n                const uint8_t glyphsCount = 9;\n\n                printAsciiArtHorizontalFrame(stream, frameSize);\n\n                for (size_t y = 0; y &lt; height; y++) {\n                    // vertical frame\n                    for (uint8_t k = 0; k &lt; frameSize; k++)\n                        Serial.print(&#039;|&#039;);\n\n                    for (size_t x = 0; x &lt; width; x++) {\n                        const uint8_t glyph = floor(((uint16_t) at(x, y)) * glyphsCount / 256);\n\n                        stream-&gt;print(glyphs[glyph]);\n                    }\n\n                    // vertical frame\n                    for (uint8_t k = 0; k &lt; frameSize; k++)\n                        Serial.print(&#039;|&#039;);\n\n                    stream-&gt;print(&#039;\\n&#039;);\n                }\n\n                printAsciiArtHorizontalFrame(stream, frameSize);\n                stream-&gt;flush();\n            }\n\n        protected:\n            const uint8_t *_data;\n\n            /**\n             *\n             * @param stream\n             * @param frameSize\n             */\n            void printAsciiArtHorizontalFrame(Stream *stream, uint8_t frameSize) {\n                for (uint8_t i = 0; i &lt; frameSize; i++) {\n                    for (size_t j = 0; j &lt; width + 2 * frameSize; j++)\n                        stream-&gt;print(&#039;-&#039;);\n                    stream-&gt;print(&#039;\\n&#039;);\n                }\n            }\n        };\n    }\n}\nL'articolo Easy Arduino thermal camera with (ASCII) video streaming proviene da Eloquent Arduino Blog.",
            "date_published": "2020-02-29T17:20:15+01:00",
            "date_modified": "2020-03-02T20:19:00+01:00",
            "authors": [
                {
                    "name": "simone",
                    "url": "https://eloquentarduino.github.io/author/simone/",
                    "avatar": "http://1.gravatar.com/avatar/d670eb91ca3b1135f213ffad83cb8de4?s=512&d=mm&r=g"
                }
            ],
            "tags": [
                "Computer vision",
                "Electronics",
                "Eloquent library"
            ],
            "attachments": [
                {
                    "url": "https://eloquentarduino.github.io/wp-content/uploads/2020/02/Thermal-ascii-speedup.mp4",
                    "mime_type": "video/mp4",
                    "size_in_bytes": 479591
                }
            ]
        }
    ]
}