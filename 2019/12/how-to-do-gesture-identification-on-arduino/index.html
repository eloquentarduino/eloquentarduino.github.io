<!DOCTYPE html>
<html lang="en-US"><head profile="http://gmpg.org/xfn/11"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" media="print" onload="this.onload=null;this.media='all';" id="ao_optimized_gfonts" href="https://fonts.googleapis.com/css?family=Lato%3A400%2C700%2C400italic%2C700italic%7CLato:400,700&display=swap"><link media="all" href="https://eloquentarduino.github.io/wp-content/cache/autoptimize/css/autoptimize_eb69c6ec6b3df139f10484f3235e9851.css" rel="stylesheet"><title>How to do Gesture identification through machine learning on Arduino</title><meta name="description" content="In this Arduno Machine learning project we're going to use an accelerometer sensor to identify the gestures you play using Machine learning."><meta name="robots" content="index, follow"><meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="How to do Gesture identification through machine learning on Arduino"><meta property="og:description" content="In this Arduno Machine learning project we're going to use an accelerometer sensor to identify the gestures you play using Machine learning."><meta property="og:url" content="https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/"><meta property="og:site_name" content="Eloquent Arduino Blog"><meta property="article:published_time" content="2019-12-19T13:25:46+00:00"><meta property="article:modified_time" content="2020-06-11T11:31:17+00:00"><meta name="twitter:card" content="summary_large_image"> <script type="application/ld+json" class="yoast-schema-graph">{"@context":"https://schema.org","@graph":[{"@type":"WebSite","@id":"https://eloquentarduino.github.io/#website","url":"https://eloquentarduino.github.io/","name":"Eloquent Arduino Blog","description":"Machine learning on Arduino, programming & electronics","publisher":{"@id":"https://eloquentarduino.github.io/#/schema/person/c35265597251f0133ecca5b413d12901"},"potentialAction":[{"@type":"SearchAction","target":"https://eloquentarduino.github.io/?s={search_term_string}","query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/#primaryimage","inLanguage":"en-US","url":"https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-RBF-kernel-0.001-gamma.png","width":700,"height":519,"caption":"Decision boundaries of 2 PCA components of Gestures features, RBF kernel, 0.001 gamma"},{"@type":"WebPage","@id":"https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/#webpage","url":"https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/","name":"How to do Gesture identification through machine learning on Arduino","isPartOf":{"@id":"https://eloquentarduino.github.io/#website"},"primaryImageOfPage":{"@id":"https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/#primaryimage"},"datePublished":"2019-12-19T13:25:46+00:00","dateModified":"2020-06-11T11:31:17+00:00","description":"In this Arduno Machine learning project we're going to use an accelerometer sensor to identify the gestures you play using Machine learning.","inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/"]}]},{"@type":"Article","@id":"https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/#article","isPartOf":{"@id":"https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/#webpage"},"author":{"@id":"https://eloquentarduino.github.io/#/schema/person/c35265597251f0133ecca5b413d12901"},"headline":"How to do Gesture identification through machine learning on Arduino","datePublished":"2019-12-19T13:25:46+00:00","dateModified":"2020-06-11T11:31:17+00:00","mainEntityOfPage":{"@id":"https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/#webpage"},"publisher":{"@id":"https://eloquentarduino.github.io/#/schema/person/c35265597251f0133ecca5b413d12901"},"image":{"@id":"https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/#primaryimage"},"keywords":"microml,svm","articleSection":"Arduino Machine learning","inLanguage":"en-US"},{"@type":["Person","Organization"],"@id":"https://eloquentarduino.github.io/#/schema/person/c35265597251f0133ecca5b413d12901","name":"simone","image":{"@type":"ImageObject","@id":"https://eloquentarduino.github.io/#personlogo","inLanguage":"en-US","url":"https://eloquentarduino.github.io/wp-content/uploads/2019/12/avatar.jpg","width":330,"height":330,"caption":"simone"},"logo":{"@id":"https://eloquentarduino.github.io/#personlogo"}}]}</script> <link rel="dns-prefetch" href="//use.fontawesome.com"><link rel="dns-prefetch" href="//s.w.org"><link href="https://fonts.gstatic.com" crossorigin="anonymous" rel="preconnect"><link rel="stylesheet" id="font-awesome-official-css" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css" type="text/css" media="all" integrity="sha384-REHJTs1r2ErKBuJB0fCK99gCYsVjwxHrSU0N7I1zl9vZbggVJXRMsv/sLlOAGb4M" crossorigin="anonymous"><link rel="stylesheet" id="font-awesome-official-v4shim-css" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css" type="text/css" media="all" integrity="sha384-AL44/7DEVqkvY9j8IjGLGZgFmHAjuHa+2RIWKxDliMNIfSs9g14/BRpYwHrWQgz6" crossorigin="anonymous"> <script type="text/javascript" src="https://eloquentarduino.github.io/wp-includes/js/jquery/jquery.js"></script> <meta name="google-site-verification" content="xgigjPrbbYDemskTaGLT9WGhmw8wgdeFtpDxVak0awI"></head><body class="post-template-default single single-post postid-35 single-format-standard has-body"><div class="wrapper"><div class="sidebar"><div class="blog-header"> <a class="blog-logo" href="https://eloquentarduino.github.io" title="Eloquent Arduino Blog â€” Machine learning on Arduino, programming & electronics" rel="home"> <noscript><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/logo-completo.png" alt="Eloquent Arduino Blog"></noscript><img class="lazyload" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20210%20140%22%3E%3C/svg%3E" data-src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/logo-completo.png" alt="Eloquent Arduino Blog"> </a></div><div class="nav-toggle toggle"><p> <span class="show">Show menu</span> <span class="hide">Hide menu</span></p><div class="bars"><div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="clear"></div></div></div><div class="blog-menu"><ul class="navigation"><li id="menu-item-461" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-461"><a href="https://eloquentarduino.github.io/category/programming/arduino-machine-learning/">Arduino Machine learning</a></li><li id="menu-item-462" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-462"><a href="https://eloquentarduino.github.io/category/programming/eloquent-library/">Eloquent library</a></li></ul><div class="clear"></div></div><div class="mobile-menu"><ul class="navigation"><li class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-461"><a href="https://eloquentarduino.github.io/category/programming/arduino-machine-learning/">Arduino Machine learning</a></li><li class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-462"><a href="https://eloquentarduino.github.io/category/programming/eloquent-library/">Eloquent library</a></li></ul></div><div class="widgets" role="complementary"><div class="widget_text widget widget_custom_html"><div class="widget_text widget-content"><div class="textwidget custom-html-widget"><div style="text-align: center"> <noscript><img src="/wp-content/uploads/2020/04/profilo.png" alt="Profile pic" style="width: 125px"></noscript><img class="lazyload" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20210%20140%22%3E%3C/svg%3E" data-src="/wp-content/uploads/2020/04/profilo.png" alt="Profile pic" style="width: 125px"> <a href="/about-me" style="display: block; font-size: 18px">About me</a></div></div></div><div class="clear"></div></div><div class="widget widget_search"><div class="widget-content"><form method="get" class="searchform" action="https://eloquentarduino.github.io" id="searchform"><div role="search" class="searchbox__wrapper"> <input id="search-input" type="search" name="search" placeholder="Search the blog" autocomplete="off" required="required" class="searchbox__input"> <button type="submit" title="Submit your search query." class="searchbox__submit"> <svg role="img" aria-label="Search"> <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#sbx-icon-search-13"></use> </svg> </button> <button type="reset" title="Clear the search query." class="searchbox__reset hide"> <svg role="img" aria-label="Reset"> <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#sbx-icon-clear-3"></use> </svg> </button></div></form></div><div class="clear"></div></div><div class="widget widget_recent_entries"><div class="widget-content"><h3 class="widget-title">Recent Posts</h3><ul><li> <a href="https://eloquentarduino.github.io/2020/08/better-word-classification-with-arduino-33-ble-sense-and-machine-learning/">Better word classification with Arduino Nano 33 BLE Sense and Machine Learning</a></li><li> <a href="https://eloquentarduino.github.io/2020/08/the-ultimate-guide-to-wifi-indoor-positioning-using-arduino-and-machine-learning/">The Ultimate Guide to Wifi Indoor Positioning using Arduino and Machine Learning</a></li><li> <a href="https://eloquentarduino.github.io/2020/08/eloquentml-grows-its-family-of-classifiers-gaussian-naive-bayes-on-arduino/">EloquentML grows its family of classifiers: Gaussian Naive Bayes on Arduino</a></li><li> <a href="https://eloquentarduino.github.io/2020/07/sefr-a-fast-linear-time-classifier-for-ultra-low-power-devices/">SEFR: A Fast Linear-Time Classifier for Ultra-Low Power Devices</a></li><li> <a href="https://eloquentarduino.github.io/2020/06/easy-esp32-camera-http-video-streaming-server/">Easy ESP32 camera HTTP video streaming server</a></li></ul></div><div class="clear"></div></div><div class="widget widget_sub_categories"><div class="widget-content"><h3 class="widget-title">Programming</h3><ul><li class="cat-item cat-item-8"><a href="https://eloquentarduino.github.io/category/programming/arduino-machine-learning/">Arduino Machine learning</a></li><li class="cat-item cat-item-12"><a href="https://eloquentarduino.github.io/category/programming/computer-vision/">Computer vision</a></li><li class="cat-item cat-item-7"><a href="https://eloquentarduino.github.io/category/programming/eloquent-library/">Eloquent library</a></li></ul></div><div class="clear"></div></div><div class="widget widget_tag_cloud"><div class="widget-content"><h3 class="widget-title">TAGS</h3><div class="tagcloud"><a href="https://eloquentarduino.github.io/tag/camera/" class="tag-cloud-link tag-link-11 tag-link-position-1" style="font-size: 14.461538461538pt;" aria-label="camera (5 items)">camera</a> <a href="https://eloquentarduino.github.io/tag/eloquent/" class="tag-cloud-link tag-link-4 tag-link-position-2" style="font-size: 12.038461538462pt;" aria-label="eloquent (3 items)">eloquent</a> <a href="https://eloquentarduino.github.io/tag/esp32/" class="tag-cloud-link tag-link-10 tag-link-position-3" style="font-size: 14.461538461538pt;" aria-label="esp32 (5 items)">esp32</a> <a href="https://eloquentarduino.github.io/tag/incremental-learning/" class="tag-cloud-link tag-link-16 tag-link-position-4" style="font-size: 8pt;" aria-label="incremental-learning (1 item)">incremental-learning</a> <a href="https://eloquentarduino.github.io/tag/microml/" class="tag-cloud-link tag-link-5 tag-link-position-5" style="font-size: 22pt;" aria-label="microml (21 items)">microml</a> <a href="https://eloquentarduino.github.io/tag/ml/" class="tag-cloud-link tag-link-17 tag-link-position-6" style="font-size: 13.384615384615pt;" aria-label="ml (4 items)">ml</a> <a href="https://eloquentarduino.github.io/tag/online-learning/" class="tag-cloud-link tag-link-15 tag-link-position-7" style="font-size: 10.423076923077pt;" aria-label="online-learning (2 items)">online-learning</a> <a href="https://eloquentarduino.github.io/tag/pca/" class="tag-cloud-link tag-link-21 tag-link-position-8" style="font-size: 8pt;" aria-label="pca (1 item)">pca</a> <a href="https://eloquentarduino.github.io/tag/rvm/" class="tag-cloud-link tag-link-13 tag-link-position-9" style="font-size: 8pt;" aria-label="rvm (1 item)">rvm</a> <a href="https://eloquentarduino.github.io/tag/svm/" class="tag-cloud-link tag-link-14 tag-link-position-10" style="font-size: 18.5pt;" aria-label="svm (11 items)">svm</a> <a href="https://eloquentarduino.github.io/tag/tinyml/" class="tag-cloud-link tag-link-20 tag-link-position-11" style="font-size: 8pt;" aria-label="tinyml (1 item)">tinyml</a></div></div><div class="clear"></div></div></div></div><div class="content"><div class="posts"><div id="post-35" class="post-35 post type-post status-publish format-standard hentry category-arduino-machine-learning tag-microml tag-svm"><div class="post-inner"><div class="post-header"><h1 class="post-title"><a href="https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/" rel="bookmark" title="How to do Gesture identification through machine learning on Arduino">How to do Gesture identification through machine learning on Arduino</a></h1><div class="post-meta"> <span class="post-date"><a href="https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/" title="How to do Gesture identification through machine learning on Arduino">19 December 2019</a></span> <span class="date-sep"> / </span> <span class="post-author"><a href="https://eloquentarduino.github.io/author/simone/" title="Posts by simone" rel="author">simone</a></span></div></div><div class="post-content"><div class="has-content-area" data-url="https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/" data-title="How to do Gesture identification through machine learning on Arduino"><p>In this Arduno Machine learning project we're going to use an accelerometer sensor to identify the gestures you play.<br> This is a remake of the project found on the <a href="https://blog.tensorflow.org/2019/11/how-to-get-started-with-machine.html">Tensorflow blog</a>. We're going to use a lot less powerful chip in this tutorial, tough: an Arduino Nano (old generation), equipped with 32 kb of flash and only 2 kb of RAM.</p><p><noscript><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-RBF-kernel-0.001-gamma.png" alt="Decision boundaries, 99% accuracy"></noscript><img class="lazyload" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20210%20140%22%3E%3C/svg%3E" data-src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-RBF-kernel-0.001-gamma.png" alt="Decision boundaries, 99% accuracy"></p><p><span id="more-35"></span></p><p></p><div class="toc"><h6>Table of contents</h6><ol><li><a href="#tocfeatures-definition">Features definition</a></li><li><a href="#tocrecord-sample-data">Record sample data</a><ol><li><a href="#tocread-the-imu-sensor">Read the IMU sensor</a></li><li><a href="#toccalibration">Calibration</a></li><li><a href="#tocdetect-first-motion">Detect first motion</a></li><li><a href="#tocrecord-features">Record features</a></li></ol></li><li><a href="#toctrain-and-export-the-svm-classifier">Train and export the SVM classifier</a><ol><li><a href="#tocselect-a-suitable-model">Select a suitable model</a></li></ol></li><li><a href="#tocrun-the-inference">Run the inference</a></li></ol></div><h2 id="tocfeatures-definition">1. Features definition</h2><p>We're going to use the accelerations along the 3 axis (X, Y, Z) coming from an <a href="https://en.wikipedia.org/wiki/Inertial_measurement_unit">IMU</a> to infer which gesture we're playing. We'll use a fixed number of recordings (<code>NUM_SAMPLES</code>) starting from the first detection of movement.</p><p>This means our feature vectors are going to be of dimension <code>3 * NUM_SAMPLES</code>, which can become too large to fit in the memory of the Arduino Nano. We'll start with a low value for <code>NUM_SAMPLES</code> to keep it as leaner as possible: if your classifications suffer from poor accuracy, you can increase this number.</p><h2 id="tocrecord-sample-data">2. Record sample data</h2><h3 id="tocread-the-imu-sensor">2.1 Read the IMU sensor</h3><p>First of all, we need to read the raw data from the IMU. This piece of code will be different based on the specific chip you use. To keep things consistent, we'll wrap the IMU logic in 2 functions: <code>imu_setup</code> and <code>imu_read</code>.</p><p>I'll report a couple of example implementations for the <code>MPU6050</code> and the <code>MPU9250</code> (these are the chip I have at hand). You should save whichever code you use in a file called <code>imu.h</code>.</p><pre><code class="language-cpp">#include "Wire.h"
// library from https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050
#include "MPU6050.h"
#define OUTPUT_READABLE_ACCELGYRO

MPU6050 imu;

void imu_setup() {
    Wire.begin();
    imu.initialize();
}

void imu_read(float *ax, float *ay, float *az) {
    int16_t _ax, _ay, _az, _gx, _gy, _gz;

    imu.getMotion6(&_ax, &_ay, &_az, &_gx, &_gy, &_gz);

    *ax = _ax;
    *ay = _ay;
    *az = _az;
}</code></pre><pre><code class="language-cpp">#include "Wire.h"
// library from https://github.com/bolderflight/MPU9250
#include "MPU9250.h"

MPU9250 imu(Wire, 0x68);

void imu_setup() {
    Wire.begin();
    imu.begin();
}

void imu_read(float *ax, float *ay, float *az) {
    imu.readSensor();

    *ax = imu.getAccelX_mss();
    *ay = imu.getAccelY_mss();
    *az = imu.getAccelZ_mss();
}</code></pre><p>In the main .ino file, we dump the values to Serial monitor / plotter.</p><pre><code class="language-cpp">#include "imu.h"

#define NUM_SAMPLES 30
#define NUM_AXES 3
// sometimes you may get "spikes" in the readings
// set a sensible value to truncate too large values
#define TRUNCATE_AT 20

double features[NUM_SAMPLES * NUM_AXES];

void setup() {
    Serial.begin(115200);
    imu_setup();
}

void loop() {
    float ax, ay, az;

    imu_read(&ax, &ay, &az);

    ax = constrain(ax, -TRUNCATE_AT, TRUNCATE_AT);
    ay = constrain(ay, -TRUNCATE_AT, TRUNCATE_AT);
    az = constrain(az, -TRUNCATE_AT, TRUNCATE_AT);

    Serial.print(ax);
    Serial.print('\t');
    Serial.print(ay);
    Serial.print('\t');
    Serial.println(az);
}</code></pre><p>Open the Serial plotter and make some movement to have an idea of the range of your readings.</p><p><noscript><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Raw-gestures.gif%22" alt="Raw IMU readings for the gestures identification project"></noscript><img class="lazyload" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20210%20140%22%3E%3C/svg%3E" data-src='https://eloquentarduino.github.io/wp-content/uploads/2019/12/Raw-gestures.gif"' alt="Raw IMU readings for the gestures identification project"></p><h3 id="toccalibration">2.2 Calibration</h3><p>Due to gravity, we get a stable value of -9.8 on the Z axis at rest (you can see this in the previous image). Since I'd like to have almost 0 at rest, I created a super simple calibration procedure to remove this fixed offset from the readings.</p><pre><code class="language-cpp">double baseline[NUM_AXES];
double features[NUM_SAMPLES * NUM_AXES];

void setup() {
    Serial.begin(115200);
    imu_setup();
    calibrate();
}

void loop() {
    float ax, ay, az;

    imu_read(&ax, &ay, &az);

    ax = constrain(ax - baseline[0], -TRUNCATE, TRUNCATE);
    ay = constrain(ay - baseline[1], -TRUNCATE, TRUNCATE);
    az = constrain(az - baseline[2], -TRUNCATE, TRUNCATE);
}

void calibrate() {
    float ax, ay, az;

    for (int i = 0; i < 10; i++) {
        imu_read(&ax, &ay, &az);
        delay(100);
    }

    baseline[0] = ax;
    baseline[1] = ay;
    baseline[2] = az;
}</code></pre><p><noscript><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Calibrated-gestures.gif" alt="Calibrated IMU readings for the gestures identification project"></noscript><img class="lazyload" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20210%20140%22%3E%3C/svg%3E" data-src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Calibrated-gestures.gif" alt="Calibrated IMU readings for the gestures identification project"></p><p>Much better.</p><h3 id="tocdetect-first-motion">2.3 Detect first motion</h3><p>Now we need to check if motion is happening. To keep it simple, we'll use a naive approach that will look for an high value in the acceleration: if a threshold is exceeded, a gesture is starting.</p><p>If you did the calibration step, a threshold of 5 should work well. If you didn't calibrate, you have to come up with a value that suits your needs.</p><pre><code class="language-cpp">#include imu.h

#define ACCEL_THRESHOLD 5

void loop() {
    float ax, ay, az;

    imu_read(&ax, &ay, &az);

    ax = constrain(ax - baseline[0], -TRUNCATE, TRUNCATE);
    ay = constrain(ay - baseline[1], -TRUNCATE, TRUNCATE);
    az = constrain(az - baseline[2], -TRUNCATE, TRUNCATE);

    if (!motionDetected(ax, ay, az)) {
        delay(10);
        return;
    }
}

bool motionDetected(float ax, float ay, float az) {
    return (abs(ax) + abs(ay) + abs(az)) > ACCEL_THRESHOLD;
}</code></pre><h3 id="tocrecord-features">2.4 Record features</h3><p>If no motion is happening, we don't take any action and keep watching. If motion is happening, we print the next <code>NUM_SAMPLES</code> readings to Serial.</p><pre><code class="language-cpp">void loop() {
    float ax, ay, az;

    imu_read(&ax, &ay, &az);

    ax = constrain(ax - baseline[0], -TRUNCATE, TRUNCATE);
    ay = constrain(ay - baseline[1], -TRUNCATE, TRUNCATE);
    az = constrain(az - baseline[2], -TRUNCATE, TRUNCATE);

    if (!motionDetected(ax, ay, az)) {
        delay(10);
        return;
    }

    recordIMU();
    printFeatures();
    delay(2000);
}

void recordIMU() {
    float ax, ay, az;

    for (int i = 0; i < NUM_SAMPLES; i++) {
        imu_read(&ax, &ay, &az);

        ax = constrain(ax - baseline[0], -TRUNCATE, TRUNCATE);
        ay = constrain(ay - baseline[1], -TRUNCATE, TRUNCATE);
        az = constrain(az - baseline[2], -TRUNCATE, TRUNCATE);

        features[i * NUM_AXES + 0] = ax;
        features[i * NUM_AXES + 1] = ay;
        features[i * NUM_AXES + 2] = az;

        delay(INTERVAL);
    }
}</code></pre><pre><code class="language-cpp">
void printFeatures() {
    const uint16_t numFeatures = sizeof(features) / sizeof(double);
    
    for (int i = 0; i < numFeatures; i++) {
        Serial.print(features[i]);
        Serial.print(i == numFeatures - 1 ? 'n' : ',');
    }
}
</code></pre><p>Record 15-20 samples for each geasture and save them to a file, one for each gesture. Since we're dealing with highly dimensional data, you should collect as much samples as possible, to average out the noise.</p><h2 id="toctrain-and-export-the-svm-classifier">3. Train and export the SVM classifier</h2><p>For a detailed guide refer to the <a href="/2019/11/how-to-train-a-classifier-in-scikit-learn/" target="_blank" rel="noopener noreferrer">tutorial</a></p><p></p><pre><code class="language-python">from sklearn.svm import SVC
from micromlgen import port

# put your samples in the dataset folder
# one class per file
# one feature vector per line, in CSV format
features, classmap = load_features('dataset/')
X, y = features[:, :-1], features[:, -1]
classifier = SVC(kernel='linear').fit(X, y)
c_code = port(classifier, classmap=classmap)
print(c_code)</code></pre><p>At this point you have to copy the printed code and import it in your Arduino project, in a file called <code>model.h</code>.</p><p>In this project on Machine learning, differently from the previous and simpler ones, we're not achieving 100% accuracy easily. Motion is quite noise, so you should experiment with a few params for the classifier and choose the ones that perform best. I'll showcase a few examples:</p><p><noscript><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-Linear-kernel.png" alt="Decision boundaries of 2 PCA components of Gestures features, Linear kernel"></noscript><img class="lazyload" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20210%20140%22%3E%3C/svg%3E" data-src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-Linear-kernel.png" alt="Decision boundaries of 2 PCA components of Gestures features, Linear kernel"></p><p><noscript><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-Polynomial-kernel.png" alt="Decision boundaries of 2 PCA components of Gestures features, Polynomial kernel"></noscript><img class="lazyload" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20210%20140%22%3E%3C/svg%3E" data-src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-Polynomial-kernel.png" alt="Decision boundaries of 2 PCA components of Gestures features, Polynomial kernel"></p><p><noscript><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-RBF-kernel-0.01-gamma.png" alt="Decision boundaries of 2 PCA components of Gestures features, RBF kernel, 0.01 gamma"></noscript><img class="lazyload" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20210%20140%22%3E%3C/svg%3E" data-src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-RBF-kernel-0.01-gamma.png" alt="Decision boundaries of 2 PCA components of Gestures features, RBF kernel, 0.01 gamma"></p><p><noscript><img src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-RBF-kernel-0.001-gamma.png" alt="Decision boundaries of 2 PCA components of Gestures features, RBF kernel, 0.001 gamma"></noscript><img class="lazyload" src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20210%20140%22%3E%3C/svg%3E" data-src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Decision-boundaries-of-2-PCA-components-of-Gestures-features-RBF-kernel-0.001-gamma.png" alt="Decision boundaries of 2 PCA components of Gestures features, RBF kernel, 0.001 gamma"></p><h3 id="tocselect-a-suitable-model">3.1 Select a suitable model</h3><p>Now that we selected the best model, we have to export it to C code. Here comes the culprit: not all models will fit on your board.</p><p>The core of SVM (Support Vector Machines) are support vectors: each trained classifier will be characterized by a certain number of them. The problem is: if there're too much, the generated code will be too large to fit in your flash.</p><p>For this reason, instead of selecting <em>the best</em> model on accuracy, you should make a ranking, from the best performing to the worst. For each model, starting from the top, you should import it in your Arduino project and try to compile: if it fits, fine, you're done. Otherwise you should pick the next and try again.</p><p>It may seem a tedious process, but keep in mind that we're trying to infer a class from 90 features in 2 Kb of RAM and 32 Kb of flash: I think this is an acceptable tradeoff.</p> <span class="bctt-click-to-tweet"><span class="bctt-ctt-text"><a href="https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-gesture-identification-on-arduino%2F&text=We%27re%20fitting%20a%20model%20to%20infer%20a%20class%20from%2090%20features%20in%202%20Kb%20of%20RAM%20and%2032%20Kb%20of%20flash%21&via=EloquentArduino&related=EloquentArduino" target="_blank" rel="noopener noreferrer">We're fitting a model to infer a class from 90 features in 2 Kb of RAM and 32 Kb of flash! </a></span><a href="https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-gesture-identification-on-arduino%2F&text=We%27re%20fitting%20a%20model%20to%20infer%20a%20class%20from%2090%20features%20in%202%20Kb%20of%20RAM%20and%2032%20Kb%20of%20flash%21&via=EloquentArduino&related=EloquentArduino" target="_blank" class="bctt-ctt-btn" rel="noopener noreferrer">Click To Tweet</a></span><p>I'll report a few figures for different combinations I tested.</p><table><thead><tr><th style="text-align: left;">Kernel</th><th style="text-align: center;">C</th><th style="text-align: center;">Gamma</th><th style="text-align: center;">Degree</th><th style="text-align: center;">Vectors</th><th style="text-align: center;">Flash size</th><th style="text-align: center;">RAM (b)</th><th style="text-align: center;">Avg accuracy</th></tr></thead><tbody><tr><td style="text-align: left;">RBF</td><td style="text-align: center;">10</td><td style="text-align: center;">0.001</td><td style="text-align: center;">-</td><td style="text-align: center;">37</td><td style="text-align: center;">53 Kb</td><td style="text-align: center;">1228</td><td style="text-align: center;">99%</td></tr><tr><td style="text-align: left;"><strong>Poly</strong></td><td style="text-align: center;"><strong>100</strong></td><td style="text-align: center;"><strong>0.001</strong></td><td style="text-align: center;"><strong>2</strong></td><td style="text-align: center;"><strong>12</strong></td><td style="text-align: center;"><strong>25 Kb</strong></td><td style="text-align: center;"><strong>1228</strong></td><td style="text-align: center;"><strong>99%</strong></td></tr><tr><td style="text-align: left;">Poly</td><td style="text-align: center;">100</td><td style="text-align: center;">0.001</td><td style="text-align: center;">3</td><td style="text-align: center;">25</td><td style="text-align: center;">40 Kb</td><td style="text-align: center;">1228</td><td style="text-align: center;">97%</td></tr><tr><td style="text-align: left;">Linear</td><td style="text-align: center;">50</td><td style="text-align: center;">-</td><td style="text-align: center;">1</td><td style="text-align: center;">40</td><td style="text-align: center;">55 Kb</td><td style="text-align: center;">1228</td><td style="text-align: center;">95%</td></tr><tr><td style="text-align: left;">RBF</td><td style="text-align: center;">100</td><td style="text-align: center;">0.01</td><td style="text-align: center;">-</td><td style="text-align: center;">61</td><td style="text-align: center;">80 Kb</td><td style="text-align: center;">1228</td><td style="text-align: center;">95%</td></tr></tbody></table><p>As you can see, we achieved a very high accuracy on the test set for all the classifiers: only one, though, fitted on the Arduino Nano. Of course, if you use a larger board, you can deploy the others too.</p><div class="infobox">As a side note, take a look at the <code>RAM</code> column: all the values are equal: this is because in the implementation is independant from the number of support vectors and only depends on the number of features.</div><h2 id="tocrun-the-inference">4. Run the inference</h2><pre><code class="language-cpp">#include "model.h"

void loop() {
    float ax, ay, az;

    imu_read(&ax, &ay, &az);

    ax = constrain(ax - baseline[0], -TRUNCATE, TRUNCATE);
    ay = constrain(ay - baseline[1], -TRUNCATE, TRUNCATE);
    az = constrain(az - baseline[2], -TRUNCATE, TRUNCATE);

    if (!motionDetected(ax, ay, az)) {
        delay(10);
        return;
    }

    recordIMU();
    classify();
    delay(2000);
}

void classify() {
    Serial.print("Detected gesture: ");
    Serial.println(classIdxToName(predict(features)));
}</code></pre><p>Here we are: it has been a long post, but now you can classify gestures with an Arduino Nano and 2 Kb of RAM.</p> <span class="bctt-click-to-tweet"><span class="bctt-ctt-text"><a href="https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-gesture-identification-on-arduino%2F&text=No%20fancy%20Neural%20Networks%2C%20no%20Tensorflow%2C%20no%2032-bit%20ARM%20processors%3A%20plain%20old%20SVM%20on%20plain%20old%208%20bits%20with%2097%25%20accuracy.&via=EloquentArduino&related=EloquentArduino" target="_blank" rel="noopener noreferrer">No fancy Neural Networks, no Tensorflow, no 32-bit ARM processors: plain old SVM on plain old 8 bits with 97% accuracy. </a></span><a href="https://twitter.com/intent/tweet?url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-gesture-identification-on-arduino%2F&text=No%20fancy%20Neural%20Networks%2C%20no%20Tensorflow%2C%20no%2032-bit%20ARM%20processors%3A%20plain%20old%20SVM%20on%20plain%20old%208%20bits%20with%2097%25%20accuracy.&via=EloquentArduino&related=EloquentArduino" target="_blank" class="bctt-ctt-btn" rel="noopener noreferrer">Click To Tweet</a></span><p>Here's a short demo of me playing 3 gestures and getting the results on the serial monitor.</p><div style="width: 640px;" class="wp-video"><video class="wp-video-shortcode" id="video-35-1" width="640" height="360" preload="metadata" controls="controls"><source type="video/mp4" src="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Gesture-identification-in-action.mp4?_=1"></source><a href="https://eloquentarduino.github.io/wp-content/uploads/2019/12/Gesture-identification-in-action.mp4">https://eloquentarduino.github.io/wp-content/uploads/2019/12/Gesture-identification-in-action.mp4</a></video></div><p></p><h4>Project figures</h4><p>On my machine, the sketch targeted at the Arduino Nano (old generation) requires 25310 bytes (82%) of program space and 1228 bytes (59%) of RAM. This means you could actually run machine learning in even less space than what the Arduino Nano provides. So, the answer to the question <em>Can I run machine learning on Arduino?</em> is <strong>definetly YES</strong>.<br> <br></p><p>Did you find this tutorial useful? Was is it easy to follow or did I miss something? Let me know in the comments so I can keep improving the blog.</p><br><hr><p>Check the full project code on <a href="https://github.com/eloquentarduino/EloquentArduino/blob/master/examples/MicromlGestureIdentificationExample/MicromlGestureIdentificationExample.ino" target="_blank" rel="noopener noreferrer">Github</a></p></div><div class="heateorSssClear"></div><div class="heateor_sss_sharing_container heateor_sss_horizontal_sharing" heateor-sss-data-href="https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/"><div class="heateor_sss_sharing_title" style="font-weight:bold">Help the blow grow</div><ul class="heateor_sss_sharing_ul"><li class="heateorSssSharingRound"><i style="width:35px;height:35px;border-radius:999px;" alt="Facebook" title="Facebook" class="heateorSssSharing heateorSssFacebookBackground" onclick='heateorSssPopup("https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-gesture-identification-on-arduino%2F")'><ss style="display:block;border-radius:999px;" class="heateorSssSharingSvg heateorSssFacebookSvg"></ss></i></li><li class="heateorSssSharingRound"><i style="width:35px;height:35px;border-radius:999px;" alt="Twitter" title="Twitter" class="heateorSssSharing heateorSssTwitterBackground" onclick='heateorSssPopup("http://twitter.com/intent/tweet?via=ArduinoEloquent&text=How%20to%20do%20Gesture%20identification%20through%20machine%20learning%20on%20Arduino&url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-gesture-identification-on-arduino%2F")'><ss style="display:block;border-radius:999px;" class="heateorSssSharingSvg heateorSssTwitterSvg"></ss></i></li><li class="heateorSssSharingRound"><i style="width:35px;height:35px;border-radius:999px;" alt="Linkedin" title="Linkedin" class="heateorSssSharing heateorSssLinkedinBackground" onclick='heateorSssPopup("http://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-gesture-identification-on-arduino%2F&title=How%20to%20do%20Gesture%20identification%20through%20machine%20learning%20on%20Arduino")'><ss style="display:block;border-radius:999px;" class="heateorSssSharingSvg heateorSssLinkedinSvg"></ss></i></li><li class="heateorSssSharingRound"><i style="width:35px;height:35px;border-radius:999px;" title="More" alt="More" class="heateorSssSharing heateorSssMoreBackground" onclick="heateorSssMoreSharingPopup(this, 'https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/', 'How%20to%20do%20Gesture%20identification%20through%20machine%20learning%20on%20Arduino', '' )"><ss style="display:block" class="heateorSssSharingSvg heateorSssMoreSvg"></ss></i></li></ul><div class="heateorSssClear"></div></div><div class="heateorSssClear"></div><div class="heateor_sss_sharing_container heateor_sss_vertical_sharing heateor_sss_bottom_sharing" style="width:44px;right: -10px;top: 100px;-webkit-box-shadow:none;box-shadow:none;" heateor-sss-data-href="https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/"><ul class="heateor_sss_sharing_ul"><li class=""><i style="width:40px;height:40px;margin:0;" alt="Facebook" title="Facebook" class="heateorSssSharing heateorSssFacebookBackground" onclick='heateorSssPopup("https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-gesture-identification-on-arduino%2F")'><ss style="display:block;" class="heateorSssSharingSvg heateorSssFacebookSvg"></ss></i></li><li class=""><i style="width:40px;height:40px;margin:0;" alt="Twitter" title="Twitter" class="heateorSssSharing heateorSssTwitterBackground" onclick='heateorSssPopup("http://twitter.com/intent/tweet?via=ArduinoEloquent&text=How%20to%20do%20Gesture%20identification%20through%20machine%20learning%20on%20Arduino&url=http%3A%2F%2Feloquent.blog%2F2019%2F12%2Fhow-to-do-gesture-identification-on-arduino%2F")'><ss style="display:block;" class="heateorSssSharingSvg heateorSssTwitterSvg"></ss></i></li><li class=""><i style="width:40px;height:40px;margin:0;" title="More" alt="More" class="heateorSssSharing heateorSssMoreBackground" onclick="heateorSssMoreSharingPopup(this, 'https://eloquentarduino.github.io/2019/12/how-to-do-gesture-identification-on-arduino/', 'How%20to%20do%20Gesture%20identification%20through%20machine%20learning%20on%20Arduino', '' )"><ss style="display:block" class="heateorSssSharingSvg heateorSssMoreSvg"></ss></i></li></ul><div class="heateorSssClear"></div></div><div class="crp_related  "><h3>Related Posts</h3><ul><li><a href="https://eloquentarduino.github.io/2020/03/how-to-train-a-color-classification-machine-learning-classifier-directly-on-your-arduino-board/" class="post-988"><span class="crp_title">How to train a color classification Machine learning classifier directly on your Arduino board</span></a></li><li><a href="https://eloquentarduino.github.io/2020/03/how-to-train-a-iris-classification-machine-learning-classifier-directly-on-your-arduino-board/" class="post-1008"><span class="crp_title">How to train a IRIS classification Machine learning classifier directly on your Arduino board</span></a></li><li><a href="https://eloquentarduino.github.io/2020/08/better-word-classification-with-arduino-33-ble-sense-and-machine-learning/" class="post-1282"><span class="crp_title">Better word classification with Arduino Nano 33 BLE Sense and Machine Learning</span></a></li><li><a href="https://eloquentarduino.github.io/2020/06/arduino-dimensionality-reduction-pca-for-machine-learning-projects/" class="post-1174"><span class="crp_title">Arduino dimensionality reduction (PCA) for Machine Learning projects</span></a></li></ul><div class="crp_clear"></div></div><div id="disqus_thread"></div></div><div class="clear"></div></div></div></div><div class="post-meta-bottom"><div class="post-cat-tags"><p class="post-categories"><span>Categories:</span> <a href="https://eloquentarduino.github.io/category/programming/arduino-machine-learning/" rel="category tag">Arduino Machine learning</a></p><p class="post-tags">Tags: <a href="https://eloquentarduino.github.io/tag/microml/" rel="tag">microml</a>, <a href="https://eloquentarduino.github.io/tag/svm/" rel="tag">svm</a></p></div><div class="archive-nav post-nav"> <a class="post-nav-older" title="Previous post: Eloquent pin management: the Pin class" href="https://eloquentarduino.github.io/2019/12/arduino-pin-class/"> Â« Eloquent pin management: the Pin class </a> <a class="post-nav-newer" title="Next post: Wifi indoor positioning using Arduino and Machine Learning in 4 steps" href="https://eloquentarduino.github.io/2019/12/wifi-indoor-positioning-on-arduino/"> Wifi indoor positioning using Arduino and Machine Learning in 4 steps Â» </a><div class="clear"></div></div></div><p class="nocomments">Comments are closed.</p><div class="footer section large-padding bg-dark"><div class="clear"></div></div><div class="credits"><div class="credits-inner"><p class="credits-left">Â© 2020 <a href="https://eloquentarduino.github.io" title="Eloquent Arduino Blog">Eloquent Arduino Blog</a></p><p class="credits-right"><span>Theme by <a href="https://www.andersnoren.se">Anders NorÃ©n</a></span> â€” <a title="To the top" class="tothetop">Up â†‘</a></p><div class="clear"></div></div></div></div><div class="clear"></div></div> <script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script> <script src="//cdn.jsdelivr.net/autocomplete.js/0/autocomplete.min.js"></script>  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-154550080-1"></script> <script>if (window.location.href.indexOf("eloquent.blog") < 0) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154550080-1');
}</script>  <script>(function() {
setTimeout(function() {
  var d = document, s = d.createElement('script');
  s.src = 'https://eloquent-arduino.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);},
10000);
})();</script>  <noscript><style>.lazyload{display:none;}</style></noscript><script data-noptimize="1">window.lazySizesConfig=window.lazySizesConfig||{};window.lazySizesConfig.loadMode=1;</script><script async data-noptimize="1" src="https://eloquentarduino.github.io/wp-content/plugins/autoptimize/classes/external/js/lazysizes.min.js"></script> <link rel="stylesheet" id="fontawesome5-css" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" type="text/css" media="all"> <script type="text/javascript">function heateorSssLoadEvent(e) {var t=window.onload;if (typeof window.onload!="function") {window.onload=e}else{window.onload=function() {t();e()}}};	var heateorSssSharingAjaxUrl = 'https://eloquentarduino.github.io/wp-admin/admin-ajax.php', heateorSssCloseIconPath = 'https://eloquentarduino.github.io/wp-content/plugins/sassy-social-share/public/../images/close.png', heateorSssPluginIconPath = 'https://eloquentarduino.github.io/wp-content/plugins/sassy-social-share/public/../images/logo.png', heateorSssHorizontalSharingCountEnable = 0, heateorSssVerticalSharingCountEnable = 0, heateorSssSharingOffset = -10; var heateorSssMobileStickySharingEnabled = 1;var heateorSssCopyLinkMessage = "Link copied.";var heateorSssUrlCountFetched = [], heateorSssSharesText = 'Shares', heateorSssShareText = 'Share';function heateorSssPopup(e) {window.open(e,"popUpWindow","height=400,width=600,left=400,top=100,resizable,scrollbars,toolbar=0,personalbar=0,menubar=no,location=no,directories=no,status")};var heateorSssWhatsappShareAPI = "web";</script> <script type="text/javascript" src="https://eloquentarduino.github.io/wp-includes/js/dist/vendor/wp-polyfill.min.js"></script> <script type="text/javascript">( 'fetch' in window ) || document.write( '<script src="https://eloquentarduino.github.io/wp-includes/js/dist/vendor/wp-polyfill-fetch.min.js?ver=3.0.0">' + 'ipt>' );( document.contains ) || document.write( '<script src="https://eloquentarduino.github.io/wp-includes/js/dist/vendor/wp-polyfill-node-contains.min.js?ver=3.26.0-0">' + 'ipt>' );( window.FormData && window.FormData.prototype.keys ) || document.write( '<script src="https://eloquentarduino.github.io/wp-includes/js/dist/vendor/wp-polyfill-formdata.min.js?ver=3.0.12">' + 'ipt>' );( Element.prototype.matches && Element.prototype.closest ) || document.write( '<script src="https://eloquentarduino.github.io/wp-includes/js/dist/vendor/wp-polyfill-element-closest.min.js?ver=2.0.2">' + 'ipt>' );</script> <script type="text/javascript" src="https://eloquentarduino.github.io/wp-includes/js/dist/i18n.min.js"></script> <script type="text/javascript">var highlight_and_share = {"show_facebook":"1","show_twitter":"1","show_linkedin":"1","show_pinterest":"","show_email":"","show_xing":"","show_copy":"","show_whatsapp":"","twitter_username":"EloquentArduino","twitter_fa_class":"fa fa-twitter","facebook_fa_class":"fa fa-facebook","linkedin_fa_class":"fa fa-linkedin","pinterest_fa_class":"fa fa-pinterest","xing_fa_class":"fa fa-xing","whatsapp_fa_class":"fa fa-whatsapp","copy_fa_class":"fa fa-copy","email_fa_class":"fa fa-envelope","mobile":"","content":".has-content-area","tweet_text":"Tweet","facebook_text":"Share","linkedin_text":"LinkedIn","pinterest_text":"Pinterest","whatsapp_text":"WhatsApp","xing_text":"Xing","copy_text":"Copy","email_text":"E-mail","icons":"1","facebook_app_id":"2530754057166153","email_your_name_value":"","email_from_value":"","nonce":"d9b9d3cc37","ajax_url":"https:\/\/eloquentarduino.github.io\/wp-admin\/admin-ajax.php","email_share":"Share This Post Via Email","email_subject":"Your Subject","email_your_name":"Your Name","email_send_email":"Send to Email Address","email_subject_text":"[Shared Post] %title%","email_from":"Your Email Address","email_send":"Send Email","email_cancel":"Cancel","email_close":"Close","email_loading":"https:\/\/eloquentarduino.github.io\/wp-content\/plugins\/highlight-and-share\/img\/loading.gif","email_subject_error":"You must fill in a subject.","email_email_to":"Send to Email Address is blank.","email_email_from":"Your email address is blank.","email_email_name":"Your name is blank.","email_sending":"Sending...","customizer_preview":""};</script> <script type="text/javascript">( function( domain, translations ) {
	var localeData = translations.locale_data[ domain ] || translations.locale_data.messages;
	localeData[""].domain = domain;
	wp.i18n.setLocaleData( localeData, domain );
} )( "highlight-and-share", { "locale_data": { "messages": { "": {} } } } );</script> <script type="text/javascript">var mejsL10n = {"language":"en","strings":{"mejs.install-flash":"You are using a browser that does not have Flash player enabled or installed. Please turn on your Flash player plugin or download the latest version from https:\/\/get.adobe.com\/flashplayer\/","mejs.fullscreen-off":"Turn off Fullscreen","mejs.fullscreen-on":"Go Fullscreen","mejs.download-video":"Download Video","mejs.fullscreen":"Fullscreen","mejs.time-jump-forward":["Jump forward 1 second","Jump forward %1 seconds"],"mejs.loop":"Toggle Loop","mejs.play":"Play","mejs.pause":"Pause","mejs.close":"Close","mejs.time-slider":"Time Slider","mejs.time-help-text":"Use Left\/Right Arrow keys to advance one second, Up\/Down arrows to advance ten seconds.","mejs.time-skip-back":["Skip back 1 second","Skip back %1 seconds"],"mejs.captions-subtitles":"Captions\/Subtitles","mejs.captions-chapters":"Chapters","mejs.none":"None","mejs.mute-toggle":"Mute Toggle","mejs.volume-help-text":"Use Up\/Down Arrow keys to increase or decrease volume.","mejs.unmute":"Unmute","mejs.mute":"Mute","mejs.volume-slider":"Volume Slider","mejs.video-player":"Video Player","mejs.audio-player":"Audio Player","mejs.ad-skip":"Skip ad","mejs.ad-skip-info":["Skip in 1 second","Skip in %1 seconds"],"mejs.source-chooser":"Source Chooser","mejs.stop":"Stop","mejs.speed-rate":"Speed Rate","mejs.live-broadcast":"Live Broadcast","mejs.afrikaans":"Afrikaans","mejs.albanian":"Albanian","mejs.arabic":"Arabic","mejs.belarusian":"Belarusian","mejs.bulgarian":"Bulgarian","mejs.catalan":"Catalan","mejs.chinese":"Chinese","mejs.chinese-simplified":"Chinese (Simplified)","mejs.chinese-traditional":"Chinese (Traditional)","mejs.croatian":"Croatian","mejs.czech":"Czech","mejs.danish":"Danish","mejs.dutch":"Dutch","mejs.english":"English","mejs.estonian":"Estonian","mejs.filipino":"Filipino","mejs.finnish":"Finnish","mejs.french":"French","mejs.galician":"Galician","mejs.german":"German","mejs.greek":"Greek","mejs.haitian-creole":"Haitian Creole","mejs.hebrew":"Hebrew","mejs.hindi":"Hindi","mejs.hungarian":"Hungarian","mejs.icelandic":"Icelandic","mejs.indonesian":"Indonesian","mejs.irish":"Irish","mejs.italian":"Italian","mejs.japanese":"Japanese","mejs.korean":"Korean","mejs.latvian":"Latvian","mejs.lithuanian":"Lithuanian","mejs.macedonian":"Macedonian","mejs.malay":"Malay","mejs.maltese":"Maltese","mejs.norwegian":"Norwegian","mejs.persian":"Persian","mejs.polish":"Polish","mejs.portuguese":"Portuguese","mejs.romanian":"Romanian","mejs.russian":"Russian","mejs.serbian":"Serbian","mejs.slovak":"Slovak","mejs.slovenian":"Slovenian","mejs.spanish":"Spanish","mejs.swahili":"Swahili","mejs.swedish":"Swedish","mejs.tagalog":"Tagalog","mejs.thai":"Thai","mejs.turkish":"Turkish","mejs.ukrainian":"Ukrainian","mejs.vietnamese":"Vietnamese","mejs.welsh":"Welsh","mejs.yiddish":"Yiddish"}};</script> <script type="text/javascript">var _wpmejsSettings = {"pluginPath":"\/wp-includes\/js\/mediaelement\/","classPrefix":"mejs-","stretching":"responsive"};</script> <script defer src="https://eloquentarduino.github.io/wp-content/cache/autoptimize/js/autoptimize_c57c718ee0746b3c35bdddf3f4dc5525.js"></script></body></html>
